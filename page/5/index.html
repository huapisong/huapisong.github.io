<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  

  
  
  
  
  
  
  <title>随记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="随记">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="随记">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="随记">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src="//push.zhanzhang.baidu.com/push.js"></script>
</head></html>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="随记" rel="home">随记</a>
      </h1>
      
        <h2 class="site-description hitokoto"></h2>
        <script type="text/javascript" src="https://v1.hitokoto.cn/?encode=js"></script>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-使用 VS Code 断点调试" class="post-使用 VS Code 断点调试 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/06/03/使用 VS Code 断点调试/">vue 使用 VS Code 断点调试</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/06/03/使用 VS Code 断点调试/" data-id="cllu7jau1003f4kia282b5fcp" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>直接在 Chrome 的调试窗口中调试 Vue 代码有诸多不便， 好在 Visual Studio Code 中提供了 Debugger for Chrome 插件，能够通过配置直接在 VS Code 断点调试代码, 并且在 VS Code 的调试窗口看到 Chrome 中 console 相同的值，这篇文章就来介绍一下这个配置过程。<br>1.开启 Chrome 远程调试端口</p>
<p>首先我们需要在远程调试打开的状态下启动 Chrome, 这样 VS Code 才能 attach 到 Chrome 上。<br>Windows</p>
<pre><code>右键点击 Chrome 的快捷方式图标，选择属性
在目标一栏，最后加上 --remote-debugging-port=9222，注意要用空格隔开
</code></pre><p>macOS</p>
<pre><code>打开控制台

执行命令 /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --remote-debugging-port=9222
</code></pre><p>Linux</p>
<pre><code>打开控制台
执行命令 google-chrome --remote-debugging-port=9222
</code></pre><p>2.安装 Chrome Debug 插件</p>
<p>点击 Visual Studio Code 左侧边栏的扩展按钮， 然后在搜索框输入Debugger for Chrome 并安装插件，再输入，安装完成后点击 reload 重启。</p>
<p>3.创建 Debug 配置文件</p>
<p>点击 Visual Studio Code 左侧边栏的 调试 按钮， 在弹出的调试配置窗口中点击 设置 小齿轮， 然后选择 chrome, VS Code 将会在工作区根目录生成.vscode 目录，里面会有一个 lanch.json 文件并会自动打开</p>
<p>用下面的配置文件覆盖自动生成的 lanch.json 文件内容。</p>
<p>注意：URL中的端口号要跟WEBPACK配置的启动端口号一致。</p>
<pre><code>{
  // Use IntelliSense to learn about possible attributes.
  // Hover to view descriptions of existing attributes.
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
  &quot;version&quot;: &quot;0.2.0&quot;,
  &quot;configurations&quot;: [
    {
      &quot;type&quot;: &quot;chrome&quot;,
      &quot;request&quot;: &quot;attach&quot;,
      &quot;name&quot;: &quot;Attach to Chrome&quot;,
      &quot;port&quot;: 9222,
      &quot;webRoot&quot;: &quot;${workspaceRoot}/src&quot;,
      &quot;url&quot;: &quot;http://localhost:8080/#/&quot;,
      &quot;sourceMaps&quot;: true,
      &quot;sourceMapPathOverrides&quot;: {
        &quot;webpack:///src/*&quot;: &quot;${webRoot}/*&quot;
      }
    }
  ]
}
</code></pre><p>4.修改 webpack 配置</p>
<p>如果是基于 webpack 打包的 vue 项目， 可能会存在断点不匹配的问题, 还需要做些修改：</p>
<p>1.打开根目录下的 config 目录下的 index.js 文件</p>
<p>2.将dev 节点下的 devtool 值改为 ‘eval-source-map’</p>
<p>3.将dev节点下的 cacheBusting 值改为 false</p>
<p>5.开启调试</p>
<p>上述配置完成之后：</p>
<ol>
<li><p>通过第一步的方式以远程调试打开的方式打开 Chrome</p>
</li>
<li><p>在 vue 项目中执行 npm run dev 以调试方式启动项目</p>
</li>
<li><p>点击 VS Code 左侧边栏的调试按钮，选择 Attach to Chrome 并点击绿色开始按钮，正常情况下就会出现调试控制条。</p>
</li>
</ol>
<p>现在就可以在 vue 文件的 js 代码中打断点进行调试了。</p>

      
    </div><!-- .entry-content -->
    <!-- busuanzi  start -->
    
    <!-- busuanzi  end -->

    <footer class="entry-meta">
    <a href="/2019/06/03/使用 VS Code 断点调试/">
    <time datetime="2019-06-02T16:00:00.000Z" class="entry-date">
        2019-06-03
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-vue 事件中的 .native" class="post-vue 事件中的 .native post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/06/03/vue 事件中的 .native/">vue 事件中的 (native)</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/06/03/vue 事件中的 .native/" data-id="cllu7jatm00304kial1miazg9" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="native是什么-？"><a href="#native是什么-？" class="headerlink" title=".native是什么 ？"></a>.native是什么 <strong>？</strong></h2><pre><code>.native - 监听组件根元素的原生事件。
主要是给自定义的组件添加原生事件。
# * 给普通的标签加事件，然后加native是无效的

 &lt;el-dropdown class=&quot;submitBtn&quot;&gt;
     &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot;&gt; 更多菜单&lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt;
     &lt;/el-button&gt;
         &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt;
             &lt;el-dropdown-item @click.native=&quot;click&quot;&gt; 双皮奶 &lt;/el-dropdown-item&gt;
         &lt;/el-dropdown-menu&gt;
 &lt;/el-dropdown&gt;
</code></pre><h2 id="将click的native去掉，思路如下-："><a href="#将click的native去掉，思路如下-：" class="headerlink" title="将click的native去掉，思路如下 ："></a>将click的native去掉，思路如下 <strong>：</strong></h2><pre><code> 子组件监听父组件给的click事件，
 子组件内部处理click事件然后向外发送click事件：$emit(&quot;click&quot;.fn)

&lt;template&gt;
  &lt;!-- 此处自定义事件名也叫 `click` 所以在使用组件时加不加 `.native` 修饰符都可以 --&gt;
  &lt;button type=&quot;button&quot; @click=&quot;$emit(&apos;click&apos;)&quot;&gt;&lt;slot /&gt;&lt;/button&gt;
&lt;/template&gt;
</code></pre>
      
    </div><!-- .entry-content -->
    <!-- busuanzi  start -->
    
    <!-- busuanzi  end -->

    <footer class="entry-meta">
    <a href="/2019/06/03/vue 事件中的 .native/">
    <time datetime="2019-06-02T16:00:00.000Z" class="entry-date">
        2019-06-03
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-vue async await" class="post-vue async await post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/06/03/vue async await/">async await</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/06/03/vue async await/" data-id="cllu7jatm002z4kiauwsqyooa" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。<br>async-await 是promise和generator的语法糖。只是为了让我们书写代码时更加流畅，当然也增强了代码的可读性。简单来说：async-await 是建立在 promise机制之上的，并不能取代其地位。<br>async 用来表示函数是异步的，定义的函数会返回一个promise对象，可以使用then方法添加回调函数。<br>await 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。<br>await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行。</p>
<h2 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2. 基本用法"></a>2. 基本用法</h2><h3 id="2-1-返回-promise-对象"><a href="#2-1-返回-promise-对象" class="headerlink" title="2.1 返回 promise 对象"></a>2.1 返回 promise 对象</h3><p>async 函数返回的是一个 promise 对象.</p>
<pre><code>async function test (){
  return &apos;hello async&apos;;
}
let result = test();
console.log(result);
// Promise {&lt;resolved&gt;: &quot;hello async&quot;}
</code></pre><p>所以，async 函数返回的是一个 Promise 对象。从文档中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。所以 可以使用 then() 链来处理这个 Promise 对象，就像这样：</p>
<pre><code>test().then(v =&gt; {
  console.log(v); // hello async
});
</code></pre><h3 id="2-2-Promise-对象的状态变化"><a href="#2-2-Promise-对象的状态变化" class="headerlink" title="2.2 Promise 对象的状态变化"></a>2.2 Promise 对象的状态变化</h3><p>async 函数返回的 Promise 对象，必须等到内部所有 await 命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到 return 语句或者抛出错误。也就是说，只有 async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数。</p>
<h3 id="2-3-await-命令"><a href="#2-3-await-命令" class="headerlink" title="2.3 await 命令"></a>2.3 await 命令</h3><p>正常情况下，await 命令后面是一个 Promise 对象。如果不是，会被转成一个立即 resolve 的 Promise 对象。</p>
<pre><code>async function f() {
  return await 123;
}

f().then(v =&gt; console.log(v))
// 123
</code></pre><p>上面代码中，await 命令的参数是数值123，它被转成 Promise 对象，并立即 resolve。</p>
<p>await 命令后面的 Promise 对象如果变为 reject 状态，则 reject 的参数会被 catch 方法的回调函数接收到。</p>
<pre><code>async function f() {
  await Promise.reject(&apos;出错了&apos;);
}

f()
.then(v =&gt; console.log(v))
.catch(e =&gt; console.log(e))
// 出错了
</code></pre><p>注意，上面代码中，await 语句前面没有 return，但是 reject 方法的参数依然传入了 catch 方法的回调函数。这里如果在 await 前面加上 return，效果是一样的。</p>
<p>只要一个 await 语句后面的 Promise 变为 reject，那么整个 async 函数都会中断执行。</p>
<pre><code>async function f() {
  await Promise.reject(&apos;出错了&apos;);
  await Promise.resolve(&apos;hello world&apos;); // 不会执行
}
</code></pre><p>上面代码中，第二个 await 语句是不会执行的，因为第一个 await 语句状态变成了 reject。</p>
<p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个 await 放在 try…catch 结构里面，这样不管这个异步操作是否成功，第二个 await 都会执行。</p>
<pre><code>async function f() {
  try {
    await Promise.reject(&apos;出错了&apos;);
  } catch(e) {
  }
  return await Promise.resolve(&apos;hello world&apos;);
}

f()
.then(v =&gt; console.log(v))
// hello world
</code></pre><h2 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h2><h3 id="Syntax-Error-await-is-a-reserved-word"><a href="#Syntax-Error-await-is-a-reserved-word" class="headerlink" title="Syntax Error: await is a reserved word"></a>Syntax Error: await is a reserved word</h3><pre><code># 报错例：
async submit() {
    try {
        this.$refs[formName].validate(valid =&gt; {
            let res = await submit(...this.submitForm)
            this.$message.success(res.resultMessage）
        })
    } catch (err){
        console.log(err)
        this.$message.success(err.resultMessage）
    }
}
</code></pre><p>上例报错： Syntax Error: await is a reserved word<br>    检查代码 分析： async 在submit()函数前面，里面 validate() 还有一个隐式函数 valid =&gt; {}，async 应该写在隐式函数前面</p>
<pre><code>#修改后例：
   submit() {
       try {
           this.$refs[formName].validate(async valid =&gt; {
               let res = await submit(...this.params)
               this.$message.success(res.resultMessage）
           })
       } catch (err){
           console.log(err)
           this.$message.success(err.resultMessage）
       }
   }
</code></pre><p>如果有多个 await 命令，可以统一放在 try…catch 结构中。</p>
<pre><code>async main() {
  try {
    const val1 = await firstStep();
    const val2 = await secondStep(val1);
    const val3 = await thirdStep(val1, val2);
    console.log(&apos;Final: &apos;, val3);
  }
  catch (err) {
    console.error(err);
  }
}

await in for 循环

let arr = [1, 2, 3, 4, 5];
arr.forEach(async item =&gt; {
  await console.log(item)
});
</code></pre>
      
    </div><!-- .entry-content -->
    <!-- busuanzi  start -->
    
    <!-- busuanzi  end -->

    <footer class="entry-meta">
    <a href="/2019/06/03/vue async await/">
    <time datetime="2019-06-02T16:00:00.000Z" class="entry-date">
        2019-06-03
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-node-vue-webpack构建项目" class="post-node-vue-webpack构建项目 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/05/14/node-vue-webpack构建项目/">node-vue-webpack 构建项目</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/05/14/node-vue-webpack构建项目/" data-id="cllu7jatm002h4kiagi0fs1a7" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h3 id="vuw-cli-全局安装"><a href="#vuw-cli-全局安装" class="headerlink" title="vuw-cli 全局安装"></a>vuw-cli 全局安装</h3><pre><code>npm install  -g vue-cli
</code></pre><h3 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h3><pre><code># 创建项目
mkdir vue-webpack
cd vue-webpack
# 创建模板
vue init webpack 
# 安装依赖包
npm install
# 运行项目
npm run dev
# 访问
</code></pre><p><a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p>
<pre><code># 简单的Vue Webpack项目构建完成
</code></pre><p> <img src="/assets/vueImg/start.png" alt="image"></p>
<h3 id="安装cnpm"><a href="#安装cnpm" class="headerlink" title="安装cnpm"></a>安装cnpm</h3><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org
</code></pre><h3 id="跨域代理配置"><a href="#跨域代理配置" class="headerlink" title="跨域代理配置"></a>跨域代理配置</h3><pre><code>#config目录下 index.js 文件配置如下， 可以配置多个

module.exports = {
  dev: {
    // Paths
    assetsSubDirectory: &apos;static&apos;,
    assetsPublicPath: &apos;/&apos;,
    proxyTable: {
      &apos;/api&apos;: {
        target: &apos;http://10.43.22.175:9000&apos;,
        changeOrigin: true,
        ws: true,
        pathRewrite: {
          &apos;^/api&apos;: &apos;/api&apos;
        },
        router: {
          // when request.headers.host == &apos;dev.localhost:3000&apos;,
          // override target &apos;http://www.example.org&apos; to &apos;http://localhost:8000&apos;
          &apos;10.43.22.175:8080&apos; : &apos;http://10.43.22.175:9000&apos;
        }
      },
      &apos;/activity&apos;: {
        target: &apos;http://10.43.22.149:8081&apos;,
        changeOrigin: true,
        ws: true,
        pathRewrite: {
          &apos;^/activity&apos;: &apos;/activity&apos;
        },
        router: {
          // when request.headers.host == &apos;dev.localhost:3000&apos;,
          // override target &apos;http://www.example.org&apos; to &apos;http://localhost:8000&apos;
          &apos;10.43.22.175:8080&apos; : &apos;http://10.43.22.149:8081&apos;
        }
      }
    }
  }
}
</code></pre><h3 id="vue-router-参数"><a href="#vue-router-参数" class="headerlink" title="vue-router 参数"></a>vue-router 参数</h3><h4 id="1-query"><a href="#1-query" class="headerlink" title="1. query"></a>1. query</h4><pre><code>1.this.$router.push({path:&apos;history&apos;, query:{id: &apos;1111&apos;}});
下一个页面通过this.$route.query.id访问路由参数
 总结：1. 强制刷新，query不会丢参
 2. query会拼接到url上 （/history?id=1111）
</code></pre><h4 id="2-params"><a href="#2-params" class="headerlink" title="2. params"></a>2. params</h4><pre><code>2.this.$router.push({&apos;name&apos;: &apos;history&apos;, params: {id: &apos;1111&apos;}});
下一个页面通过this.$route.params.id访问路由参数
 总结：
    1. 页面刷新参数会丢失
    2. 不会拼接到url上 例 （/history）
    3.   router.js 中： 需要添加name属性
    {
      path: &apos;history&apos;,
      name: &apos;history&apos;,
      meta: {
        requireAuth: true,
        title: &apos;历史记录&apos;
      },
      component: resolve =&gt; require([&apos;@/views/history.vue&apos;], resolve)
    }
    4.注意： 用path访问 参数 undefined
        例：
        this.$router.push({&apos;path&apos;: &apos;history&apos;, params: {id: &apos;1111&apos;}});
        # 下一个页面通过this.$route.params.id访问路由参数
        undefined
</code></pre><h4 id="3-其他-id"><a href="#3-其他-id" class="headerlink" title="3.其他 :id"></a>3.其他 :id</h4><pre><code># 跳转
this.$router.push({&apos;path&apos;: &apos;history/&apos; + row.id});
or 
&lt;router-link :to=&apos;`/history/${item.id}`&apos;&gt;&lt;/router-link&gt;

# router.js 中：
{
  path: &apos;history/:id&apos;,
  meta: {
    requireAuth: true,
    title: &apos;历史记录&apos;
  },
  component: resolve =&gt; require([&apos;@/views/history.vue&apos;], resolve)
},
下一个页面通过this.$route.params.id访问路由参数
1. 页面刷新参数不会丢失
2. 会拼接到url上 例 （/history/1111111） 
</code></pre><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3>
      
    </div><!-- .entry-content -->
    <!-- busuanzi  start -->
    
    <!-- busuanzi  end -->

    <footer class="entry-meta">
    <a href="/2019/05/14/node-vue-webpack构建项目/">
    <time datetime="2019-05-13T16:00:00.000Z" class="entry-date">
        2019-05-14
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-vue + webpack-build-params-init" class="post-vue + webpack-build-params-init post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/05/06/vue + webpack-build-params-init/">编译不同环境 global 参数设置</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/05/06/vue + webpack-build-params-init/" data-id="cllu7jatm002v4kiagox3lx4o" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="获取-‘npm-run-build-dev’-中的参数，修改-global"><a href="#获取-‘npm-run-build-dev’-中的参数，修改-global" class="headerlink" title="获取 ‘npm run build dev’ 中的参数，修改 global"></a>获取 ‘npm run build dev’ 中的参数，修改 global</h2><pre><code># 在 build.js 中添加如下修改

const yargs = require(&apos;yargs&apos;)
const fs = require(&apos;fs&apos;)
let envList = [&apos;prod&apos;, &apos;test&apos;, &apos;dev&apos;, &apos;local&apos;, &apos;stage&apos;];
let globConfig = (yargs.argv.config &amp;&amp; envList.includes(yargs.argv.config)) ? yargs.argv.config : (yargs.argv._[0]? yargs.argv._[0]: envList[2]);
let versionConfig = yargs.argv.vers ? yargs.argv.vers : &apos;1.0.0.0&apos;;
console.log(&apos;building for&apos;, globConfig,)
console.log(yargs.argv, yargs.argv._[0])

let glogFile = fs.readFileSync(path.resolve(__dirname, &apos;../src/assets/js/global.js&apos;), &apos;utf-8&apos;)
let curFile = glogFile.replace(/(let\s*env\s*\=\s*)(\d+)(\s*\;)/gi, (s0, s1, s2, s3) =&gt; {
  let config = 4
  // (globConfig === &apos;test&apos;) ? 2 : ((globConfig === &apos;prod&apos;) ? 1 : ((globConfig === &apos;dev&apos;) ? 3: globConfig === &apos;stage&apos; ? 5 : 4))
  switch(globConfig) {
    case &apos;test&apos;:
      config = 2
      break;
    case &apos;prod&apos;:
      config = 1
      break;
    case &apos;dev&apos;:
      config = 3
      break;
    case &apos;stage&apos;:
      config = 5
      break;
    default:
      config = 4
  }
  return s1 + config + s3;
}).replace(/(let\s*version\s*\=\s*\&quot;)(.*)(\&quot;\;)/gi, (s0, s1, s2, s3) =&gt; {
  return s1 + versionConfig + s3;
})

fs.writeFileSync(path.resolve(__dirname, &apos;../src/assets/js/global.js&apos;), curFile, &apos;utf-8&apos;);
</code></pre>
      
    </div><!-- .entry-content -->
    <!-- busuanzi  start -->
    
    <!-- busuanzi  end -->

    <footer class="entry-meta">
    <a href="/2019/05/06/vue + webpack-build-params-init/">
    <time datetime="2019-05-05T16:00:00.000Z" class="entry-date">
        2019-05-06
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-vue + webpack 多模块静态文件导入" class="post-vue + webpack 多模块静态文件导入 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/05/06/vue + webpack 多模块静态文件导入/">vue + webpack 多模块静态文件导入</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/05/06/vue + webpack 多模块静态文件导入/" data-id="cllu7jatm002t4kia87nwsk4z" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="多个模块导入静态文件"><a href="#多个模块导入静态文件" class="headerlink" title="多个模块导入静态文件"></a>多个模块导入静态文件</h2><p>项目结构目录<br><img src="/assets/vueImg/projects.png" alt="Image text"></p>
<p>官方推荐的css及js引用方式如下:</p>
<pre><code>&lt;!-- 引入样式 --&gt;
&lt;link href=&quot;https://cdnjs.cloudflare.com/ajax/libs/element-ui/2.2.0/theme-chalk/index.css&quot; rel=&quot;stylesheet&quot;&gt; 
&lt;!-- 引入组件库 --&gt;
&lt;script src=&quot;https://lib.baomitu.com/vue/2.4.4/vue.min.js&quot;&gt;&lt;/script&gt; 
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.2/vue-router.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://unpkg.com/element-ui@2.2.0/lib/index.js&quot;&gt;&lt;/script&gt;
</code></pre><p>这种方式引入,如果环境只有内网,没有外网的话,会导致页面直接空白.（或cdn 访问不通、不在维护等……）</p>
<p>很简单把css的href及js的src的网址输入浏览器可以得到css和js的源码,直接拷贝到本地即可.</p>
<p>index.html 引入</p>
<pre><code>&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;
  &lt;title&gt;xxxxx&lt;/title&gt;
  &lt;link href=&quot;/static/css/element-ui2.2.0/index.css&quot; rel=&quot;stylesheet&quot;&gt;
  &lt;script src=&apos;/static/js/vue2.7.0/vue.min.js&apos;&gt;&lt;/script&gt;
  &lt;script src=&apos;/static/js/vue-router3.0.2/vue-router.min.js&apos;&gt;&lt;/script&gt;
  &lt;script src=&apos;/static/js/element-ui@2.2.0/index.js&apos;&gt;&lt;/script&gt;
&lt;/head&gt;
</code></pre><h2 id="静态文件配置（多模块、多服务、各服务端口不同）"><a href="#静态文件配置（多模块、多服务、各服务端口不同）" class="headerlink" title="静态文件配置（多模块、多服务、各服务端口不同）"></a>静态文件配置（多模块、多服务、各服务端口不同）</h2><pre><code># config 配置信息
assetsSubDirectory: &apos;static&apos;,
assetsPublicPath: &apos;/&apos;,

# 项目是 vue+webpack 多模块
 开发环境中多个模块需要启动多个服务，各服务监听的端口不同，使用离线存储数据时存在跨域不共通的问题。
 解决思路： 采用第三方代理服务器，前端所有的请求到代理服务器由代理服务器进行请求分发
 实现：采用gulp-connect 做为代理服务器，代理转发的具体代码如下

const gulp = require(&apos;gulp&apos;);
const connect = require(&apos;gulp-connect&apos;);
const proxy = require(&apos;http-proxy-middleware&apos;);
const ipLib = require(&apos;ip&apos;);
const path = require(&apos;path&apos;);
const fs = require(&apos;fs&apos;)


let currentIp = ipLib.address()
let globPath = path.resolve(__dirname, &apos;../src/assets/js/global.js&apos;)
const proxyPort = &apos;7890&apos;

gulp.task(&apos;server&apos;, function(){
  connect.server({
    port: proxyPort,
    host: &apos;0.0.0.0&apos;,
    middleware: function(connect, opt) {
      return [
        proxy(&apos;/login&apos;, {
          target: &apos;http://www.localhost:8080&apos;, // target host
          changeOrigin: true,               // needed for virtual hosted sites
          ws: true,
          router: { // login
            [ currentIp + &apos;:&apos;+proxyPort] : &apos;http://&apos; + currentIp + &apos;:10258/&apos;
          }
        }),
        proxy(&apos;/static&apos;, {
          target: &apos;http://www.localhost:8080&apos;, // target host
          changeOrigin: true,               // needed for virtual hosted sites
          ws: true,
          router: { // static
            [ currentIp + &apos;:&apos;+proxyPort] : &apos;http://&apos; + currentIp + &apos;:10258/&apos;
          }
        }),
      ]
    }
  })
})
</code></pre><h2 id="本地使用element-ui-图标不显示或显示错乱的问题"><a href="#本地使用element-ui-图标不显示或显示错乱的问题" class="headerlink" title="本地使用element ui 图标不显示或显示错乱的问题"></a>本地使用element ui 图标不显示或显示错乱的问题</h2><p>但是问题来了,element-ui的index.css拷贝本地之后,会发现图标无法正常显示了.</p>
<pre><code>原因

在本地的index.css中发现如下代码是网络请求icon的

@charset &quot;UTF-8&quot;;.el-pagination--small .arrow.disabled,.el-table .hidden-columns,.el-table td.is-hidden&gt;*,.el-table th.is-hidden&gt;*,.el-table--hidden{visibility:hidden}@font-face{font-family:element-icons;src:url(fonts/element-icons.woff) format(&quot;woff&quot;),url(fonts/element-icons.ttf) format(&quot;truetype&quot;);font-weight:400;
</code></pre><p>解决办法</p>
<p>访问 <a href="https://cdnjs.cloudflare.com/ajax/libs/element-ui/2.2.0/theme-chalk/fonts/element-icons.woff" target="_blank" rel="noopener">https://cdnjs.cloudflare.com/ajax/libs/element-ui/2.2.0/theme-chalk/fonts/element-icons.woff</a><br><a href="https://cdnjs.cloudflare.com/ajax/libs/element-ui/2.2.0/theme-chalk/fonts/element-icons.ttf" target="_blank" rel="noopener">https://cdnjs.cloudflare.com/ajax/libs/element-ui/2.2.0/theme-chalk/fonts/element-icons.ttf</a></p>
<p>文件自动下载下来,放到项目的/static/css/element-ui2.2.0/fonts文件夹下即可</p>
<p><img src="/assets/vueImg/staticFile.png" alt="Image text"></p>

      
    </div><!-- .entry-content -->
    <!-- busuanzi  start -->
    
    <!-- busuanzi  end -->

    <footer class="entry-meta">
    <a href="/2019/05/06/vue + webpack 多模块静态文件导入/">
    <time datetime="2019-05-05T16:00:00.000Z" class="entry-date">
        2019-05-06
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-vue 修改子组件样式" class="post-vue 修改子组件样式 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/05/05/vue 修改子组件样式/">vue 修改子组件样式</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/05/05/vue 修改子组件样式/" data-id="cllu7jatm00344kia78ejbv9f" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h3 id="Scoped-CSS"><a href="#Scoped-CSS" class="headerlink" title="Scoped CSS"></a>Scoped CSS</h3><p>当 style 标签有 scoped 属性时，它的 CSS 只作用于当前组件中的元素。这类似于 Shadow DOM 中的样式封装。它有一些注意事项，但不需要任何 polyfill。它通过使用 PostCSS 来实现以下转换：</p>
<pre><code>&lt;style scoped&gt;
.example {
  color: red;
}
&lt;/style&gt;

&lt;template&gt;
  &lt;div class=&quot;example&quot;&gt;hi&lt;/div&gt;
&lt;/template&gt;
</code></pre><p>转换结果：</p>
<pre><code>&lt;style&gt;
.example[data-v-f3f3eg9] {
  color: red;
}
&lt;/style&gt;

&lt;template&gt;
  &lt;div class=&quot;example&quot; data-v-f3f3eg9&gt;hi&lt;/div&gt;
&lt;/template&gt;
</code></pre><h3 id="混用本地和全局样式"><a href="#混用本地和全局样式" class="headerlink" title="混用本地和全局样式"></a>混用本地和全局样式</h3><p>你可以在一个组件中同时使用有 scoped 和非 scoped 样式：</p>
<pre><code>&lt;style&gt;
/* 全局样式 */
&lt;/style&gt;

&lt;style scoped&gt;
/* 本地样式 */
&lt;/style&gt;
</code></pre><h3 id="子组件的根元素"><a href="#子组件的根元素" class="headerlink" title="子组件的根元素"></a>子组件的根元素</h3><p>使用 scoped 后，父组件的样式将不会渗透到子组件中。不过一个子组件的根节点会同时受其父组件的 scoped CSS 和子组件的 scoped CSS 的影响。这样设计是为了让父组件可以从布局的角度出发，调整其子组件根元素的样式。</p>
<h3 id="深度作用选择器"><a href="#深度作用选择器" class="headerlink" title="深度作用选择器"></a>深度作用选择器</h3><p>如果你希望 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，你可以使用 &gt;&gt;&gt; 操作符：</p>
<pre><code>&lt;style scoped&gt;
.a &gt;&gt;&gt; .b { /* ... */ }
&lt;/style&gt;
</code></pre><p>上述代码将会编译成：</p>
<pre><code>.a[data-v-f3f3eg9] .b { /* ... */ }
</code></pre><p>有些像 Sass 之类的预处理器无法正确解析 &gt;&gt;&gt;。这种情况下你可以使用 /deep/ 或 ::v-deep 操作符取而代之——两者都是 &gt;&gt;&gt; 的别名，同样可以正常工作。</p>
<p>例：</p>
<pre><code> &lt;template slot-scope=&quot;slotProps&quot;&gt;
    &lt;xx-input
    v-model=&quot;slotProps.option.record.name&quot;
    :type=&quot;form.input.type&quot;
    placeholder=&quot;请输入&quot;
    :required=&quot;true&quot;
    size=&quot;60&quot;
    class=&quot;table-input&quot;
  &gt;&lt;/xx-input&gt;
 &lt;/template&gt;

&lt;style lang=&quot;css&quot; scoped&gt;
.table-input /deep/ .input-no-label .input__content{
  margin-bottom: 0;
}
&lt;/style&gt;
</code></pre><h3 id="动态生成的内容"><a href="#动态生成的内容" class="headerlink" title="动态生成的内容"></a>动态生成的内容</h3><p>通过 v-html 创建的 DOM 内容不受 scoped 样式影响，但是你仍然可以通过深度作用选择器来为他们设置样式。</p>
<h3 id="还有一些要留意"><a href="#还有一些要留意" class="headerlink" title="还有一些要留意"></a>还有一些要留意</h3><p><strong>Scoped 样式不能代替 class</strong>考虑到浏览器渲染各种 CSS 选择器的方式，当 p { color: red } 是 scoped 时 (即与特性选择器组合使用时) 会慢很多倍。如果你使用 class 或者 id 取而代之，比如 .example { color: red }，性能影响就会消除。</p>
<p><strong>在递归组件中小心使用后代选择器!</strong> 对选择器 .a .b 中的 CSS 规则来说，如果匹配 .a 的元素包含一个递归子组件，则所有的子组件中的 .b 都将被这个规则匹配。</p>
<h3 id="不推荐使用全局样式"><a href="#不推荐使用全局样式" class="headerlink" title="*不推荐使用全局样式"></a>*不推荐使用全局样式</h3><p>参考：<a href="https://vue-loader.vuejs.org/zh/guide/scoped-css.html" target="_blank" rel="noopener">https://vue-loader.vuejs.org/zh/guide/scoped-css.html</a></p>
<h3 id="vue-的样式覆盖问题"><a href="#vue-的样式覆盖问题" class="headerlink" title="vue 的样式覆盖问题"></a>vue 的样式覆盖问题</h3><pre><code>一般想要覆盖第三方插件样式，可自己定义class，或者直接获取三方类名，添加样式，只需要在后面加 !important属性即可
.subitem-date-picker {
  width: 100% !important;
}
</code></pre>
      
    </div><!-- .entry-content -->
    <!-- busuanzi  start -->
    
    <!-- busuanzi  end -->

    <footer class="entry-meta">
    <a href="/2019/05/05/vue 修改子组件样式/">
    <time datetime="2019-05-04T16:00:00.000Z" class="entry-date">
        2019-05-05
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-vue 重新渲染组件（重置或者更新) " class="post-vue 重新渲染组件（重置或者更新)  post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/05/05/vue 重新渲染组件（重置或者更新) /">vue 重新渲染组件（重置或者更新）</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/05/05/vue 重新渲染组件（重置或者更新) /" data-id="cllu7jatm00374kia4ev410l6" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="动态组件-amp-异步组件"><a href="#动态组件-amp-异步组件" class="headerlink" title="动态组件 &amp; 异步组件"></a>动态组件 &amp; 异步组件</h2><p>  组件根据传入的数据动态产生DOM结构, 只操作数据便可以重新渲染页面, 路由相同时页面不重新渲染或更新<br>  一、当数据通过异步操作后，对之前加载的数据进行变更后，发现数据不生效。<br>  二、A组件或者B组件触发数据更新，C组件数据更新了，但是C组件仍显示上一次数据。</p>
<h2 id="方案一：v-if（可以重置生命周期）"><a href="#方案一：v-if（可以重置生命周期）" class="headerlink" title="方案一：v-if（可以重置生命周期）"></a>方案一：v-if（可以重置生命周期）</h2><pre><code>当路由变更后,通过watch 监听，先去销毁当前的组件，然后再重现渲染。使用 v-if 可以解决这个问题
&lt;template&gt;
  &lt;form-component :initModelForData=&quot;initModelForData&quot; :subTitle=&quot;subTitle&quot; :columnList=&quot;columnList&quot; v-if=&quot;reFresh&quot;&gt;&lt;/form-component&gt;
&lt;/template&gt;

&lt;script&gt;
  export default{
    data(){
      return {
        reFresh:true,
      }
    },
    watch:{
      $route(to, form) {
        this.reFresh= false
        this.$nextTick(()=&gt;{
            this.reFresh = true
        })
      }
    }
}
&lt;/script&gt;
</code></pre><p>  这种方式虽然可以实现，但太不优雅  </p>
<h2 id="方案二-key-’’（此处可触发watch和update）"><a href="#方案二-key-’’（此处可触发watch和update）" class="headerlink" title="方案二 :key=’’（此处可触发watch和update）"></a>方案二 :key=’’（此处可触发watch和update）</h2><pre><code>通过vue key 实现，原理请查看官方文档。所以当key 值变更时，会自动的重新渲染。

&lt;template&gt;
  &lt;form-component :initModelForData=&quot;initModelForData&quot; :subTitle=&quot;subTitle&quot; :columnList=&quot;columnList&quot; :key=&quot;key&quot;&gt;&lt;/form-component&gt;
&lt;/template&gt;

&lt;script&gt;
  export default{
    data(){
      return {
        key: 1
      }
    },
    watch:{
      $route(to, form) {
        ++this.key
      }
    }
}
&lt;/script&gt;
</code></pre>
      
    </div><!-- .entry-content -->
    <!-- busuanzi  start -->
    
    <!-- busuanzi  end -->

    <footer class="entry-meta">
    <a href="/2019/05/05/vue 重新渲染组件（重置或者更新) /">
    <time datetime="2019-05-04T16:00:00.000Z" class="entry-date">
        2019-05-05
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-java集合框架" class="post-java集合框架 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/04/28/java集合框架/">java 集合框架</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/04/28/java集合框架/" data-id="cllu7jauh00584kial3zgv5ms" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h3 id="一、只有光头才能变强"><a href="#一、只有光头才能变强" class="headerlink" title="一、只有光头才能变强"></a>一、只有光头才能变强</h3><h4 id="1、-什么是Java集合API"><a href="#1、-什么是Java集合API" class="headerlink" title="1、 什么是Java集合API"></a>1、 什么是Java集合API</h4><pre><code>Java集合框架API是用来表示和操作集合的统一框架，它包含接口、实现类、以及帮助程序员完成一些编程的算法。简言之，API在上层完成以下几件事：

● 编程更加省力，提高城程序速度和代码质量

● 非关联的API提高互操作性

● 节省学习使用新API成本

● 节省设计新API的时间

● 鼓励、促进软件重用

具体来说，有6个集合接口，最基本的是Collection接口，由三个接口Set、List、SortedSet继承，另外两个接口是Map、SortedMap,这两个接口不继承Collection，表示映射而不是真正的集合。
</code></pre><h4 id="2、-什么是Iterator"><a href="#2、-什么是Iterator" class="headerlink" title="2、 什么是Iterator"></a>2、 什么是Iterator</h4><pre><code>一些集合类提供了内容遍历的功能，通过java.util.Iterator接口。这些接口允许遍历对象的集合。依次操作每个元素对象。当使用 Iterators时，在获得Iterator的时候包含一个集合快照。通常在遍历一个Iterator的时候不建议修改集合本省。
</code></pre><h4 id="3、-Iterator与ListIterator有什么区别"><a href="#3、-Iterator与ListIterator有什么区别" class="headerlink" title="3、 Iterator与ListIterator有什么区别"></a>3、 Iterator与ListIterator有什么区别</h4><pre><code>Iterator:只能正向遍历集合，适用于获取移除元素。ListIerator：继承Iterator,可以双向列表的遍历，同样支持元素的修改。
</code></pre><h4 id="4、-什么是HaspMap和Map"><a href="#4、-什么是HaspMap和Map" class="headerlink" title="4、 什么是HaspMap和Map"></a>4、 什么是HaspMap和Map</h4><pre><code>Map是接口，Java 集合框架中一部分，用于存储键值对，HashMap是用哈希算法实现Map的类。
</code></pre><h4 id="5、-HashMap与HashTable有什么区别？对比Hashtable-VS-HashMap"><a href="#5、-HashMap与HashTable有什么区别？对比Hashtable-VS-HashMap" class="headerlink" title="5、 HashMap与HashTable有什么区别？对比Hashtable VS HashMap"></a>5、 HashMap与HashTable有什么区别？对比Hashtable VS HashMap</h4><pre><code>两者都是用key-value方式获取数据。Hashtable是原始集合类之一(也称作遗留类)。HashMap作为新集合框架的一部分在Java2的1.2版本中加入。它们之间有一下区别：

● HashMap和Hashtable大致是等同的，除了非同步和空值(HashMap允许null值作为key和value，而Hashtable不可以)。

● HashMap没法保证映射的顺序一直不变，但是作为HashMap的子类LinkedHashMap，如果想要预知的顺序迭代(默认按照插入顺序),你可以很轻易的置换为HashMap，如果使用Hashtable就没那么容易了。

● HashMap不是同步的，而Hashtable是同步的。

● 迭代HashMap采用快速失败机制，而Hashtable不是，所以这是设计的考虑点。
</code></pre><h4 id="6、-在Hashtable上下文中同步是什么意思"><a href="#6、-在Hashtable上下文中同步是什么意思" class="headerlink" title="6、 在Hashtable上下文中同步是什么意思"></a>6、 在Hashtable上下文中同步是什么意思</h4><pre><code>同步意味着在一个时间点只能有一个线程可以修改哈希表，任何线程在执行hashtable的更新操作前需要获取对象锁，其他线程等待锁的释放。
</code></pre><h4 id="7、-什么叫做快速失败特性"><a href="#7、-什么叫做快速失败特性" class="headerlink" title="7、 什么叫做快速失败特性"></a>7、 什么叫做快速失败特性</h4><pre><code>从高级别层次来说快速失败是一个系统或软件对于其故障做出的响应。一个快速失败系统设计用来即时报告可能会导致失败的任何故障情况，它通常用来停止正常的操作而不是尝试继续做可能有缺陷的工作。当有问题发生时，快速失败系统即时可见地发错错误告警。在Java中，快速失败与iterators有关。如果一个iterator在集合对象上创建了，其它线程欲“结构化”的修改该集合对象，并发修改异常 (ConcurrentModificationException) 抛出。
</code></pre><h4 id="8、-怎样使Hashmap同步"><a href="#8、-怎样使Hashmap同步" class="headerlink" title="8、 怎样使Hashmap同步"></a>8、 怎样使Hashmap同步</h4><pre><code>HashMap可以通过Map m = Collections.synchronizedMap（hashMap）来达到同步的效果。
</code></pre><h4 id="9、-什么时候使用Hashtable，什么时候使用HashMap"><a href="#9、-什么时候使用Hashtable，什么时候使用HashMap" class="headerlink" title="9、 什么时候使用Hashtable，什么时候使用HashMap"></a>9、 什么时候使用Hashtable，什么时候使用HashMap</h4><pre><code>基本的不同点是Hashtable同步HashMap不是的，所以无论什么时候有多个线程访问相同实例的可能时，就应该使用Hashtable，反之使用HashMap。非线程安全的数据结构能带来更好的性能。

如果在将来有一种可能—你需要按顺序获得键值对的方案时，HashMap是一个很好的选择，因为有HashMap的一个子类 LinkedHashMap。所以如果你想可预测的按顺序迭代(默认按插入的顺序)，你可以很方便用LinkedHashMap替换HashMap。反观要是使用的Hashtable就没那么简单了。同时如果有多个线程访问HashMap，Collections.synchronizedMap()可以代替，总的来说HashMap更灵活。
</code></pre><h4 id="10、为什么Vector类认为是废弃的或者是非官方地不推荐使用？或者说为什么我们应该一直使用ArrayList而不是Vector"><a href="#10、为什么Vector类认为是废弃的或者是非官方地不推荐使用？或者说为什么我们应该一直使用ArrayList而不是Vector" class="headerlink" title="10、为什么Vector类认为是废弃的或者是非官方地不推荐使用？或者说为什么我们应该一直使用ArrayList而不是Vector"></a>10、为什么Vector类认为是废弃的或者是非官方地不推荐使用？或者说为什么我们应该一直使用ArrayList而不是Vector</h4><pre><code>你应该使用ArrayList而不是Vector是因为默认情况下你是非同步访问的，Vector同步了每个方法，你几乎从不要那样做，通常有想要同步的是整个操作序列。同步单个的操作也不安全(如果你迭代一个Vector,你还是要加锁，以避免其它线程在同一时刻改变集合).而且效率更慢。当然同样有锁的开销即使你不需要，这是个很糟糕的方法在默认情况下同步访问。你可以一直使用Collections.sychronizedList来装饰一个集合。

事实上Vector结合了“可变数组”的集合和同步每个操作的实现。这是另外一个设计上的缺陷。Vector还有些遗留的方法在枚举和元素获取的方法，这些方法不同于List接口，如果这些方法在代码中程序员更趋向于想用它。尽管枚举速度更快，但是他们不能检查如果集合在迭代的时候修改了，这样将导致问题。尽管以上诸多原因，oracle也从没宣称过要废弃Vector.
</code></pre><h3 id="二、CopyOnWriteArrayList-Set-介绍"><a href="#二、CopyOnWriteArrayList-Set-介绍" class="headerlink" title="二、CopyOnWriteArrayList(Set)介绍"></a>二、CopyOnWriteArrayList(Set)介绍</h3><p>一般来说，我们会认为：CopyOnWriteArrayList是同步List的替代品，CopyOnWriteArraySet是同步Set的替代品。</p>
<p>无论是Hashtable–&gt;ConcurrentHashMap，还是说Vector–&gt;CopyOnWriteArrayList。JUC下支持并发的容器与老一代的线程安全类相比，总结起来就是加锁粒度的问题</p>
<pre><code>Hashtable、Vector加锁的粒度大(直接在方法声明处使用synchronized)
ConcurrentHashMap、CopyOnWriteArrayList加锁粒度小(用各种的方式来实现线程安全，比如我们知道的ConcurrentHashMap用了cas锁、volatile等方式来实现线程安全..)
JUC下的线程安全容器在遍历的时候不会抛出ConcurrentModificationException异常
</code></pre><p>所以一般来说，我们都会使用JUC包下给我们提供的线程安全容器，而不是使用老一代的线程安全容器。</p>
<p>下面我们来看看CopyOnWriteArrayList是怎么实现的，为什么使用迭代器遍历的时候就不用额外加锁，也不会抛出ConcurrentModificationException异常。</p>
<h4 id="2-1CopyOnWriteArrayList实现原理"><a href="#2-1CopyOnWriteArrayList实现原理" class="headerlink" title="2.1CopyOnWriteArrayList实现原理"></a>2.1CopyOnWriteArrayList实现原理</h4><p>我们还是先来回顾一下COW：</p>
<pre><code>如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。优点是如果调用者没有修改该资源，就不会有副本（private copy）被建立，因此多个调用者只是读取操作时可以共享同一份资源。
</code></pre><p>概括一下CopyOnWriteArrayList源码注释介绍了什么：</p>
<pre><code>CopyOnWriteArrayList是线程安全容器(相对于ArrayList)，底层通过复制数组的方式来实现。
CopyOnWriteArrayList在遍历的使用不会抛出ConcurrentModificationException异常，并且遍历的时候就不用额外加锁
元素可以为null
</code></pre><h4 id="2-1-1看一下CopyOnWriteArrayList基本的结构"><a href="#2-1-1看一下CopyOnWriteArrayList基本的结构" class="headerlink" title="2.1.1看一下CopyOnWriteArrayList基本的结构"></a>2.1.1看一下CopyOnWriteArrayList基本的结构</h4><pre><code>/** 可重入锁对象 */
final transient ReentrantLock lock = new ReentrantLock();

/** CopyOnWriteArrayList底层由数组实现，volatile修饰 */
private transient volatile Object[] array;

/**
 * 得到数组
 */
final Object[] getArray() {
    return array;
}

/**
 * 设置数组
 */
final void setArray(Object[] a) {
    array = a;
}

/**
 * 初始化CopyOnWriteArrayList相当于初始化数组
 */
public CopyOnWriteArrayList() {
    setArray(new Object[0]);
}
</code></pre><p>看起来挺简单的，CopyOnWriteArrayList底层就是数组，加锁就交由ReentrantLock来完成。</p>
<h4 id="2-1-2常见方法的实现"><a href="#2-1-2常见方法的实现" class="headerlink" title="2.1.2常见方法的实现"></a>2.1.2常见方法的实现</h4><p>根据上面的分析我们知道如果遍历Vector/SynchronizedList是需要自己手动加锁的。</p>
<p>CopyOnWriteArrayList使用迭代器遍历时不需要显示加锁，看看add()、clear()、remove()与get()方法的实现可能就有点眉目了。</p>
<p>首先我们可以看看add()方法</p>
<pre><code>public boolean add(E e) {

    // 加锁
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {

        // 得到原数组的长度和元素
        Object[] elements = getArray();
        int len = elements.length;

        // 复制出一个新数组
        Object[] newElements = Arrays.copyOf(elements, len + 1);

        // 添加时，将新元素添加到新数组中
        newElements[len] = e;

        // 将volatile Object[] array 的指向替换成新数组
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}
</code></pre><p>通过代码我们可以知道：在添加的时候就上锁，并复制一个新数组，增加操作在新数组上完成，将array指向到新数组中，最后解锁。</p>
<p>再来看看size()方法：</p>
<pre><code>public int size() {

    // 直接得到array数组的长度
    return getArray().length;
}
</code></pre><p>再来看看get()方法：</p>
<pre><code>public E get(int index) {
    return get(getArray(), index);
}

final Object[] getArray() {
    return array;
}
</code></pre><p>那再来看看set()方法</p>
<pre><code>public E set(int index, E element) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {

        // 得到原数组的旧值
        Object[] elements = getArray();
        E oldValue = get(elements, index);

        // 判断新值和旧值是否相等
        if (oldValue != element) {

            // 复制新数组，新值在新数组中完成
            int len = elements.length;
            Object[] newElements = Arrays.copyOf(elements, len);
            newElements[index] = element;

            // 将array引用指向新数组
            setArray(newElements);
        } else {
            // Not quite a no-op; enssures volatile write semantics
            setArray(elements);
        }
        return oldValue;
    } finally {
        lock.unlock();
    }
}
</code></pre><p>对于remove()、clear()跟set()和add()是类似的，这里我就不再贴出代码了。</p>
<p>总结：</p>
<pre><code>在修改时，复制出一个新数组，修改的操作在新数组中完成，最后将新数组交由array变量指向。
写加锁，读不加锁
</code></pre><h4 id="2-1-3剖析为什么遍历时不用调用者显式加锁"><a href="#2-1-3剖析为什么遍历时不用调用者显式加锁" class="headerlink" title="2.1.3剖析为什么遍历时不用调用者显式加锁"></a>2.1.3剖析为什么遍历时不用调用者显式加锁</h4><p>常用的方法实现我们已经基本了解了，但还是不知道为啥能够在容器遍历的时候对其进行修改而不抛出异常。所以，来看一下他的迭代器吧：</p>
<pre><code>// 1. 返回的迭代器是COWIterator
public Iterator&lt;E&gt; iterator() {
    return new COWIterator&lt;E&gt;(getArray(), 0);
}


// 2. 迭代器的成员属性
private final Object[] snapshot;
private int cursor;

// 3. 迭代器的构造方法
private COWIterator(Object[] elements, int initialCursor) {
    cursor = initialCursor;
    snapshot = elements;
}

// 4. 迭代器的方法...
public E next() {
    if (! hasNext())
        throw new NoSuchElementException();
    return (E) snapshot[cursor++];
}

//.... 可以发现的是，迭代器所有的操作都基于snapshot数组，而snapshot是传递进来的array数组
</code></pre><p>到这里，我们应该就可以想明白了！CopyOnWriteArrayList在使用迭代器遍历的时候，操作的都是原数组！</p>
<h4 id="2-1-4CopyOnWriteArrayList缺点"><a href="#2-1-4CopyOnWriteArrayList缺点" class="headerlink" title="2.1.4CopyOnWriteArrayList缺点"></a>2.1.4CopyOnWriteArrayList缺点</h4><p>看了上面的实现源码，我们应该也大概能分析出CopyOnWriteArrayList的缺点了。</p>
<pre><code>内存占用：如果CopyOnWriteArrayList经常要增删改里面的数据，经常要执行add()、set()、remove()的话，那是比较耗费内存的。
    因为我们知道每次add()、set()、remove()这些增删改操作都要复制一个数组出来。

数据一致性：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。
    从上面的例子也可以看出来，比如线程A在迭代CopyOnWriteArrayList容器的数据。线程B在线程A迭代的间隙中将CopyOnWriteArrayList部分的数据修改了(已经调用setArray()了)。但是线程A迭代出来的是原有的数据。
</code></pre><h4 id="2-1-5CopyOnWriteSet"><a href="#2-1-5CopyOnWriteSet" class="headerlink" title="2.1.5CopyOnWriteSet"></a>2.1.5CopyOnWriteSet</h4><p>CopyOnWriteArraySet的原理就是CopyOnWriteArrayList。</p>
<pre><code>private final CopyOnWriteArrayList&lt;E&gt; al;

public CopyOnWriteArraySet() {
    al = new CopyOnWriteArrayList&lt;E&gt;();
}
</code></pre>
      
    </div><!-- .entry-content -->
    <!-- busuanzi  start -->
    
    <!-- busuanzi  end -->

    <footer class="entry-meta">
    <a href="/2019/04/28/java集合框架/">
    <time datetime="2019-04-27T16:00:00.000Z" class="entry-date">
        2019-04-28
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-nginx解决方案" class="post-nginx解决方案 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/04/24/nginx解决方案/">Nginx解决方案</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/04/24/nginx解决方案/" data-id="cllu7jauh005e4kiag0r5tsgk" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h3 id="1-方案场景"><a href="#1-方案场景" class="headerlink" title="1.方案场景"></a>1.方案场景</h3><p>现有多台应用服务器，要实现所有的访问先访问到反向代理服务器上再转内部对应的应用。</p>
<pre><code>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。简而言之就是隐藏所有的服务器，与之相对的是正向代理，如我们常用的vpn，目的是隐藏访问客户端。
</code></pre><p>我们在这里打算采用Nginx作为方向代理的服务器</p>
<h3 id="2-什么是nginx"><a href="#2-什么是nginx" class="headerlink" title="2.什么是nginx"></a>2.什么是nginx</h3><pre><code>Nginx(&quot;engine x&quot;)是一款是由俄罗斯的程序设计师Igor Sysoev开发高性能的 Web和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。
在高连接并发的情况下，Nginx是Apache服务器不错的替代品。
</code></pre><h3 id="3-nginx安装"><a href="#3-nginx安装" class="headerlink" title="3.nginx安装"></a>3.nginx安装</h3><pre><code>在/usr/local/src下进行，否则后面会编译错误
</code></pre><h4 id="3-1-安装编译工具和库文件"><a href="#3-1-安装编译工具和库文件" class="headerlink" title="3.1 安装编译工具和库文件"></a>3.1 安装编译工具和库文件</h4><pre><code>yum -y install make zlib zlib-devel gcc-c++ libtool  openssl openssl-devel
</code></pre><h4 id="3-2-安装PCRE"><a href="#3-2-安装PCRE" class="headerlink" title="3.2 安装PCRE"></a>3.2 安装PCRE</h4><p> PCRE 作用是让 Nginx 支持 Rewrite 功能。<br> 下载 PCRE 安装包，下载地址： <a href="http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz" target="_blank" rel="noopener">http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz</a></p>
<pre><code>wget http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz
</code></pre><p> 解压安装包</p>
<pre><code>tar zxvf pcre-8.35.tar.gz
</code></pre><p> 进入安装包目录</p>
<pre><code>cd pcre-8.35
</code></pre><p> 编译安装</p>
<pre><code>./configure
make &amp;&amp; make install
</code></pre><p> 查看pcre版本</p>
<pre><code>pcre-config --version
</code></pre><p> 若有版本显示，表明安装成功</p>
<h4 id="3-3-安装Nginx"><a href="#3-3-安装Nginx" class="headerlink" title="3.3 安装Nginx"></a>3.3 安装Nginx</h4><p>下载 Nginx，下载地址：<a href="http://nginx.org/download/nginx-1.6.2.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.6.2.tar.gz</a></p>
<pre><code>wget http://nginx.org/download/nginx-1.6.2.tar.gz
</code></pre><p>解压安装包</p>
<pre><code>tar zxvf nginx-1.6.2.tar.gz
</code></pre><p>进入安装包目录</p>
<pre><code>cd nginx-1.6.2
</code></pre><p>编译安装</p>
<pre><code>./configure --prefix=/usr/local/webserver/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/usr/local/src/pcre-8.35
make
make isntall
</code></pre><p>注意，编译安装的路径要按照实际安装的路径来，本次是在/usr/local/src下</p>
<p>查看nginx版本</p>
<pre><code>/usr/local/webserver/nginx/sbin/nginx -v
</code></pre><p>若有版本显示，表明安装成功</p>
<h3 id="4-nginx的配置"><a href="#4-nginx的配置" class="headerlink" title="4.nginx的配置"></a>4.nginx的配置</h3><p>nginx的配置文件在/usr/local/webserver/nginx/conf/nginx.conf下，我们只要修改nginx.conf的内容就可以修改Nginx的配置<br>配置文件的格式如下</p>
<pre><code>main # 全局设置
events { # Nginx工作模式
    ....
}
http { # http设置
    ....
    upstream myproject { # 负载均衡服务器设置
        .....
    }
    server  { # 主机设置
        ....
        location { # URL匹配
            ....
        }
    }
    server  {
        ....
        location {
            ....
        }
    }
    ....
}
</code></pre><h4 id="4-1-main模块"><a href="#4-1-main模块" class="headerlink" title="4.1 main模块"></a>4.1 main模块</h4><p>main区域是一个全局设置</p>
<pre><code>#user 来指定Nginx Worker进程运行用户以及用户组，默认由nobody账号运行。
user  nobody;
#指定了Nginx要开启的子进程数。每个Nginx进程平均耗费10M~12M内存。根据经验，一般指定1个进程就足够了，如果是多核CPU，建议指定和CPU的数量一样的进程数即可。我这里写2，那么就会开启2个子进程，总共3个进程。
worker_processes  1;

#error_log 来定义全局错误日志文件。日志输出级别有debug、info、notice、warn、error、crit可供选择，其中，debug输出日志最为最详细，而crit输出日志最少。
error_log  logs/error.log;
error_log  logs/error.log  notice;
error_log  logs/error.log  info;
#pid 来指定进程id的存储文件位置。
pid        logs/nginx.pid
</code></pre><h4 id="4-2-events模块"><a href="#4-2-events模块" class="headerlink" title="4.2 events模块"></a>4.2 events模块</h4><p>events模块来用指定nginx的工作模式和工作模式及连接数上限，一般是这样</p>
<pre><code>events {
    use kqueue; #用来指定Nginx的工作模式
    #指定Nginx的单个进程的最大连接数，即接收到的前端的最大请求数，默认为1024
    worker_connections  1024;
}
</code></pre><h4 id="4-3-http模块"><a href="#4-3-http模块" class="headerlink" title="4.3 http模块"></a>4.3 http模块</h4><p>  http是Nginx的核心模块，它负责http服务器相关属性的配置，里面的server和upstream子模块至关重要，我们在设置方向代理、负债均衡以及虚拟目录等的时候，就是依赖于这两个模块的配置</p>
<pre><code>http {
     #设定mime类型,类型由mime.type文件定义
    include       /etc/nginx/mime.types;
    #设定了默认的类型为二进制流，也就是当文件类型未定义时使用这种方式
    default_type  application/octet-stream;

    #用于设置日志的格式，和记录哪些参数，这里设置为main，刚好用于access_log来纪录这种类型。
    log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;
                    &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;
                    &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;
    #设定日志文件，后面的main是日志的格式样式，对应于log_format的main。
    access_log    /var/log/nginx/access.log main;

    #用于开启高效文件传输模式。将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞。
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;

    #设置客户端连接保持活动的超时时间。在超过这个时间之后，服务器会关闭该连接。
    keepalive_timeout 10;

    #设定负载均衡的服务器列表
    upstream load_balance_server {
        ......
    }

   #HTTP服务器
   server {
       ......
    }
}
</code></pre><h5 id="4-3-1-upstream模块"><a href="#4-3-1-upstream模块" class="headerlink" title="4.3.1 upstream模块"></a>4.3.1 upstream模块</h5><p>  upstream主要负责负载均衡，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。</p>
<pre><code>upstream test.com{
    ip_hash;
    server 123.206.117.62:80;
    server 123.206.117.62:80 down;
    server 123.206.117.62:8080  max_fails=3  fail_timeout=20s;
    server 123.206.117.62:8080;
}
</code></pre><blockquote>
<ul>
<li>上面的代码，test.com是upstream指定的负载均衡器的名称，这个名称可以任意指定，在后面需要的地方直接调用即可。</li>
<li>ip_hash这是其中的一种负载均衡调度算法，Nginx的负载均衡模块目前支持4种调度算法<blockquote>
<ul>
<li>weight 轮询（默认）。每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响。weight。指定轮询权值，weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下。</li>
<li>ip_hash。每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。</li>
<li>fair（第三方）。比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。</li>
<li>url_hash（第三方）。按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx的hash软件包。</li>
</ul>
</blockquote>
</li>
<li>server指定的是各种服务器，包括服务器的ip、端口以及每个后端服务器在负载均衡中的状态，常用的状态有：<blockquote>
<ol>
<li>down，表示当前的server暂时不参与负载均衡。</li>
<li>backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。</li>
<li>max_fails，允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。</li>
<li>fail_timeout，在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。<br>注意：当负载调度算法为ip_hash时，后端服务器在负载均衡调度中的状态不能是weight和backup。其它情况可以是weight，表示负载的权重，默认为1，weight越大，权重越大。</li>
</ol>
</blockquote>
</li>
</ul>
</blockquote>
<h5 id="4-3-2-server模块"><a href="#4-3-2-server模块" class="headerlink" title="4.3.2 server模块"></a>4.3.2 server模块</h5><p>  server模块是http的子模块，它用来定一个虚拟主机，它的基本配置如下</p>
<pre><code>server {
    #指定虚拟主机的服务端口
    listen 8080;
    #用来指定IP地址或者域名，多个域名之间用空格分开。
    server_name localhost 123.206.117.62 www.test.com;
    # 全局定义，如果都是这一个目录，这样定义最简单。
    root   /Users/marscheng/www; #示在这整个server虚拟主机内，全部的root web根目录。注意要和locate {}下面定义的区分开来。
    index  index.php index.html index.htm; #全局定义访问的默认首页地址。注意要和locate {}下面定义的区分开来。
    charset utf-8;#网页的默认编码格式
    #用来指定此虚拟主机的访问日志存放路径，最后的main用于指定访问日志的输出格式
    access_log  usr/local/var/log/host.access.log  main;
    #错误日志文件
    error_log  usr/local/var/log/host.error.log  error;
    #用于定位的配置
    location / {
          ....  
        }

}
</code></pre><p>  location模块</p>
<p>  location模块一般是在server中定义的，它在Nginx中用的最多，无论是负载均衡、反向代理还是虚拟域名，都跟它的配置有关。</p>
<p>  location是用来定位，解析url,定位URL，所以，它也提供了强大的正则匹配功能，也支持条件判断匹配，用户可以通过location指令实现Nginx对动态、静态网页进行过滤处理。</p>
<ol>
<li><p>设定默认首页和虚拟机目录</p>
<pre><code>location / {
  #指令用于指定访问根目录时，虚拟主机的web目录，这个目录可以是相对路径（相对路径是相对于nginx的安装目录）。也可以是绝对路径。
  root   /Users/marscheng/www;
  #用于设定我们只输入域名后访问的默认首页地址，有个先后顺序：index.php index.html index.htm，如果没有开启目录浏览权限，又找不到这些默认首页，就会报403错误。
  index  index.jsp index.html index.htm;
}
</code></pre></li>
<li><p>用正则表达式匹配</p>
<pre><code>location ~ \.html$ { #匹配.html结尾的URL，用来解析html文件。里面的root也是一样，用来表示虚拟主机的根目录。
  root           /Users/marscheng/www;
  fastcgi_pass   127.0.0.1:9000;
  fastcgi_index  index.html;
  include        fastcgi.conf;
}
</code></pre></li>
</ol>
<p>这里只是简单介绍，详细的配置可以参考这篇文章：<br><a href="http://seanlook.com/2015/05/17/nginx-location-rewrite/" target="_blank" rel="noopener">http://seanlook.com/2015/05/17/nginx-location-rewrite/</a></p>
<p>网上还有一篇介绍Nginx比较好的，文章，地址如下：<br><a href="http://www.jianshu.com/p/bed000e1830b" target="_blank" rel="noopener">http://www.jianshu.com/p/bed000e1830b</a></p>
<h3 id="5-方案设计"><a href="#5-方案设计" class="headerlink" title="5.方案设计"></a>5.方案设计</h3><p>根据场景设计了如下的配置方案：</p>
<pre><code>http {
#此处省略一些基本配置

upstream product_server{
    server 9.236.2.35:8081;
}

upstream admin_server{
    server 9.236.2.36:8082;
}

upstream finance_server{
    server 9.236.2.37:8083;
}

server {
    #此处省略一些基本配置
    #根据不同正则匹配默认指向不同的的server
    location / {
        proxy_pass http://product_server;
    }

    location /product/{
        proxy_pass http://product_server;
    }

    location /admin/ {
        proxy_pass http://admin_server;
    }

    location /finance/ {
        proxy_pass http://finance_server;
    }
}
</code></pre><p>}</p>

      
    </div><!-- .entry-content -->
    <!-- busuanzi  start -->
    
    <!-- busuanzi  end -->

    <footer class="entry-meta">
    <a href="/2019/04/24/nginx解决方案/">
    <time datetime="2019-04-23T16:00:00.000Z" class="entry-date">
        2019-04-24
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

    
    </footer>
</article>






  
  
    <nav id="pagination">
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
      </nav>
    </nav>
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value name="s" id="s">
        <input type="submit" id="searchsubmit" value="搜索">
    </div>
</form></aside>
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-content">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AES/">AES</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/">JS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Markdown/">Markdown</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Openoffice/">Openoffice</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/POI/">POI</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SVN/">SVN</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shell/">Shell</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud-Spring-Boot-微服务/">Spring Cloud Spring Boot 微服务</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Springboot/">Springboot</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WeCaht/">WeCaht</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/console/">console</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/github/">github</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/node-mysql2/">node mysql2</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/npm/">npm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vscode/">vscode</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/windows/">windows</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端学习/">前端学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/加密算法/">加密算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随记/">随记</a><span class="category-list-count">6</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2023/07/27/制作npm/">生成npm包</a>
          </li>
        
          <li>
            <a href="/2023/07/19/indexedDB/">windows indexedDB</a>
          </li>
        
          <li>
            <a href="/2023/07/19/webpack4 thread-loader cache/">webpack vue-cli 启动编译慢</a>
          </li>
        
          <li>
            <a href="/2023/07/19/webpack/">terser-webpack-plugin的使用:删除注释和console</a>
          </li>
        
          <li>
            <a href="/2023/03/23/node mysql2/">node mysql2</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2023 花皮松
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
    <!-- busuanzi start -->
    
    <!-- busuanzi end -->
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>