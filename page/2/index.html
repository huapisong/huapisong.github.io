<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  

  
  
  
  
  
  
  <title>随记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="随记">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="随记">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="随记">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src="//push.zhanzhang.baidu.com/push.js"></script>
</head></html>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="随记" rel="home">随记</a>
      </h1>
      
        <h2 class="site-description hitokoto"></h2>
        <script type="text/javascript" src="https://v1.hitokoto.cn/?encode=js"></script>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-javaThread" class="post-javaThread post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/04/18/javaThread/">java 线程</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/04/18/javaThread/" data-id="cjwk8gclg000v1k0y902lshs9" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h4 id="进程和线程的区别："><a href="#进程和线程的区别：" class="headerlink" title="进程和线程的区别："></a>进程和线程的区别：</h4><pre><code>进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。
线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。
线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。
多进程是指操作系统能同时运行多个任务（程序）。
多线程是指在同一程序中有多个顺序流在执行。

多线程的存在其实就是“最大限度的利用cpu资源”，当某一个线程的处理不需要占用cpu而之和I/O打交道的时候，让需要占用cpu资源的其他线程有机会获得cpu资源。从根本上说，这就是说多线程编程的目的。
多线程目的： 使用多线程，可以帮助我们编写出cpu最大利用率的高效程序，使得空闲时间降到最低

在java中要想实现多线程：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">继续Thread类</span><br><span class="line">实现Runable接口</span><br><span class="line">通过Callable创建线程</span><br><span class="line">线程池来实现</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="ExecutorService-创建线程池"><a href="#ExecutorService-创建线程池" class="headerlink" title="ExecutorService  创建线程池"></a>ExecutorService  创建线程池</h3><pre><code>// 创建一个可缓存的线程池，调用execute将重用以前构成的线程（如果线程可用）。
// 如果没有可用的线程，则创建一个新线程并添加到池中。终止并从缓存中移出那些已有60秒钟未被使用的线程。
Executors.newCachedThreadPool();
// 创建固定数目的线程池
Executors.newFixedThreadPool(1);
// 创建一个单线程化的Executor
Executors.newSingleThreadExecutor();
// 创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Time类。
Executors.newScheduledThreadPool(1);
</code></pre><p> 为什么不推荐通过Executors直接创建线程池</p>
<pre><code>原因：
java中BlockingQueue主要有两种实现，分别是ArrayBlockingQueue和LinkedBlockingQueue。ArrayBlockingQueue是一个用数组实现的有界阻塞队列，必须设置容量。
而LinkedBlockingQueue是一个用链表实现的有界阻塞队列，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE.

查看new SingleExecutor时的源码可以发现，在创建LinkedBlockingQueue时，并未指定容量。
此时，LinkedBlockingQueue就是一个无边界队列，对于一个无边界队列来说，是可以不断的向队列中加入任务的，这种情况下就有可能因为任务过多而导致内存溢出的问题。
</code></pre><p> 创建线程池的正确方法：</p>
<pre><code>避免使用Executors创建线程池，主要是避免使用其中的默认实现，那么我们可以自己直接调用ThreadPoolExecutor的构造函数自己创建线程池。在创建的同时，给BlockQueue指定容量就可以了。

ExecutorService executor = new ThreadPoolExecutor(10, 10,
        60L, TimeUnit.SECONDS,
        new ArrayBlockingQueue&lt;Runnable&gt;(10));

这种情况下，一旦提交的线程数超过当前可用线程数时，就会抛出java.util.concurrent.RejectedExecutionException，
这是因为当前线程池使用的队列是有界边界队列，队列已经满了便无法继续处理新的请求。但是异常（Exception）总比发生错误（Error）要好。
</code></pre><h3 id="ExecutorService-shutdown-、ShutdownNow-、awaitTermination"><a href="#ExecutorService-shutdown-、ShutdownNow-、awaitTermination" class="headerlink" title="ExecutorService  shutdown()、ShutdownNow()、awaitTermination()"></a>ExecutorService  shutdown()、ShutdownNow()、awaitTermination()</h3><pre><code>shutdown() 停止接收新任务，原来的任务继续执行
    1、停止接收新的submit的任务；
    2、已经提交的任务（包括正在跑的和队列中等待的）,会继续执行完成；
    3、等到第2步完成后，才真正停止；

ShutdownNow() 停止接收新任务，原来的任务停止执行
    1、跟 shutdown() 一样，先停止接收新submit的任务；
    2、忽略队列里等待的任务；
    3、尝试将正在执行的任务interrupt中断；
    4、返回未执行的任务列表；

awaitTermination(long timeOut, TimeUnit unit)：当前线程阻塞
    当前线程阻塞，直到：
    等所有已提交的任务（包括正在跑的和队列中等待的）执行完；
    或者 等超时时间到了（timeout 和 TimeUnit设定的时间）；
    或者 线程被中断，抛出InterruptedException

区别

    1、shutdown() 和 shutdownNow() 的区别
        shutdown() 只是关闭了提交通道，用submit()是无效的；而内部该怎么跑还是怎么跑，跑完再停。
        shutdownNow() 能立即停止线程池，正在跑的和正在等待的任务都停下了。
    2、shutdown() 和 awaitTermination() 的区别
        shutdown() 后，不能再提交新的任务进去；但是 awaitTermination() 后，可以继续提交。
        awaitTermination()是阻塞的，返回结果是线程池是否已停止（true/false）；shutdown() 不阻塞。

总结
    1、优雅的关闭，用 shutdown()
    2、想立马关闭，并得到未执行任务列表，用shutdownNow()
    3、优雅的关闭，并允许关闭声明后新任务能提交，用 awaitTermination()
    4、关闭功能 【从强到弱】 依次是：shuntdownNow() &gt; shutdown() &gt; awaitTermination()
</code></pre><p>例：</p>
<p>1、扩展Thread类实现的多线程例子</p>
<pre><code>public static void main(String[] args) {
    MyThread T1 = new MyThread(&quot;A&quot;);
    MyThread T2 = new MyThread(&quot;B&quot;);
    T1.start();
    T2.start();
}
class MyThread extends Thread {
    private String name;
    public MyThread(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        for (int i = 0; i &lt; 5; i++) {
            System.out.println(name+&quot;:&quot;+i);
            try {
                sleep(1000); //休眠1秒，避免太快导致看不到同时执行
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }
}

结果：
   A:0
   B:0
   A:1
   B:1
   A:2
   B:2
   A:3
   B:3
   A:4
   B:4
</code></pre><p>2、实现Runnable 、 ExecutorService 接口的多线程例子</p>
<pre><code>    ExecutorService executor = new ThreadPoolExecutor(10, 10,
                     60L, TimeUnit.SECONDS,
                     new ArrayBlockingQueue&lt;Runnable&gt;(10));
    public static void main(String[] args) {
        // executor
        /*for (int i = 0; i &lt; Integer.MAX_VALUE; i++) {
            executor.execute(new SubThread());
        }*/

        // Runnable
        executor.execute(new MyRunnable());
    }

 // 1. Runnable
class SubThread implements Runnable {
    @Override
    public void run() {
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) { //do nothing
        }
    }
}

 // 2. Runnable
class MyRunnable implements Runnable{

    public void run(){
        System.out.println(&quot;Runnable:run()....&quot;);
        int i=0;
        while(i&lt;20){
            i++;
            for(int j=0;j&lt;1000000;j++);
            System.out.println(&quot;i=&quot;+i);
        }
    }
}
结果：
    Runnable:run()....
    i=1
    i=2
    i=3
    i=4
    i=5
    i=6
    i=7
    i=8
    i=9
    i=10
    i=11
    i=12
    i=13
    i=14
    i=15
    i=16
    i=17
    i=18
    i=19
    i=20
</code></pre><p>3、实现Callable接口的多线程例子  </p>
<pre><code>    ExecutorService executor = new ThreadPoolExecutor(10, 10,
                             60L, TimeUnit.SECONDS,
                             new ArrayBlockingQueue&lt;Runnable&gt;(10));
    public static void main(String[] args) {
        // Callable
        Future future1 = executor.submit(new MyCallable());
        Future future2 = executor.submit(new MyCallable());
        try {
            System.out.println(future1.get());
            System.out.println(future2.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
        // 停止接收新任务，原来的任务继续执行
        executor.shutdown();
    }
class MyCallable implements Callable&lt;String&gt; {
    public String call() throws Exception {
        System.out.println(&quot;开始执行Callable&quot;);
        String[] ss={&quot;zhangsan&quot;,&quot;lisi&quot;};
        long[] num=new long[2];
        for(int i=0;i&lt;1000000;i++){
            num[(int)(Math.random()*2)]++;
        }

        if(num[0]&gt;num[1]){
            return ss[0];
        }else if(num[0]&lt;num[1]){
            throw new Exception(&quot;弃权!&quot;);
        }else{
            return ss[1];
        }
    }
}

结果;

开始执行Callable
开始执行Callable
zhangsan
zhangsan
</code></pre><h3 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h3><pre><code>1.wait和notify方法定义在Object类中，因此会被所有的类所继承。 这些方法都是final的，即它们都是不能被重写的，不能通过子类覆写去改变它们的行为。 而sleep方法是在Thread类中是由native修饰的，本地方法。
2.当线程调用了wait()方法时，它会释放掉对象的锁。 
    Thread.sleep()，它会导致线程睡眠指定的毫秒数，但线程在睡眠的过程中是不会释放掉对象的锁的。
3.正因为wait方法会释放锁，所以调用该方法时，当前的线程必须拥有当前对象的monitor，也即lock，就是锁。
要确保调用wait()方法的时候拥有锁，即，wait()方法的调用必须放在synchronized方法或synchronized块中。
4.sleep方法时间到，线程处于临时阻塞状态或者运行状态。 wait方法如果没有被设置时间，就必须要通过notify或者notifyAll来唤醒。
</code></pre><p>notify()</p>
<pre><code>notify()方法会唤醒一个等待当前对象的锁的线程。 如果多个线程在等待，它们中的一个将会选择被唤醒。
这种选择是随意的，和具体实现有关。（线程等待一个对象的锁是由于调用了wait方法中的一个）。

被唤醒的线程是不能被执行的，需要等到当前线程放弃这个对象的锁。
被唤醒的线程将和其他线程以通常的方式进行竞争，来获得对象的锁。也就是说，被唤醒的线程并没有什么优先权，也没有什么劣势，对象的下一个线程还是需要通过一般性的竞争。
且notify方法和wait一样，是需要放在synchronized方法或synchronized块中。

notifyAll()方法会唤醒在此对象监视器上等待的所有线程。线程通过调用其中一个 wait 方法，在对象的监视器上等待。
直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；
</code></pre><p>   尽量使用notifyAll()，notify()非常容易导致死锁。</p>
<h1 id="ThreadLocal-的简单使用及实现的原理"><a href="#ThreadLocal-的简单使用及实现的原理" class="headerlink" title="ThreadLocal 的简单使用及实现的原理"></a>ThreadLocal 的简单使用及实现的原理</h1><h3 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h3><pre><code>ThreadLocal的实例代表了一个线程局部的变量，每条线程都只能看到自己的值，并不会意识到其它的线程中也存在该变量。

它采用采用空间来换取时间的方式，解决多线程中相同变量的访问冲突问题。
</code></pre><h3 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h3><pre><code>ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。
</code></pre><h3 id="ThreadLocal的核心机制"><a href="#ThreadLocal的核心机制" class="headerlink" title="ThreadLocal的核心机制"></a>ThreadLocal的核心机制</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每个Thread线程内部都有一个Map。</span><br><span class="line">Map里面存储线程本地对象（key）和线程的变量副本（value）</span><br><span class="line">但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。</span><br></pre></td></tr></table></figure>
</code></pre><p>所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰</p>
<h3 id="ThreadLocal的简单使用"><a href="#ThreadLocal的简单使用" class="headerlink" title="ThreadLocal的简单使用"></a>ThreadLocal的简单使用</h3><p>下面的例子中，创建了两个线程，然后线程对各自的局部变量进行递增的操作。每个线程中的局部变量的初始值都是100。</p>
<pre><code>public class ThreadLocalTest {
    // ThreadLocal中的值
    static class Bank {
        ThreadLocal&lt;Integer&gt; t = new ThreadLocal&lt;Integer&gt;() {
            // 重写里面的方法就可以修改初始值了
            @Override
            protected Integer initialValue(){
                return 100;
            }
        };
        public int get() {
            return t.get();
        }
        public void set() {
            // 获取值
            t.set(t.get() + 10);
        }
        public void set(Integer value) {
            // 获取值
            t.set(value);
        }
    }
    /** 定义对ThreadLocal的操作，也就是在原来的基础上进行加10的操作，然后打印出结果。 */
    // 对ThreadLocal的操作
    static class Transfer implements Runnable {
        Bank bank;
        public Transfer(Bank bank) {
            this.bank = bank;
        }
        @Override
        public void run() {
            for (int i = 0; i &lt; 10; i++) {
                //
                bank.set();
                // 输出不同线程的ThreadLocal的值
                System.out.println(Thread.currentThread() + &quot;：：：&quot; + bank.get());
            }
        }
    }
    /** 创建两个线程并启动，主线程等待这两个线程执行完成。最值得注意的就是主线程中输出的bank.get()，输出的初始值100。 */
    // 创建线程并等待线程执行完成
    public static void main(String[] args) throws InterruptedException {
        //
        Bank bank = new Bank();
        // bank.set(50);
        // 多个线程都是同时操作一个变量，但是不同线程的结果是互不影响的
        Transfer t = new Transfer(bank);
        Thread t1 = new Thread(t);
        t1.start();
        Thread t2 = new Thread(t);
        t2.start();
        t1.join();
        t2.join();
        // 需要注意的是，这个是main（） 线程中的变量，输出的是 ThreadLocal&lt;Integer&gt; t 的初始值， 也就是100
        System.out.println(bank.get());
    }
}
</code></pre><h3 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h3><p>ThreadLocal类提供如下几个核心方法：</p>
<pre><code>public T get() { }
public void set(T value) { }
public void remove() { }
protected T initialValue() { }
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get()方法用于获取当前线程的副本变量值。</span><br><span class="line">set()方法用于保存当前线程的副本变量值。</span><br><span class="line">initialValue()为当前线程初始副本变量值。</span><br><span class="line">remove()方法移除当前前程的副本变量值</span><br></pre></td></tr></table></figure>
</code></pre><p>每个Thread的对象都有一个ThreadLocalMap，当创建一个ThreadLocal的时候，就会将该ThreadLocal对象添加到该Map中，其中键就是ThreadLocal，值可以是任意类型。</p>
<p>在该类中，重要的方法就是两个：set()和get()方法。当调用ThreadLocal的get()方法的时候，会先找到当前线程的ThreadLocalMap，然后再找到对应的值。set()方法也是一样。</p>
<pre><code>public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings(&quot;unchecked&quot;)
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}

public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/04/18/javaThread/">
    <time datetime="2019-04-17T16:00:00.000Z" class="entry-date">
        2019-04-18
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-Spring Cloud高可用" class="post-Spring Cloud高可用 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/04/17/Spring Cloud高可用/">Spring Cloud构建微服务架构  高可用</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/04/17/Spring Cloud高可用/" data-id="cjwk8gcl8000l1k0ymgk4oien" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h3 id="一、SpringCloud简介"><a href="#一、SpringCloud简介" class="headerlink" title="一、SpringCloud简介"></a>一、SpringCloud简介</h3><p>Spring Cloud是一系列框架的有序集合。<br>它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。<br>Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>
<h3 id="二、微服务的注册与发现-Eureka"><a href="#二、微服务的注册与发现-Eureka" class="headerlink" title="二、微服务的注册与发现-Eureka"></a>二、微服务的注册与发现-Eureka</h3><p> Eureka是Netflix开源的服务发现组件，本身是基于Rest的服务，它包含服务端和客户端两部分；在SpringCloud中将它集成在其中，从而实现了微服务的发现与注册；</p>
<ul>
<li>Eureka的GitHub：<a href="https://github.com/Netflix/Eureka" target="_blank" rel="noopener">https://github.com/Netflix/Eureka</a></li>
</ul>
<p>Eureka Server可以运行多个实例来构建集群，解决单点问题，Eureka Server采用的是Peer to Peer对等通信。这是一种去中心化的架构，无master/slave区分，每一个Peer都是对等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的serviceUrl指向其他节点。每个节点都可被视为其他节点的副本。</p>
<p>如果某台Eureka Server宕机，Eureka Client的请求会自动切换到新的Eureka Server节点，当宕机的服务器重新恢复后，Eureka会再次将其纳入到服务器集群管理之中。当节点开始接受客户端请求时，所有的操作都会进行replicateToPeer（节点间复制）操作，将请求复制到其他Eureka Server当前所知的所有节点中。</p>
<p>简单来说，Eureka Server的高可用，实际上就是将自己也作为服务向其他服务注册中心进行注册，这样就可以形成一组相互注册的服务注册中心，以实现服务清单的互相同步，达到高可用的效果。</p>
<p> 集群模式下，Eureka的架构图：<br> <img src="/assets/SpringCloudImg/eurekaService1.png" alt><br>Eureka Server </p>
<pre><code>- 服务端-没有存储，内存保持，每服务实例需要发送心跳去续约 
- 客户端-在内存中缓存着eureka的注册信息，因此不必每请求到eureka查找服务 
- eureka之间会做注册服务同步，从而保证状态一致，客户端只需访问一个
</code></pre><p>eureka Service Provider</p>
<pre><code>- 会向Eureka Server做Register（服务注册）、Renew（服务续约）、Cancel（服务下线）等操作 
</code></pre><p>Service Consumer </p>
<pre><code>- 会向Eureka Server获取注册服务列表，并消费服务
</code></pre><h3 id="三、Eureka的高可用"><a href="#三、Eureka的高可用" class="headerlink" title="三、Eureka的高可用"></a>三、Eureka的高可用</h3><p>eureka 项目下复制application.properties<br>分别命名为： </p>
<pre><code>application-server1.properties, application-server2.properties, application-server3.properties
</code></pre><p>修改hosts文件：</p>
<pre><code>127.0.0.1    localhost server1 server2 server3
</code></pre><p>application-server1.properties的配置文件：</p>
<pre><code>server.port=1001
spring.application.name=eureka-server-1
spring.profiles.active=server1
#表示是否将自己注册在EurekaServer上，默认为true。由于当前应用就是EurekaServer，所以置为false
eureka.client.register-with-eureka=true
#表示表示是否从EurekaServer获取注册信息，默认为true。单节点不需要同步其他的EurekaServer节点的数据
#eureka.client.fetch-registry=false
#指定主机名
eureka.instance.hostname=server1
eureka.client.serviceUrl.defaultZone=http://server2:1002/eureka/,http://server3:1003/eureka/
</code></pre><p>application-server2.properties的配置文件：</p>
<pre><code>server.port=1002
spring.application.name=eureka-server-2
spring.profiles.active=server2
#表示是否将自己注册在EurekaServer上，默认为true。由于当前应用就是EurekaServer，所以置为false
eureka.client.register-with-eureka=true
#表示表示是否从EurekaServer获取注册信息，默认为true。单节点不需要同步其他的EurekaServer节点的数据
#eureka.client.fetch-registry=false
#指定主机名
eureka.instance.hostname=server2
eureka.client.serviceUrl.defaultZone=http://server1:1001/eureka/,http://server3:1003/eureka/
</code></pre><p>application-server3.properties的配置文件：</p>
<pre><code>server.port=1003
spring.application.name=eureka-server-3
spring.profiles.active=server3
#表示是否将自己注册在EurekaServer上，默认为true。由于当前应用就是EurekaServer，所以置为false
eureka.client.register-with-eureka=true
#表示表示是否从EurekaServer获取注册信息，默认为true。单节点不需要同步其他的EurekaServer节点的数据
#eureka.client.fetch-registry=false
#指定主机名
eureka.instance.hostname=server3
eureka.client.serviceUrl.defaultZone=http://server1:1001/eureka/,http://server2:1002/eureka/
</code></pre><p>compute-service   项目下复制application.properties 为： application-dev.properties<br>配置信息：</p>
<pre><code>spring.application.name=compute-service
server.port=2001
eureka.client.serviceUrl.defaultZone=http://server3:1003/eureka/,http://server1:1001/eureka/,http://server2:1002/eureka/
</code></pre><p>分别启动服务端server3、server2、server1、compute-service</p>
<pre><code># 分别在项目下 执行 mvn clean install  命令编译 生成 target
 mvn clean install

# 在 /SpringCloudDemo/eureka/target 下执行,启动

java -jar eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=server1
java -jar eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=server2
java -jar eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=server3

# 在 /SpringCloudDemo/compute-service/target 下执行,启动
java -jar compute-service-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev
</code></pre><p>访问，<a href="http://localhost:1001/" target="_blank" rel="noopener">http://localhost:1001/</a>，<a href="http://localhost:1002/，http://localhost:1003/，如下：" target="_blank" rel="noopener">http://localhost:1002/，http://localhost:1003/，如下：</a></p>
<p> <img src="/assets/SpringCloudImg/keepalived1.png" alt><br> <img src="/assets/SpringCloudImg/keepalived2.png" alt><br> <img src="/assets/SpringCloudImg/keepalived3.png" alt> </p>
<p><a href="https://github.com/huapisong/SpringCloudDemo/" target="_blank" rel="noopener">该工程可参见：SpringCloudDemo/eureka</a></p>
<p>至此，完成了Eureka的高可用；</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/04/17/Spring Cloud高可用/">
    <time datetime="2019-04-16T16:00:00.000Z" class="entry-date">
        2019-04-17
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Spring-Cloud-Spring-Boot-微服务/">Spring Cloud Spring Boot 微服务</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-Spring Cloud(三)断路器" class="post-Spring Cloud(三)断路器 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/04/15/Spring Cloud(三)断路器/">Spring Cloud构建微服务架构 (三) 断路器</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/04/15/Spring Cloud(三)断路器/" data-id="cjwk8gcl4000g1k0ypmwdmvsp" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>在微服务架构中，我们将系统拆分成了一个个的服务单元，各单元间通过服务注册与订阅的方式互相依赖。由于每个单元都在不同的进程中运行，依赖通过远程调用的方式执行，这样就有可能因为网络原因或是依赖服务自身问题出现调用故障或延迟，而这些问题会直接导致调用方的对外服务也出现延迟，若此时调用方的请求不断增加，最后就会出现因等待出现故障的依赖方响应而形成任务积压，最终导致自身服务的瘫痪。</p>
<p>举个例子，在一个电商网站中，我们可能会将系统拆分成，用户、订单、库存、积分、评论等一系列的服务单元。用户创建一个订单的时候，在调用订单服务创建订单的时候，会向库存服务来请求出货（判断是否有足够库存来出货）。此时若库存服务因网络原因无法被访问到，导致创建订单服务的线程进入等待库存申请服务的响应，在漫长的等待之后用户会因为请求库存失败而得到创建订单失败的结果。如果在高并发情况之下，因这些等待线程在等待库存服务的响应而未能释放，使得后续到来的创建订单请求被阻塞，最终导致订单服务也不可用。</p>
<p>在微服务架构中，存在着那么多的服务单元，若一个单元出现故障，就会因依赖关系形成故障蔓延，最终导致整个系统的瘫痪，这样的架构相较传统架构就更加的不稳定。为了解决这样的问题，因此产生了断路器模式。<br>什么是断路器</p>
<p>断路器模式源于Martin Fowler的Circuit Breaker一文。“断路器”本身是一种开关装置，用于在电路上保护线路过载，当线路中有电器发生短路时，“断路器”能够及时的切断故障电路，防止发生过载、发热、甚至起火等严重后果。</p>
<p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。<br>Netflix Hystrix</p>
<p>在Spring Cloud中使用了Hystrix 来实现断路器的功能。Hystrix是Netflix开源的微服务框架套件之一，该框架目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能。</p>
<p>下面我们来看看如何使用Hystrix。<br>准备工作</p>
<p>在开始加入断路器之前，我们先拿之前构建两个微服务为基础进行下面的操作，主要使用下面几个工程：</p>
<pre><code>SpringCloudDemo
    eureka工程：服务注册中心，端口1000
    compute-service工程：服务单元，端口2001 / 2000
    eureka-ribbon：通过ribbon实现的服务单元，依赖compute-service的服务，端口2002
    eureka-feign：通过feign实现的服务单元，依赖compute-service的服务，端口2003
</code></pre><p>若您还没有使用Spring Cloud的经验，可以先阅读《服务注册与发现》与《服务消费者》，对Spring Cloud构建的微服务有一个初步的认识。</p>
<h3 id="Ribbon中引入Hystrix"><a href="#Ribbon中引入Hystrix" class="headerlink" title="Ribbon中引入Hystrix"></a>Ribbon中引入Hystrix</h3><pre><code>依次启动eureka-server、compute-service、eureka-ribbon工程
访问http://localhost:1000/可以看到注册中心的状态
访问http://localhost:2002/add，调用eureka-ribbon的服务，该服务会去调用compute-service的服务，计算出10+20的值，页面显示30
关闭compute-service服务，访问http://localhost:2002/add，我们获得了下面的报错信息

{&quot;timestamp&quot;:&quot;2019-04-16T07:11:04.064+0000&quot;,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;message&quot;:&quot;I/O error on GET request for \&quot;http://COMPUTE-SERVICE/add\&quot;: Connection refused: connect; nested exception is java.net.ConnectException: Connection refused: connect&quot;,&quot;path&quot;:&quot;/add&quot;}
</code></pre><p>pom.xml中引入依赖hystrix依赖</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt;
    &lt;artifactId&gt;hystrix-javanica&lt;/artifactId&gt;
    &lt;version&gt;RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>在eureka-ribbon的主类RibbonApplication中使用@EnableCircuitBreaker注解开启断路器功能：</p>
<pre><code>@SpringBootApplication
@EnableDiscoveryClient
@EnableCircuitBreaker
public class RibbonApplication {

    @Bean
    @LoadBalanced
    RestTemplate restTemplate() {
        return new RestTemplate();
    }

    public static void main(String[] args) {
        SpringApplication.run(RibbonApplication.class, args);
    }

}
</code></pre><p>改造原来的服务消费方式，新增ComputeService类，在使用ribbon消费服务的函数上增加@HystrixCommand注解来指定回调方法。</p>
<pre><code>@Service
public class ComputeService {

    @Autowired
    RestTemplate restTemplate;

    @HystrixCommand(fallbackMethod = &quot;addServiceFallback&quot;)
    public String addService() {
        return restTemplate.getForEntity(&quot;http://COMPUTE-SERVICE/add?a=10&amp;b=20&quot;, String.class).getBody();
    }

    public String addServiceFallback() {
        return &quot;error&quot;;
    }

}
</code></pre><p>提供rest接口的Controller改为调用ComputeService的addService</p>
<pre><code>@RestController
public class ConsumerController {

    @Autowired
    private ComputeService computeService;

    @RequestMapping(value = &quot;/add&quot;, method = RequestMethod.GET)
    public String add() {
        return computeService.addService();
    }

}
</code></pre><p>验证断路器的回调</p>
<pre><code>依次启动eureka、compute-service、eureka-ribbon工程
访问http://localhost:1000/可以看到注册中心的状态
访问http://localhost:2002/add，页面显示：30
关闭compute-service服务后再访问http://localhost:2002/add
显示：error
</code></pre><h3 id="Feign使用Hystrix"><a href="#Feign使用Hystrix" class="headerlink" title="Feign使用Hystrix"></a>Feign使用Hystrix</h3><p>注意这里说的是“使用”，没有错，我们不需要在Feigh工程中引入Hystix，Feign中已经依赖了Hystrix，我们可以在未做任何改造前，尝试下面你的操作：</p>
<pre><code>依次启动eureka、compute-service、eureka-feign工程
访问http://localhost:1000/可以看到注册中心的状态
访问http://localhost:2003/add，调用eureka-feign的服务，该服务会去调用compute-service的服务，计算出10+20的值，页面显示30
关闭compute-service服务，访问http://localhost:2003/add，我们获得了下面的报错信息

{&quot;timestamp&quot;:&quot;2019-04-16T07:11:04.064+0000&quot;,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;message&quot;:&quot;I/O error on GET request for \&quot;http://COMPUTE-SERVICE/add\&quot;: Connection refused: connect; nested exception is java.net.ConnectException: Connection refused: connect&quot;,&quot;path&quot;:&quot;/add&quot;}
</code></pre><p>appliction.yml 配置</p>
<pre><code>feign:
    hystrix:
        enabled: true
</code></pre><p>使用@FeignClient注解中的fallback属性指定回调类</p>
<pre><code>@FeignClient(value = &quot;compute-service&quot;, fallback = ComputeClientHystrix.class)
public interface ComputeClient {

    @RequestMapping(method = RequestMethod.GET, value = &quot;/add&quot;)
    Integer add(@RequestParam(value = &quot;a&quot;) Integer a, @RequestParam(value = &quot;b&quot;) Integer b);

}
</code></pre><p>创建回调类ComputeClientHystrix，实现@FeignClient的接口，此时实现的方法就是对应@FeignClient接口中映射的fallback函数。</p>
<pre><code>@Component
public class ComputeClientHystrix implements ComputeClient {

    @Override
    public Integer add(@RequestParam(value = &quot;a&quot;) Integer a, @RequestParam(value = &quot;b&quot;) Integer b) {
        return -9999;
    }

}
</code></pre><p>再用之前的方法验证一下，是否在compute-service服务不可用的情况下，页面返回了-9999。</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/04/15/Spring Cloud(三)断路器/">
    <time datetime="2019-04-14T16:00:00.000Z" class="entry-date">
        2019-04-15
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Spring-Cloud-Spring-Boot-微服务/">Spring Cloud Spring Boot 微服务</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-Spring Cloud(二)服务消费者" class="post-Spring Cloud(二)服务消费者 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/04/12/Spring Cloud(二)服务消费者/">Spring Cloud构建微服务架构（二）服务消费者</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/04/12/Spring Cloud(二)服务消费者/" data-id="cjwk8gcl1000d1k0yx1yfqfhz" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>在上一篇《Spring Cloud构建微服务架构（一）服务注册与发现》中，我们已经成功创建了“服务注册中心”，实现并注册了一个“服务提供者：COMPUTE-SERVICE”。那么我们要如何去消费服务提供者的接口内容呢？</p>
<h3 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h3><p>Ribbon是一个基于HTTP和TCP客户端的负载均衡器。Feign中也使用Ribbon，后续会介绍Feign的使用。</p>
<p>Ribbon可以在通过客户端中配置的ribbonServerList服务端列表去轮询访问以达到均衡负载的作用。</p>
<p>当Ribbon与Eureka联合使用时，ribbonServerList会被DiscoveryEnabledNIWSServerList重写，扩展成从Eureka注册中心中获取服务端列表。同时它也会用NIWSDiscoveryPing来取代IPing，它将职责委托给Eureka来确定服务端是否已经启动。</p>
<p>下面我们通过实例看看如何使用Ribbon来调用服务，并实现客户端的均衡负载。<br>准备工作</p>
<pre><code>启动服务注册中心：eureka
启动服务提供方：compute-service
修改compute-service中的server-port为2000，再启动一个服务提供方：compute-service
</code></pre><p>此时访问：<a href="http://localhost:1000/" target="_blank" rel="noopener">http://localhost:1000/</a></p>
<p>可以看到COMPUTE-SERVICE服务有两个单元正在运行：</p>
<pre><code>zangqisong-PC:compute-service:2001
zangqisong-PC:compute-service:2000
</code></pre><p><img src="/assets/SpringCloudImg/eurekaComputeService1.png" alt><br>使用Ribbon实现客户端负载均衡的消费者</p>
<p>构建一个基本Spring Boot项目，并在pom.xml中加入如下内容：</p>
<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt;
        &lt;artifactId&gt;hystrix-javanica&lt;/artifactId&gt;
        &lt;version&gt;RELEASE&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;${spring-cloud.version}&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre><p>在应用主类中，通过@EnableDiscoveryClient注解来添加发现服务能力。创建RestTemplate实例，并通过@LoadBalanced注解开启均衡负载能力。</p>
<pre><code>@SpringBootApplication
@EnableDiscoveryClient
@EnableCircuitBreaker
public class EurekaRibbonApplication {

    @Bean
    @LoadBalanced
    RestTemplate restTemplate() {
        return new RestTemplate();
    }

    public static void main(String[] args) {
        SpringApplication.run(EurekaRibbonApplication.class, args);
    }

}
</code></pre><p>创建ConsumerController来消费COMPUTE-SERVICE的add服务。通过直接RestTemplate来调用服务，计算10 + 20的值。</p>
<pre><code>@RestController
public class ConsumerController {

    @Autowired
    RestTemplate restTemplate;

    @RequestMapping(value = &quot;/add&quot;, method = RequestMethod.GET)
    public String add() {
        return restTemplate.getForEntity(&quot;http://COMPUTE-SERVICE/add?a=10&amp;b=20&quot;, String.class).getBody();
    }

}
</code></pre><p>application.properties中配置eureka服务注册中心</p>
<pre><code>spring.application.name=ribbon-consumer
server.port=2002
eureka.client.serviceUrl.defaultZone=http://localhost:1000/eureka/
</code></pre><p><a href="http://localhost:2002/add" target="_blank" rel="noopener">启动该应用，并访问两次：http://localhost:2002/add</a></p>
<p>然后，打开compute-service的两个服务提供方，分别输出了类似下面的日志内容：</p>
<pre><code>端口为2000服务提供端的日志：

2019-04-16 13:48:40.690  INFO 79592 --- [nio-2000-exec-2] c.e.c.controller.ComputeController       : /add, host:zangqisong-PC, service_id:COMPUTE-SERVICE:2000, result:30

端口为2001服务提供端的日志：

2019-04-16 13:48:40.811  INFO 114792 --- [nio-2001-exec-7] c.e.c.controller.ComputeController       : /add, host:zangqisong-PC, service_id:COMPUTE-SERVICE:2001, result:30
</code></pre><p>可以看到，之前启动的两个compute-service服务端分别被调用了一次。到这里，我们已经通过Ribbon在客户端已经实现了对服务调用的均衡负载。</p>
<p><a href="https://github.com/huapisong/SpringCloudDemo/" target="_blank" rel="noopener">该工程可参见：SpringCloudDemo/eureka-ribbon</a></p>
<h3 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h3><p>Feign是一个声明式的Web Service客户端，它使得编写Web Serivce客户端变得更加简单。我们只需要使用Feign来创建一个接口并用注解来配置它既可完成。它具备可插拔的注解支持，包括Feign注解和JAX-RS注解。Feign也支持可插拔的编码器和解码器。Spring Cloud为Feign增加了对Spring MVC注解的支持，还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。</p>
<p>下面，通过一个例子来展现Feign如何方便的声明对上述computer-service服务的定义和调用。</p>
<p>创建一个Spring Boot工程，配置pom.xml，将上述的配置中的ribbon依赖替换成feign的依赖即可，具体如下：</p>
<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt;
        &lt;artifactId&gt;hystrix-javanica&lt;/artifactId&gt;
        &lt;version&gt;RELEASE&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>在应用主类中通过@EnableFeignClients注解开启Feign功能，具体如下：</p>
<pre><code>@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
public class EurekaFeignApplication {

    public static void main(String[] args) {
        SpringApplication.run(EurekaFeignApplication.class, args);
    }

}
</code></pre><p>定义compute-service服务的接口，具体如下：</p>
<pre><code>@FeignClient(&quot;compute-service&quot;)
public interface ComputeClient {

    @RequestMapping(method = RequestMethod.GET, value = &quot;/add&quot;)
    Integer add(@RequestParam(value = &quot;a&quot;) Integer a, @RequestParam(value = &quot;b&quot;) Integer b);

}

使用@FeignClient(&quot;compute-service&quot;)注解来绑定该接口对应compute-service服务
通过Spring MVC的注解来配置compute-service服务下的具体实现。
</code></pre><p>在web层中调用上面定义的ComputeClient，具体如下：</p>
<pre><code>@RestController
public class ConsumerController {

    @Autowired
    ComputeClient computeClient;

    @RequestMapping(value = &quot;/add&quot;, method = RequestMethod.GET)
    public Integer add() {
        return computeClient.add(10, 20);
    }

}
</code></pre><p>application.properties中不用变，指定eureka服务注册中心即可，如：</p>
<pre><code>spring.application.name=feign-consumer
server.port=2003
eureka.client.serviceUrl.defaultZone=http://localhost:1000/eureka/
</code></pre><p><a href="http://localhost:2003/add" target="_blank" rel="noopener">启动该应用，访问几次：http://localhost:2003/add</a></p>
<p>再观察日志，可以得到之前使用Ribbon时一样的结果，对服务提供方实现了均衡负载。</p>
<pre><code>2019-04-16 14:48:21.475  INFO 114792 --- [nio-2001-exec-9] c.e.c.controller.ComputeController       : /add, host:zangqisong-PC, service_id:COMPUTE-SERVICE:2000, result:30
2019-04-16 14:48:21.741  INFO 79592 --- [nio-2000-exec-4] c.e.c.controller.ComputeController       : /add, host:zangqisong-PC, service_id:COMPUTE-SERVICE:2000, result:30
</code></pre><p>这一节我们通过Feign以接口和注解配置的方式，轻松实现了对compute-service服务的绑定，这样我们就可以在本地应用中像本地服务一下的调用它，并且做到了客户端均衡负载。</p>
<p><a href="https://github.com/huapisong/SpringCloudDemo/" target="_blank" rel="noopener">示例可参见：SpringCloudDemo/eureka-feign</a></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/04/12/Spring Cloud(二)服务消费者/">
    <time datetime="2019-04-11T16:00:00.000Z" class="entry-date">
        2019-04-12
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Spring-Cloud-Spring-Boot-微服务/">Spring Cloud Spring Boot 微服务</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-Spring Cloud(一)服务注册与发现" class="post-Spring Cloud(一)服务注册与发现 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/04/11/Spring Cloud(一)服务注册与发现/">Spring Cloud构建微服务架构（一）服务注册与发现</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/04/11/Spring Cloud(一)服务注册与发现/" data-id="cjwk8gckx00081k0y93ll58yv" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h3 id="Spring-Cloud-简介"><a href="#Spring-Cloud-简介" class="headerlink" title="Spring Cloud 简介"></a>Spring Cloud 简介</h3><p>Spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。</p>
<p>Spring Cloud包含了多个子项目（针对分布式系统中涉及的多个不同开源产品），比如：Spring Cloud Config、Spring Cloud Netflix、Spring Cloud CloudFoundry、Spring Cloud AWS、Spring Cloud Security、Spring Cloud Commons、Spring Cloud Zookeeper、Spring Cloud CLI等项目。</p>
<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>“微服务架构”在这几年非常的火热，以至于关于微服务架构相关的产品社区也变得越来越活跃（比如：netflix、dubbo），Spring Cloud也因Spring社区的强大知名度和影响力也被广大架构师与开发者备受关注。</p>
<p>那么什么是“微服务架构”呢？简单的说，微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务与服务间通过诸如RESTful API的方式互相调用。</p>
<p>对于“微服务架构”，大家在互联网可以搜索到很多相关的介绍和研究文章来进行学习和了解。也可以阅读始祖Martin Fowler的《Microservices》，本文不做更多的介绍和描述。</p>
<h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><p>在简单介绍了Spring Cloud和微服务架构之后，下面回归本文的主旨内容，如何使用Spring Cloud搭建服务注册与发现模块。</p>
<p>这里我们会用到Spring Cloud Netflix，该项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路有（Zuul），客户端负载均衡（Ribbon）等。</p>
<p>所以，我们这里的核心内容就是服务发现模块：Eureka。下面我们动手来做一些尝试。</p>
<h3 id="创建“服务注册中心”"><a href="#创建“服务注册中心”" class="headerlink" title="创建“服务注册中心”"></a>创建“服务注册中心”</h3><p>创建一个基础的Spring Boot工程，并在pom.xml中引入需要的依赖内容：</p>
<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;${spring-cloud.version}&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre><p>通过@EnableEurekaServer注解启动一个服务注册中心提供给其他应用进行对话。这一步非常的简单，只需要在一个普通的Spring Boot应用中添加这个注解就能开启此功能，比如下面的例子：</p>
<pre><code>import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@EnableEurekaServer
@SpringBootApplication
public class EurekaApplication {

    public static void main(String[] args) {
        SpringApplication.run(EurekaApplication.class, args);
    }

}
</code></pre><p>在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，只需要在application.properties中问增加如下配置：</p>
<pre><code>server.port=1000
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
eureka.client.serviceUrl.defaultZone=http://localhost:${server.port}/eureka/
</code></pre><p>为了与后续要进行注册的服务区分，这里将服务注册中心的端口通过server.port属性设置为1000。</p>
<p><a href="http://localhost:1000/" target="_blank" rel="noopener">启动工程后，访问：http://localhost:1000/</a></p>
<p>可以看到下面的页面，其中还没有发现任何服务<br> <img src="/assets/SpringCloudImg/eurekaService.png" alt><br><a href="https://github.com/huapisong/SpringCloudDemo/" target="_blank" rel="noopener">该工程可参见：SpringCloudDemo/eureka</a></p>
<h3 id="创建“服务提供方”"><a href="#创建“服务提供方”" class="headerlink" title="创建“服务提供方”"></a>创建“服务提供方”</h3><p>下面我们创建提供服务的客户端，并向服务注册中心注册自己。</p>
<p>假设我们有一个提供计算功能的微服务模块，我们实现一个RESTful API，通过传入两个参数a和b，最后返回a + b的结果。</p>
<p>首先，创建一个基本的Spring Boot应用 compute-service，在pom.xml中，加入如下配置：</p>
<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;${spring-cloud.version}&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre><p>其次，实现/add请求处理接口，通过DiscoveryClient对象，在日志中打印出服务实例的相关内容。</p>
<pre><code>@RestController
public class ComputeController {
    private final Logger logger = LoggerFactory.getLogger(getClass());
    // 服务注册
    @Autowired
    private Registration registration;
    @Autowired
    private DiscoveryClient client;

    @RequestMapping(value = &quot;/add&quot; ,method = RequestMethod.GET)
    public Integer add(@RequestParam Integer a, @RequestParam Integer b) {

        ServiceInstance instance = serviceInstance();
        Integer r = a + b;
        logger.info(&quot;/add, host:&quot; + instance.getHost() + &quot;, service_id:&quot; + instance.getServiceId() + &quot;, result:&quot; + r);
        return r;
    }
    public ServiceInstance serviceInstance() {
        List&lt;ServiceInstance&gt; list = client.getInstances(registration.getServiceId());
        if (list != null &amp;&amp; list.size() &gt; 0) {
            for (ServiceInstance itm : list){
                if (itm.getPort() == 2001)
                    return itm;
            }
        }
        return null;
    }
}
</code></pre><p>最后在主类中通过加上@EnableDiscoveryClient注解，该注解能激活Eureka中的DiscoveryClient实现，才能实现Controller中对服务信息的输出。</p>
<pre><code>@EnableDiscoveryClient
@SpringBootApplication
public class ComputeServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(ComputeServiceApplication.class, args);
    }

}
</code></pre><p>我们在完成了服务内容的实现之后，再继续对application.properties做一些配置工作，具体如下：</p>
<pre><code>spring.application.name=compute-service
server.port=2001
eureka.client.serviceUrl.defaultZone=http://localhost:1000/eureka/
</code></pre><p>通过spring.application.name属性，我们可以指定微服务的名称后续在调用的时候只需要使用该名称就可以进行服务的访问。</p>
<p>eureka.client.serviceUrl.defaultZone属性对应服务注册中心的配置内容，指定服务注册中心的位置。</p>
<p>为了在本机上测试区分服务提供方和服务注册中心，使用server.port属性设置不同的端口。</p>
<p>启动该工程后，再次访问：<a href="http://localhost:1000/" target="_blank" rel="noopener">http://localhost:1000/</a></p>
<p>可以看到，我们定义的服务被注册了。<br> <img src="/assets/SpringCloudImg/eurekaComputeService.png" alt><br><a href="https://github.com/huapisong/SpringCloudDemo/" target="_blank" rel="noopener">该工程可参见：SpringCloudDemo/compute-service</a></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/04/11/Spring Cloud(一)服务注册与发现/">
    <time datetime="2019-04-10T16:00:00.000Z" class="entry-date">
        2019-04-11
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Spring-Cloud-Spring-Boot-微服务/">Spring Cloud Spring Boot 微服务</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-node+superagent爬虫" class="post-node+superagent爬虫 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/04/10/node+superagent爬虫/">node  爬虫</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/04/10/node+superagent爬虫/" data-id="cjwk8gcls001f1k0yjt3cdp87" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><pre><code>Node.js环境搭建
</code></pre><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p>选择一个目录，新建一个准备存放工程内容的文件夹demo。</p>
<p>打开终端（windows机器打开CMD命令行），输入npm init，根据提示，逐步输入工程信息，具体示例如下</p>
<pre><code>$ npm init
This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.

See `npm help json` for definitive documentation on these fields
and exactly what they do.

Use `npm install &lt;pkg&gt;` afterwards to install a package and
save it as a dependency in the package.json file.

Press ^C at any time to quit.
package name: (demo) demo
version: (1.0.0)
description: 爬虫
entry point: (index.js)
test command:
git repository:
keywords:
author: huapisong
license: (ISC)
About to write to D:\test\demo\package.json:

{
  &quot;name&quot;: &quot;demo&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;爬虫&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;huapisong&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}


Is this ok? (yes) yes
</code></pre><p>此时文件夹下生成了一个package.json文件，其中包含了工程的基本信息以及引用的框架等信息</p>
<h3 id="框架引入"><a href="#框架引入" class="headerlink" title="框架引入"></a>框架引入</h3><pre><code>superagent：发起http请求
cheerio：解析http返回的html内容
async：多线程并发控制
</code></pre><p>安装命令 npm install –save PACKAGE_NAME，执行以下三条命令后，工程目录下多了一个node_modules目录，该目录就是引入的框架内容。</p>
<pre><code>$npm install --save superagent
$npm install --save cheerio
$npm install --save async
</code></pre><h3 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程"></a>编码过程</h3><p>工程目录下，创建index.js</p>
<pre><code>var superagent = require(&apos;superagent&apos;);
var cheerio = require(&apos;cheerio&apos;);
var async = require(&apos;async&apos;);

var fs = require(&apos;fs&apos;);
var request = require(&quot;request&quot;);

console.log(&apos;爬虫程序开始运行......&apos;);

// 第一步，发起请求，获取的列表
superagent
    .get(&apos;http://www.wanfangdata.com.cn/keywords/getNewKeywords.do?keywords=java&amp;resource=all&amp;topNumber=18&apos;)
    .set(&apos;Accept&apos;, &apos;application/json, text/javascript, */*; q=0.01&apos;)
    .set(&apos;Content-Type&apos;,&apos;text/html;charset=UTF-8&apos;)
    .end(function(err, res){
        // res.body, res.headers, res.status
        //let body = cheerio.load(res.body);
        // 请求返回后的处理
        // 将response中返回的结果转换成JSON对象
        var words = JSON.parse(res.text).word;
        console.log(&apos;抓取的数据：&apos; + JSON.stringify(words));

        async.mapSeries(words,
            function (word, callback) {
                console.log(&apos;抓取的数据：&apos; + word);
                // 对每个对象的处理逻辑
                fetchInfo(word, callback);
                console.timeEnd(&quot;  耗时&quot;);

            },
            function (err, result) {
                console.log(&apos;final:\n&apos; + result);
            }
        );
        // 并发遍历 words对象
        /* var words = JSON.parse(res.text);
        async.mapLimit(words, 10,
            function (word, callback) {
                console.log(&apos;抓取的数据：&apos; + word);
                // 对每个对象的处理逻辑
                fetchInfo(word, callback);
                console.timeEnd(&quot;  耗时&quot;);

            },
            function (err, result) {
                console.log(&apos;final:\n&apos; + result);
            }
        );*/

    });

var concurrencyCount = 0; // 当前并发数记录
var fetchInfo = function(word, callback){
    console.time(&apos;  耗时&apos;);
    concurrencyCount++;
    console.log(&apos;并发数：&apos;, concurrencyCount, &apos;，正在抓取的是&apos;, word);

    // 写入文件内容（如果文件不存在会创建一个文件）
    fs.writeFile(&apos;./try4.txt&apos;, word+&apos;\n&apos;, { &apos;flag&apos;: &apos;a&apos; }, function(err) {
        if (err) {
            console.log(&apos;并发数:&apos;, concurrencyCount--, &apos;word&apos;, word);
            callback(null, word);
            throw err;
        }
        callback(null, word);
        // 写入成功后读取测试
        /*fs.readFile(&apos;./try4.txt&apos;, &apos;utf-8&apos;, function(err, data) {
            if (err) {
                throw err;
            }
            console.log(data);
        });*/
    });

}
</code></pre><p>工程目录下执行命令，node index.js，抓取程序开始执行</p>
<pre><code> node index.js
爬虫程序开始运行......
抓取的数据：[&quot;Java&quot;,&quot;JAVA&quot;,&quot;java&quot;,&quot;Java语言&quot;,&quot;JAVA语言&quot;,&quot;Java技术&quot;,&quot;JAVA技术&quot;,&quot;Java3D&quot;,&quot;JavaEE&quot;,&quot;Java虚拟机&quot;,&quot;Java EE&quot;,&quot;JavaBean&quot;,&quot;Java程序设计&quot;,&quot;JavaScript&quot;,&quot;JAVASCRIPT&quot;,&quot;Javascript&quot;,&quot;Java Applet&quot;]
抓取的数据：Java
并发数： 1 ，正在抓取的是 Java
 耗时: 1.329ms
抓取的数据：JAVA
并发数： 2 ，正在抓取的是 JAVA
 耗时: 0.646ms
抓取的数据：java
并发数： 3 ，正在抓取的是 java
 耗时: 0.625ms
抓取的数据：Java语言
并发数： 4 ，正在抓取的是 Java语言
 耗时: 0.642ms
抓取的数据：JAVA语言
并发数： 5 ，正在抓取的是 JAVA语言
 耗时: 0.663ms
抓取的数据：Java技术
并发数： 6 ，正在抓取的是 Java技术
 耗时: 0.410ms
抓取的数据：JAVA技术
并发数： 7 ，正在抓取的是 JAVA技术
 耗时: 0.395ms
抓取的数据：Java3D
并发数： 8 ，正在抓取的是 Java3D
 耗时: 0.377ms
抓取的数据：JavaEE
并发数： 9 ，正在抓取的是 JavaEE
 耗时: 0.240ms
抓取的数据：Java虚拟机
并发数： 10 ，正在抓取的是 Java虚拟机
 耗时: 0.346ms
抓取的数据：Java EE
并发数： 11 ，正在抓取的是 Java EE
 耗时: 0.306ms
抓取的数据：JavaBean
并发数： 12 ，正在抓取的是 JavaBean
 耗时: 0.323ms
抓取的数据：Java程序设计
并发数： 13 ，正在抓取的是 Java程序设计
 耗时: 0.326ms
抓取的数据：JavaScript
并发数： 14 ，正在抓取的是 JavaScript
 耗时: 0.306ms
抓取的数据：JAVASCRIPT
并发数： 15 ，正在抓取的是 JAVASCRIPT
 耗时: 0.346ms
抓取的数据：Javascript
并发数： 16 ，正在抓取的是 Javascript
 耗时: 1.027ms
抓取的数据：Java Applet
并发数： 17 ，正在抓取的是 Java Applet
 耗时: 0.955ms
final:
Java,JAVA,java,Java语言,JAVA语言,Java技术,JAVA技术,Java3D,JavaEE,Java虚拟机,Java EE,JavaBean,Java程序设计,JavaScript,JAVASCRIPT,Javascript,Java Applet
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/04/10/node+superagent爬虫/">
    <time datetime="2019-04-09T16:00:00.000Z" class="entry-date">
        2019-04-10
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Node/">Node</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-几个能够免费生成二维码的api接口" class="post-几个能够免费生成二维码的api接口 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/04/08/几个能够免费生成二维码的api接口/">几个能够免费生成二维码的api接口</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/04/08/几个能够免费生成二维码的api接口/" data-id="cjwk8gcm1001v1k0y5o96hwkz" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>1.百度网盘(可使用https)</p>
<pre><code>http://pan.baidu.com/share/qrcode?w=150&amp;h=150&amp;url=内容
</code></pre><p>2.iClick接口 (无https)</p>
<pre><code>http://bshare.optimix.asia/barCode?site=weixin&amp;url=内容
</code></pre><p>3.JiaThis 接口(无https)</p>
<pre><code>http://s.jiathis.com/qrcode.php?url=内容
</code></pre><p>4.联图网(无https)</p>
<pre><code>http://qr.liantu.com/api.php?text=内容
</code></pre><p>5.K780数据网(支持https和http)</p>
<pre><code>http://api.k780.com:88/?app=qr.get&amp;data=内容&amp;level=L&amp;size=6

https://sapi.k780.com/?app=qr.get&amp;data=内容&amp;level=L&amp;size=6
</code></pre><p>6.QR Code Generator(https接口)</p>
<pre><code>https://api.qrserver.com/v1/create-qr-code/?size=150x150&amp;data=内容
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/04/08/几个能够免费生成二维码的api接口/">
    <time datetime="2019-04-07T16:00:00.000Z" class="entry-date">
        2019-04-08
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/随记/">随记</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-vue组件之间通信" class="post-vue组件之间通信 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/03/26/vue组件之间通信/">vue组件之间的通信</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/03/26/vue组件之间通信/" data-id="cjwk8gcm2001w1k0ylclpgj5x" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h3 id="安装-vue-bus"><a href="#安装-vue-bus" class="headerlink" title="安装 vue-bus"></a>安装 vue-bus</h3><pre><code>npm install vue-bus --save-dev
</code></pre><h3 id="创建-vue-bus"><a href="#创建-vue-bus" class="headerlink" title="创建 vue-bus"></a>创建 vue-bus</h3><pre><code>/**
* 组件之间的通信
* @param Vue
*/
const install = (Vue) =&gt;{
  const Bus = new Vue({
      methods:{
          emit(event, ...args){
              this.$emit(event, ...args)
          },
          on (event, callback){
              this.$on(event, callback)
          },
          off(event, callback){
              this.$off(event, callback)
          }
      }
  })
  Vue.prototype.$bus = Bus
}
export default install
</code></pre><h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h3><pre><code>import VueBus from &apos;@/common/vue-bus&apos;
Vue.use(VueBus)
</code></pre><h3 id="组件a-调用-组件b"><a href="#组件a-调用-组件b" class="headerlink" title="组件a 调用 组件b"></a>组件a 调用 组件b</h3><pre><code># 组件 a
let num = Math.floor(Math.random() * 100 + 1);
this.$bus.$emit(&apos;getMenu&apos;, num);

# 组件 b
,created() {
    this.$bus.$on(&apos;getMenu&apos;, target =&gt; {
        // console.log(target);
        this.getMenus();
    });
}
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/03/26/vue组件之间通信/">
    <time datetime="2019-03-25T16:00:00.000Z" class="entry-date">
        2019-03-26
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-RPC入门总结  RPC定义和原理" class="post-RPC入门总结  RPC定义和原理 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/01/01/RPC入门总结  RPC定义和原理/">RPC入门总结 RPC定义和原理</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/01/01/RPC入门总结  RPC定义和原理/" data-id="cjwk8gcko00011k0y08cnbl5w" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>一、RPC</p>
<pre><code>1. RPC是什么

    RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。

RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。
2. 为什么要用RPC？ 
其实这是应用开发到一定的阶段的强烈需求驱动的。

    1. 如果我们开发简单的单一应用，逻辑简单、用户不多、流量不大，那我们用不着；

    2. 当我们的系统访问量增大、业务增多时，我们会发现一台单机运行此系统已经无法承受。此时，我们可以将业务拆分成几个互不关联的应用，分别部署在各自机器上，以划清逻辑并减小压力。此时，我们也可以不需要RPC，因为应用之间是互不关联的。
    3. 当我们的业务越来越多、应用也越来越多时，自然的，我们会发现有些功能已经不能简单划分开来或者划分不出来。此时，可以将公共业务逻辑抽离出来，将之组成独立的服务Service应用 。而原有的、新增的应用都可以与那些独立的Service应用 交互，以此来完成完整的业务功能。所以此时，我们急需一种高效的应用程序之间的通讯手段来完成这种需求，所以你看，RPC大显身手的时候来了！
    其实3描述的场景也是服务化 、微服务 和分布式系统架构 的基础场景。即RPC框架就是实现以上结构的有力方式。
</code></pre><p>二、RPC的原理和框架</p>
<pre><code>Nelson 的论文中指出实现 RPC 的程序包括 5 个部分：

1. User

2. User-stub

3. RPCRuntime

4. Server-stub

5. Server

    这里 user 就是 client 端，当 user 想发起一个远程调用时，它实际是通过本地调用user-stub。user-stub 负责将调用的接口、方法和参数通过约定的协议规范进行编码并通过本地的 RPCRuntime 实例传输到远端的实例。远端 RPCRuntime 实例收到请求后交给 server-stub 进行解码后发起本地端调用，调用结果再返回给 user 端。
    RPC 服务方通过 RpcServer 去导出（export）远程接口方法，而客户方通过 RpcClient 去引入（import）远程接口方法。客户方像调用本地方法一样去调用远程接口方法，RPC 框架提供接口的代理实现，实际的调用将委托给代理RpcProxy 。代理封装调用信息并将调用转交给RpcInvoker 去实际执行。在客户端的RpcInvoker 通过连接器RpcConnector 去维持与服务端的通道RpcChannel，并使用RpcProtocol 执行协议编码（encode）并将编码后的请求消息通过通道发送给服务方。
    RPC 服务端接收器 RpcAcceptor 接收客户端的调用请求，同样使用RpcProtocol 执行协议解码（decode）。解码后的调用信息传递给RpcProcessor 去控制处理调用过程，最后再委托调用给RpcInvoker 去实际执行并返回调用结果。如下是各个部分的详细职责：
    1. RpcServer  
       负责导出（export）远程接口  
    2. RpcClient  
       负责导入（import）远程接口的代理实现  
    3. RpcProxy  
       远程接口的代理实现  
    4. RpcInvoker  
       客户方实现：负责编码调用信息和发送调用请求到服务方并等待调用结果返回  
       服务方实现：负责调用服务端接口的具体实现并返回调用结果  
    5. RpcProtocol  
       负责协议编/解码  
    6. RpcConnector  
       负责维持客户方和服务方的连接通道和发送数据到服务方  
    7. RpcAcceptor  
       负责接收客户方请求并返回请求结果  
    8. RpcProcessor  
       负责在服务方控制调用过程，包括管理调用线程池、超时时间等  
    9. RpcChannel  
       数据传输通道  
</code></pre><p>三、Java中常用的RPC框架</p>
<pre><code>目前常用的RPC框架如下：

1. Thrift：thrift是一个软件框架，用来进行可扩展且跨语言的服务的开发。它结合了功能强大的软件堆栈和代码生成引擎，以构建在 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml 这些编程语言间无缝结合的、高效的服务。

2. Dubbo：Dubbo是一个分布式服务框架，以及SOA治理方案。其功能主要包括：高性能NIO通讯及多协议集成，服务动态寻址与路由，软负载均衡与容错，依赖分析与降级等。 Dubbo是阿里巴巴内部的SOA服务化治理方案的核心框架，Dubbo自2011年开源后，已被许多非阿里系公司使用。 

3. Spring Cloud：Spring Cloud由众多子项目组成，如Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Consul 等，提供了搭建分布式系统及微服务常用的工具，如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性token、全局锁、选主、分布式会话和集群状态等，满足了构建微服务所需的所有解决方案。Spring Cloud基于Spring Boot, 使得开发部署极其简单。
</code></pre><p>四、RPC和消息队列的差异</p>
<pre><code>1. 功能差异

    在架构上，RPC和Message的差异点是，Message有一个中间结点Message Queue，可以把消息存储。
    消息的特点
    1. Message Queue把请求的压力保存一下，逐渐释放出来，让处理者按照自己的节奏来处理。
    2. Message Queue引入一下新的结点，系统的可靠性会受Message Queue结点的影响。
    3. Message Queue是异步单向的消息。发送消息设计成是不需要等待消息处理的完成。
    所以对于有同步返回需求，用Message Queue则变得麻烦了。
RPC的特点
    同步调用，对于要等待返回结果/处理结果的场景，RPC是可以非常自然直觉的使用方式(RPC也可以是异步调用)。
    由于等待结果，Consumer（Client）会有线程消耗。如果以异步RPC的方式使用，Consumer（Client）线程消耗可以去掉。但不能做到像消息一样暂存消息/请求，压力会直接传导到服务Provider。
    2. 适用场合差异
        1. 希望同步得到结果的场合，RPC合适。
        2. 希望使用简单，则RPC；RPC操作基于接口，使用简单，使用方式模拟本地调用。异步的方式编程比较复杂。
        3. 不希望发送端（RPC Consumer、Message Sender）受限于处理端（RPC Provider、Message Receiver）的速度时，使用Message Queue。
        随着业务增长，有的处理端处理量会成为瓶颈，会进行同步调用到异步消息的改造。这样的改造实际上有调整业务的使用方式。比如原来一个操作页面提交后就下一个页面会看到处理结果；改造后异步消息后，下一个页面就会变成“操作已提交，完成后会得到通知”。
    3. 不适用场合说明
        1. RPC同步调用使用Message Queue来传输调用信息。 上面分析可以知道，这样的做法，发送端是在等待，同时占用一个中间点的资源。变得复杂了，但没有对等的收益。
        2. 对于返回值是void的调用，可以这样做，因为实际上这个调用业务上往往不需要同步得到处理结果的，只要保证会处理即可。（RPC的方式可以保证调用返回即处理完成，使用消息方式后这一点不能保证了。）
        3. 返回值是void的调用，使用消息，效果上是把消息的使用方式Wrap成了服务调用（服务调用使用方式成简单，基于业务接口）。
</code></pre><p>五、RPC框架的核心技术点</p>
<pre><code>RPC框架实现的几个核心技术点：

（1）服务暴露：

    远程提供者需要以某种形式提供服务调用相关的信息，包括但不限于服务接口定义、数据结构、或者中间态的服务定义文件。例如Facebook的Thrift的IDL文件，Web service的WSDL文件；服务的调用者需要通过一定的途径获取远程服务调用相关的信息。

    目前，大部分跨语言平台 RPC 框架采用根据 IDL 定义通过 code generator 去生成 stub 代码，这种方式下实际导入的过程就是通过代码生成器在编译期完成的。代码生成的方式对跨语言平台 RPC 框架而言是必然的选择，而对于同一语言平台的 RPC 则可以通过共享接口定义来实现。这里的导入方式本质也是一种代码生成技术，只不过是在运行时生成，比静态编译期的代码生成看起来更简洁些。

    java 中还有一种比较特殊的调用就是多态，也就是一个接口可能有多个实现，那么远程调用时到底调用哪个？这个本地调用的语义是通过 jvm 提供的引用多态性隐式实现的，那么对于 RPC 来说跨进程的调用就没法隐式实现了。如果前面DemoService 接口有 2 个实现，那么在导出接口时就需要特殊标记不同的实现需要，那么远程调用时也需要传递该标记才能调用到正确的实现类，这样就解决了多态调用的语义问题。

（2）远程代理对象：

    服务调用者用的服务实际是远程服务的本地代理。说白了就是通过动态代理来实现。

    java 里至少提供了两种技术来提供动态代码生成，一种是 jdk 动态代理，另外一种是字节码生成。动态代理相比字节码生成使用起来更方便，但动态代理方式在性能上是要逊色于直接的字节码生成的，而字节码生成在代码可读性上要差很多。两者权衡起来，个人认为牺牲一些性能来获得代码可读性和可维护性显得更重要。

（3）通信：

    RPC框架与具体的协议无关。RPC 可基于 HTTP 或 TCP 协议，Web Service 就是基于 HTTP 协议的 RPC，它具有良好的跨平台性，但其性能却不如基于 TCP 协议的 RPC。

    1. TCP/HTTP：众所周知，TCP 是传输层协议，HTTP 是应用层协议，而传输层较应用层更加底层，在数据传输方面，越底层越快，因此，在一般情况下，TCP 一定比 HTTP 快。

    2. 消息ID：RPC 的应用场景实质是一种可靠的请求应答消息流，和 HTTP 类似。因此选择长连接方式的 TCP 协议会更高效，与 HTTP 不同的是在协议层面我们定义了每个消息的唯一 id，因此可以更容易的复用连接。

    3. IO方式：为了支持高并发，传统的阻塞式 IO 显然不太合适，因此我们需要异步的 IO，即 NIO。Java 提供了 NIO 的解决方案，Java 7 也提供了更优秀的 NIO.2 支持。

    4. 多连接：既然使用长连接，那么第一个问题是到底 client 和 server 之间需要多少根连接？实际上单连接和多连接在使用上没有区别，对于数据传输量较小的应用类型，单连接基本足够。单连接和多连接最大的区别在于，每根连接都有自己私有的发送和接收缓冲区，因此大数据量传输时分散在不同的连接缓冲区会得到更好的吞吐效率。所以，如果你的数据传输量不足以让单连接的缓冲区一直处于饱和状态的话，那么使用多连接并不会产生任何明显的提升，反而会增加连接管理的开销。
    5. 心跳：连接是由 client 端发起建立并维持。如果 client 和 server 之间是直连的，那么连接一般不会中断（当然物理链路故障除外）。如果 client 和 server 连接经过一些负载中转设备，有可能连接一段时间不活跃时会被这些中间设备中断。为了保持连接有必要定时为每个连接发送心跳数据以维持连接不中断。心跳消息是 RPC 框架库使用的内部消息，在前文协议头结构中也有一个专门的心跳位，就是用来标记心跳消息的，它对业务应用透明。

（4）序列化：

    两方面会直接影响 RPC 的性能，一是传输方式，二是序列化。

    1. 序列化方式：毕竟是远程通信，需要将对象转化成二进制流进行传输。不同的RPC框架应用的场景不同，在序列化上也会采取不同的技术。 就序列化而言，Java 提供了默认的序列化方式，但在高并发的情况下，这种方式将会带来一些性能上的瓶颈，于是市面上出现了一系列优秀的序列化框架，比如：Protobuf、Kryo、Hessian、Jackson 等，它们可以取代 Java 默认的序列化，从而提供更高效的性能。

    2. 编码内容：出于效率考虑，编码的信息越少越好（传输数据少），编码的规则越简单越好（执行效率高）。如下是编码需要具备的信息：

    -- 调用编码 --  
    1. 接口方法  
       包括接口名、方法名  
    2. 方法参数  
       包括参数类型、参数值  
    3. 调用属性  
       包括调用属性信息，例如调用附件隐式参数、调用超时时间等  

    -- 返回编码 --  
    1. 返回结果  
       接口方法中定义的返回值  
    2. 返回码  
       异常返回码  
    3. 返回异常信息  
       调用异常信息 

    除了以上这些必须的调用信息，我们可能还需要一些元信息以方便程序编解码以及未来可能的扩展。这样我们的编码消息里面就分成了两部分，一部分是元信息、另一部分是调用的必要信息。如果设计一种 RPC 协议消息的话，元信息我们把它放在协议消息头中，而必要信息放在协议消息体中。下面给出一种概念上的 RPC 协议消息设计格式：

    -- 消息头 --  
    magic      : 协议魔数，为解码设计  
    header size: 协议头长度，为扩展设计  
    version    : 协议版本，为兼容设计  
    st         : 消息体序列化类型  
    hb         : 心跳消息标记，为长连接传输层心跳设计  
    ow         : 单向消息标记，  
    rp         : 响应消息标记，不置位默认是请求消息  
    status code: 响应消息状态码  
    reserved   : 为字节对齐保留  
    message id : 消息 id  
    body size  : 消息体长度  

    -- 消息体 --  
    采用序列化编码，常见有以下格式  
    xml   : 如 webservie soap  
    json  : 如 JSON-RPC  
    binary: 如 thrift; hession; kryo 等  
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/01/01/RPC入门总结  RPC定义和原理/">
    <time datetime="2018-12-31T16:00:00.000Z" class="entry-date">
        2019-01-01
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/随记/">随记</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-String反转" class="post-String反转 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/02/06/String反转/">String 的反转</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2018/02/06/String反转/" data-id="cjwk8gckv00071k0y8b1dlj5u" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <pre><code>package com.example.demo;

import java.util.Stack;

/**
 * String 的反转
 */
public class Reverse {
    private String str = null;

    public Reverse(String str) {
        this.str = str;
    }

    // 数组实现String反转
    public String reverseByArray() {
        if (str == null || str.length() == 1) {
            return str;
        }
        char[] ch = str.toCharArray();// 字符串转换成字符数组
        for (int i = 0; i &lt; ch.length / 2; i++) {
            char temp = ch[i];
            ch[i] = ch[ch.length - i - 1];
            ch[ch.length - i - 1] = temp;
        }
        return new String(ch);
    }

    // 用栈实现String反转
    public String reverseByStack() {
        if (str == null || str.length() == 1) {
            return str;
        }
        Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();
        char[] ch = str.toCharArray();// 字符串转换成字符数组
        for (char c : ch) {
            stack.push(c);// 每个字符，推进栈
        }
        for (int i = 0; i &lt; ch.length; i++) {
            ch[i] = stack.pop();// 移除这个堆栈的顶部对象
        }
        return new String(ch);
    }

    // 用逆序遍历实现String反转
    public String reverseBySort() {
        if (str == null || str.length() == 1) {
            return str;
        }
        StringBuffer sb = new StringBuffer();
        for (int i = str.length() - 1; i &gt;= 0; i--) {
            sb.append(str.charAt(i));// 使用StringBuffer从右往左拼接字符
        }
        return sb.toString();
    }

    // 使用位运算实现String反转
    public String reverseByBit() {
        if (str == null || str.length() == 1) {
            return str;
        }
        char[] ch = str.toCharArray();// 字符串转换成字符数组
        int len = str.length();
        for (int i = 0; i &lt; len / 2; i++) {
            ch[i] ^= ch[len - 1 - i];
            ch[len - 1 - i] ^= ch[i];
            ch[i] ^= ch[len - 1 - i];
        }
        return new String(ch);
    }

    //使用递归实现String反转
    public String reverseByRecursive(String str) {
        if (str == null || str.length() == 0) {
            return str;
        }
        if (str.length() == 1) {
            return str;
        } else {
            // 从下标为1开始截取字符串，在返回下标为0的字符
            return reverseByRecursive(str.substring(1)) + str.charAt(0);
        }
    }

    // 使用 StringBuilder reverse() 方法反转
    public String reverseByStringBuilder(String str) {
        if (str == null || str.length() == 0) {
            return str;
        }
        StringBuilder sb = new StringBuilder(str);
        return sb.reverse().toString();
    }

    public static void main(String[] args) {
        String s = &quot;123456&quot;;

        Reverse r = new Reverse(s);
        System.out.println(r.reverseByArray());
        System.out.println(r.reverseByStack());
        System.out.println(r.reverseBySort());
        System.out.println(r.reverseByBit());
        System.out.println(r.reverseByRecursive(s));
        System.out.println(r.reverseByStringBuilder(s));
    }
}
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/02/06/String反转/">
    <time datetime="2018-02-05T16:00:00.000Z" class="entry-date">
        2018-02-06
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

    
    </footer>
</article>






  
  
    <nav id="pagination">
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
      </nav>
    </nav>
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value name="s" id="s">
        <input type="submit" id="searchsubmit" value="搜索">
    </div>
</form></aside>
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-content">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SVN/">SVN</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud-Spring-Boot-微服务/">Spring Cloud Spring Boot 微服务</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/node-vue/">node vue</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随记/">随记</a><span class="category-list-count">5</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2019/06/04/vue 事件中的 .native/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/06/03/java 正则表达式 手机号 邮箱/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/05/14/node-vue-webpack构建项目/">node-vue-webpack 构建项目</a>
          </li>
        
          <li>
            <a href="/2019/05/07/关于Java 23种设计模式/">关于Java 23种设计模式</a>
          </li>
        
          <li>
            <a href="/2019/05/06/vue + webpack 多模块静态文件导入/">vue + webpack 多模块静态文件导入</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2019 花皮松
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>