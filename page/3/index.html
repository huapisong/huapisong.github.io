<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  

  
  
  
  
  
  
  <title>随记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="随记">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="随记">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="随记">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src="//push.zhanzhang.baidu.com/push.js"></script>
</head></html>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="随记" rel="home">随记</a>
      </h1>
      
        <h2 class="site-description hitokoto"></h2>
        <script type="text/javascript" src="https://v1.hitokoto.cn/?encode=js"></script>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-Spring Cloud(一)服务注册与发现" class="post-Spring Cloud(一)服务注册与发现 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/04/11/Spring Cloud(一)服务注册与发现/">Spring Cloud构建微服务架构（一）服务注册与发现</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/04/11/Spring Cloud(一)服务注册与发现/" data-id="cjzam8g0j002agouhw4am1wdq" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h3 id="Spring-Cloud-简介"><a href="#Spring-Cloud-简介" class="headerlink" title="Spring Cloud 简介"></a>Spring Cloud 简介</h3><p>Spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。</p>
<p>Spring Cloud包含了多个子项目（针对分布式系统中涉及的多个不同开源产品），比如：Spring Cloud Config、Spring Cloud Netflix、Spring Cloud CloudFoundry、Spring Cloud AWS、Spring Cloud Security、Spring Cloud Commons、Spring Cloud Zookeeper、Spring Cloud CLI等项目。</p>
<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>“微服务架构”在这几年非常的火热，以至于关于微服务架构相关的产品社区也变得越来越活跃（比如：netflix、dubbo），Spring Cloud也因Spring社区的强大知名度和影响力也被广大架构师与开发者备受关注。</p>
<p>那么什么是“微服务架构”呢？简单的说，微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务与服务间通过诸如RESTful API的方式互相调用。</p>
<p>对于“微服务架构”，大家在互联网可以搜索到很多相关的介绍和研究文章来进行学习和了解。也可以阅读始祖Martin Fowler的《Microservices》，本文不做更多的介绍和描述。</p>
<h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><p>在简单介绍了Spring Cloud和微服务架构之后，下面回归本文的主旨内容，如何使用Spring Cloud搭建服务注册与发现模块。</p>
<p>这里我们会用到Spring Cloud Netflix，该项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路有（Zuul），客户端负载均衡（Ribbon）等。</p>
<p>所以，我们这里的核心内容就是服务发现模块：Eureka。下面我们动手来做一些尝试。</p>
<h3 id="创建“服务注册中心”"><a href="#创建“服务注册中心”" class="headerlink" title="创建“服务注册中心”"></a>创建“服务注册中心”</h3><p>创建一个基础的Spring Boot工程，并在pom.xml中引入需要的依赖内容：</p>
<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;${spring-cloud.version}&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre><p>通过@EnableEurekaServer注解启动一个服务注册中心提供给其他应用进行对话。这一步非常的简单，只需要在一个普通的Spring Boot应用中添加这个注解就能开启此功能，比如下面的例子：</p>
<pre><code>import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@EnableEurekaServer
@SpringBootApplication
public class EurekaApplication {

    public static void main(String[] args) {
        SpringApplication.run(EurekaApplication.class, args);
    }

}
</code></pre><p>在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，只需要在application.properties中问增加如下配置：</p>
<pre><code>server.port=1000
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
eureka.client.serviceUrl.defaultZone=http://localhost:${server.port}/eureka/
</code></pre><p>为了与后续要进行注册的服务区分，这里将服务注册中心的端口通过server.port属性设置为1000。</p>
<p><a href="http://localhost:1000/" target="_blank" rel="noopener">启动工程后，访问：http://localhost:1000/</a></p>
<p>可以看到下面的页面，其中还没有发现任何服务<br> <img src="/assets/SpringCloudImg/eurekaService.png" alt="image"><br><a href="https://github.com/huapisong/SpringCloudDemo/" target="_blank" rel="noopener">该工程可参见：SpringCloudDemo/eureka</a></p>
<h3 id="创建“服务提供方”"><a href="#创建“服务提供方”" class="headerlink" title="创建“服务提供方”"></a>创建“服务提供方”</h3><p>下面我们创建提供服务的客户端，并向服务注册中心注册自己。</p>
<p>假设我们有一个提供计算功能的微服务模块，我们实现一个RESTful API，通过传入两个参数a和b，最后返回a + b的结果。</p>
<p>首先，创建一个基本的Spring Boot应用 compute-service，在pom.xml中，加入如下配置：</p>
<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;${spring-cloud.version}&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre><p>其次，实现/add请求处理接口，通过DiscoveryClient对象，在日志中打印出服务实例的相关内容。</p>
<pre><code>@RestController
public class ComputeController {
    private final Logger logger = LoggerFactory.getLogger(getClass());
    // 服务注册
    @Autowired
    private Registration registration;
    @Autowired
    private DiscoveryClient client;

    @RequestMapping(value = &quot;/add&quot; ,method = RequestMethod.GET)
    public Integer add(@RequestParam Integer a, @RequestParam Integer b) {

        ServiceInstance instance = serviceInstance();
        Integer r = a + b;
        logger.info(&quot;/add, host:&quot; + instance.getHost() + &quot;, service_id:&quot; + instance.getServiceId() + &quot;, result:&quot; + r);
        return r;
    }
    public ServiceInstance serviceInstance() {
        List&lt;ServiceInstance&gt; list = client.getInstances(registration.getServiceId());
        if (list != null &amp;&amp; list.size() &gt; 0) {
            for (ServiceInstance itm : list){
                if (itm.getPort() == 2001)
                    return itm;
            }
        }
        return null;
    }
}
</code></pre><p>最后在主类中通过加上@EnableDiscoveryClient注解，该注解能激活Eureka中的DiscoveryClient实现，才能实现Controller中对服务信息的输出。</p>
<pre><code>@EnableDiscoveryClient
@SpringBootApplication
public class ComputeServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(ComputeServiceApplication.class, args);
    }

}
</code></pre><p>我们在完成了服务内容的实现之后，再继续对application.properties做一些配置工作，具体如下：</p>
<pre><code>spring.application.name=compute-service
server.port=2001
eureka.client.serviceUrl.defaultZone=http://localhost:1000/eureka/
</code></pre><p>通过spring.application.name属性，我们可以指定微服务的名称后续在调用的时候只需要使用该名称就可以进行服务的访问。</p>
<p>eureka.client.serviceUrl.defaultZone属性对应服务注册中心的配置内容，指定服务注册中心的位置。</p>
<p>为了在本机上测试区分服务提供方和服务注册中心，使用server.port属性设置不同的端口。</p>
<p>启动该工程后，再次访问：<a href="http://localhost:1000/" target="_blank" rel="noopener">http://localhost:1000/</a></p>
<p>可以看到，我们定义的服务被注册了。<br><img src="/assets/SpringCloudImg/eurekaComputeService.png" alt="image"><br><a href="https://github.com/huapisong/SpringCloudDemo/" target="_blank" rel="noopener">该工程可参见：SpringCloudDemo/compute-service</a></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/04/11/Spring Cloud(一)服务注册与发现/">
    <time datetime="2019-04-10T16:00:00.000Z" class="entry-date">
        2019-04-11
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Spring-Cloud-Spring-Boot-微服务/">Spring Cloud Spring Boot 微服务</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-node+superagent爬虫" class="post-node+superagent爬虫 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/04/10/node+superagent爬虫/">node  爬虫</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/04/10/node+superagent爬虫/" data-id="cjzam8fzn000vgouhx1bxaqjo" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><pre><code>Node.js环境搭建
</code></pre><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p>选择一个目录，新建一个准备存放工程内容的文件夹demo。</p>
<p>打开终端（windows机器打开CMD命令行），输入npm init，根据提示，逐步输入工程信息，具体示例如下</p>
<pre><code>$ npm init
This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.

See `npm help json` for definitive documentation on these fields
and exactly what they do.

Use `npm install &lt;pkg&gt;` afterwards to install a package and
save it as a dependency in the package.json file.

Press ^C at any time to quit.
package name: (demo) demo
version: (1.0.0)
description: 爬虫
entry point: (index.js)
test command:
git repository:
keywords:
author: huapisong
license: (ISC)
About to write to D:\test\demo\package.json:

{
  &quot;name&quot;: &quot;demo&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;爬虫&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;huapisong&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}


Is this ok? (yes) yes
</code></pre><p>此时文件夹下生成了一个package.json文件，其中包含了工程的基本信息以及引用的框架等信息</p>
<h3 id="框架引入"><a href="#框架引入" class="headerlink" title="框架引入"></a>框架引入</h3><pre><code>superagent：发起http请求
cheerio：解析http返回的html内容
async：多线程并发控制
</code></pre><p>安装命令 npm install –save PACKAGE_NAME，执行以下三条命令后，工程目录下多了一个node_modules目录，该目录就是引入的框架内容。</p>
<pre><code>$npm install --save superagent
$npm install --save cheerio
$npm install --save async
</code></pre><h3 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程"></a>编码过程</h3><p>工程目录下，创建index.js</p>
<pre><code>var superagent = require(&apos;superagent&apos;);
var cheerio = require(&apos;cheerio&apos;);
var async = require(&apos;async&apos;);

var fs = require(&apos;fs&apos;);
var request = require(&quot;request&quot;);

console.log(&apos;爬虫程序开始运行......&apos;);

// 第一步，发起请求，获取的列表
superagent
    .get(&apos;http://www.wanfangdata.com.cn/keywords/getNewKeywords.do?keywords=java&amp;resource=all&amp;topNumber=18&apos;)
    .set(&apos;Accept&apos;, &apos;application/json, text/javascript, */*; q=0.01&apos;)
    .set(&apos;Content-Type&apos;,&apos;text/html;charset=UTF-8&apos;)
    .end(function(err, res){
        // res.body, res.headers, res.status
        //let body = cheerio.load(res.body);
        // 请求返回后的处理
        // 将response中返回的结果转换成JSON对象
        var words = JSON.parse(res.text).word;
        console.log(&apos;抓取的数据：&apos; + JSON.stringify(words));

        async.mapSeries(words,
            function (word, callback) {
                console.log(&apos;抓取的数据：&apos; + word);
                // 对每个对象的处理逻辑
                fetchInfo(word, callback);
                console.timeEnd(&quot;  耗时&quot;);

            },
            function (err, result) {
                console.log(&apos;final:\n&apos; + result);
            }
        );
        // 并发遍历 words对象
        /* var words = JSON.parse(res.text);
        async.mapLimit(words, 10,
            function (word, callback) {
                console.log(&apos;抓取的数据：&apos; + word);
                // 对每个对象的处理逻辑
                fetchInfo(word, callback);
                console.timeEnd(&quot;  耗时&quot;);

            },
            function (err, result) {
                console.log(&apos;final:\n&apos; + result);
            }
        );*/

    });

var concurrencyCount = 0; // 当前并发数记录
var fetchInfo = function(word, callback){
    console.time(&apos;  耗时&apos;);
    concurrencyCount++;
    console.log(&apos;并发数：&apos;, concurrencyCount, &apos;，正在抓取的是&apos;, word);

    // 写入文件内容（如果文件不存在会创建一个文件）
    fs.writeFile(&apos;./try4.txt&apos;, word+&apos;\n&apos;, { &apos;flag&apos;: &apos;a&apos; }, function(err) {
        if (err) {
            console.log(&apos;并发数:&apos;, concurrencyCount--, &apos;word&apos;, word);
            callback(null, word);
            throw err;
        }
        callback(null, word);
        // 写入成功后读取测试
        /*fs.readFile(&apos;./try4.txt&apos;, &apos;utf-8&apos;, function(err, data) {
            if (err) {
                throw err;
            }
            console.log(data);
        });*/
    });

}
</code></pre><p>工程目录下执行命令，node index.js，抓取程序开始执行</p>
<pre><code> node index.js
爬虫程序开始运行......
抓取的数据：[&quot;Java&quot;,&quot;JAVA&quot;,&quot;java&quot;,&quot;Java语言&quot;,&quot;JAVA语言&quot;,&quot;Java技术&quot;,&quot;JAVA技术&quot;,&quot;Java3D&quot;,&quot;JavaEE&quot;,&quot;Java虚拟机&quot;,&quot;Java EE&quot;,&quot;JavaBean&quot;,&quot;Java程序设计&quot;,&quot;JavaScript&quot;,&quot;JAVASCRIPT&quot;,&quot;Javascript&quot;,&quot;Java Applet&quot;]
抓取的数据：Java
并发数： 1 ，正在抓取的是 Java
 耗时: 1.329ms
抓取的数据：JAVA
并发数： 2 ，正在抓取的是 JAVA
 耗时: 0.646ms
抓取的数据：java
并发数： 3 ，正在抓取的是 java
 耗时: 0.625ms
抓取的数据：Java语言
并发数： 4 ，正在抓取的是 Java语言
 耗时: 0.642ms
抓取的数据：JAVA语言
并发数： 5 ，正在抓取的是 JAVA语言
 耗时: 0.663ms
抓取的数据：Java技术
并发数： 6 ，正在抓取的是 Java技术
 耗时: 0.410ms
抓取的数据：JAVA技术
并发数： 7 ，正在抓取的是 JAVA技术
 耗时: 0.395ms
抓取的数据：Java3D
并发数： 8 ，正在抓取的是 Java3D
 耗时: 0.377ms
抓取的数据：JavaEE
并发数： 9 ，正在抓取的是 JavaEE
 耗时: 0.240ms
抓取的数据：Java虚拟机
并发数： 10 ，正在抓取的是 Java虚拟机
 耗时: 0.346ms
抓取的数据：Java EE
并发数： 11 ，正在抓取的是 Java EE
 耗时: 0.306ms
抓取的数据：JavaBean
并发数： 12 ，正在抓取的是 JavaBean
 耗时: 0.323ms
抓取的数据：Java程序设计
并发数： 13 ，正在抓取的是 Java程序设计
 耗时: 0.326ms
抓取的数据：JavaScript
并发数： 14 ，正在抓取的是 JavaScript
 耗时: 0.306ms
抓取的数据：JAVASCRIPT
并发数： 15 ，正在抓取的是 JAVASCRIPT
 耗时: 0.346ms
抓取的数据：Javascript
并发数： 16 ，正在抓取的是 Javascript
 耗时: 1.027ms
抓取的数据：Java Applet
并发数： 17 ，正在抓取的是 Java Applet
 耗时: 0.955ms
final:
Java,JAVA,java,Java语言,JAVA语言,Java技术,JAVA技术,Java3D,JavaEE,Java虚拟机,Java EE,JavaBean,Java程序设计,JavaScript,JAVASCRIPT,Javascript,Java Applet
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/04/10/node+superagent爬虫/">
    <time datetime="2019-04-09T16:00:00.000Z" class="entry-date">
        2019-04-10
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Node/">Node</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-几个能够免费生成二维码的api接口" class="post-几个能够免费生成二维码的api接口 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/04/08/几个能够免费生成二维码的api接口/">几个能够免费生成二维码的api接口</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/04/08/几个能够免费生成二维码的api接口/" data-id="cjzam8fzy001igouhi56evbcf" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>1.百度网盘(可使用https)</p>
<pre><code>http://pan.baidu.com/share/qrcode?w=150&amp;h=150&amp;url=内容
</code></pre><p>2.iClick接口 (无https)</p>
<pre><code>http://bshare.optimix.asia/barCode?site=weixin&amp;url=内容
</code></pre><p>3.JiaThis 接口(无https)</p>
<pre><code>http://s.jiathis.com/qrcode.php?url=内容
</code></pre><p>4.联图网(无https)</p>
<pre><code>http://qr.liantu.com/api.php?text=内容
</code></pre><p>5.K780数据网(支持https和http)</p>
<pre><code>http://api.k780.com:88/?app=qr.get&amp;data=内容&amp;level=L&amp;size=6

https://sapi.k780.com/?app=qr.get&amp;data=内容&amp;level=L&amp;size=6
</code></pre><p>6.QR Code Generator(https接口)</p>
<pre><code>https://api.qrserver.com/v1/create-qr-code/?size=150x150&amp;data=内容
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/04/08/几个能够免费生成二维码的api接口/">
    <time datetime="2019-04-07T16:00:00.000Z" class="entry-date">
        2019-04-08
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/随记/">随记</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-vue组件之间通信" class="post-vue组件之间通信 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/03/26/vue组件之间通信/">vue组件之间的通信</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/03/26/vue组件之间通信/" data-id="cjzam8fzu0018gouh2hzt2nn0" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h3 id="安装-vue-bus"><a href="#安装-vue-bus" class="headerlink" title="安装 vue-bus"></a>安装 vue-bus</h3><pre><code>npm install vue-bus --save-dev
</code></pre><h3 id="创建-vue-bus"><a href="#创建-vue-bus" class="headerlink" title="创建 vue-bus"></a>创建 vue-bus</h3><pre><code>/**
* 组件之间的通信
* @param Vue
*/
const install = (Vue) =&gt;{
  const Bus = new Vue({
      methods:{
          emit(event, ...args){
              this.$emit(event, ...args)
          },
          on (event, callback){
              this.$on(event, callback)
          },
          off(event, callback){
              this.$off(event, callback)
          }
      }
  })
  Vue.prototype.$bus = Bus
}
export default install
</code></pre><h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h3><pre><code>import VueBus from &apos;@/common/vue-bus&apos;
Vue.use(VueBus)
</code></pre><h3 id="组件a-调用-组件b"><a href="#组件a-调用-组件b" class="headerlink" title="组件a 调用 组件b"></a>组件a 调用 组件b</h3><pre><code># 组件 a
let num = Math.floor(Math.random() * 100 + 1);
this.$bus.$emit(&apos;getMenu&apos;, num);

# 组件 b
,created() {
    this.$bus.$on(&apos;getMenu&apos;, target =&gt; {
        // console.log(target);
        this.getMenus();
    });
}
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/03/26/vue组件之间通信/">
    <time datetime="2019-03-25T16:00:00.000Z" class="entry-date">
        2019-03-26
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-RPC入门总结  RPC定义和原理" class="post-RPC入门总结  RPC定义和原理 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/01/01/RPC入门总结  RPC定义和原理/">RPC入门总结 RPC定义和原理</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/01/01/RPC入门总结  RPC定义和原理/" data-id="cjzam8g0i0029gouhw3ljijgj" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>一、RPC</p>
<pre><code>1. RPC是什么

    RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。

RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。
2. 为什么要用RPC？ 
其实这是应用开发到一定的阶段的强烈需求驱动的。

    1. 如果我们开发简单的单一应用，逻辑简单、用户不多、流量不大，那我们用不着；

    2. 当我们的系统访问量增大、业务增多时，我们会发现一台单机运行此系统已经无法承受。此时，我们可以将业务拆分成几个互不关联的应用，分别部署在各自机器上，以划清逻辑并减小压力。此时，我们也可以不需要RPC，因为应用之间是互不关联的。
    3. 当我们的业务越来越多、应用也越来越多时，自然的，我们会发现有些功能已经不能简单划分开来或者划分不出来。此时，可以将公共业务逻辑抽离出来，将之组成独立的服务Service应用 。而原有的、新增的应用都可以与那些独立的Service应用 交互，以此来完成完整的业务功能。所以此时，我们急需一种高效的应用程序之间的通讯手段来完成这种需求，所以你看，RPC大显身手的时候来了！
    其实3描述的场景也是服务化 、微服务 和分布式系统架构 的基础场景。即RPC框架就是实现以上结构的有力方式。
</code></pre><p>二、RPC的原理和框架</p>
<pre><code>Nelson 的论文中指出实现 RPC 的程序包括 5 个部分：

1. User

2. User-stub

3. RPCRuntime

4. Server-stub

5. Server

    这里 user 就是 client 端，当 user 想发起一个远程调用时，它实际是通过本地调用user-stub。user-stub 负责将调用的接口、方法和参数通过约定的协议规范进行编码并通过本地的 RPCRuntime 实例传输到远端的实例。远端 RPCRuntime 实例收到请求后交给 server-stub 进行解码后发起本地端调用，调用结果再返回给 user 端。
    RPC 服务方通过 RpcServer 去导出（export）远程接口方法，而客户方通过 RpcClient 去引入（import）远程接口方法。客户方像调用本地方法一样去调用远程接口方法，RPC 框架提供接口的代理实现，实际的调用将委托给代理RpcProxy 。代理封装调用信息并将调用转交给RpcInvoker 去实际执行。在客户端的RpcInvoker 通过连接器RpcConnector 去维持与服务端的通道RpcChannel，并使用RpcProtocol 执行协议编码（encode）并将编码后的请求消息通过通道发送给服务方。
    RPC 服务端接收器 RpcAcceptor 接收客户端的调用请求，同样使用RpcProtocol 执行协议解码（decode）。解码后的调用信息传递给RpcProcessor 去控制处理调用过程，最后再委托调用给RpcInvoker 去实际执行并返回调用结果。如下是各个部分的详细职责：
    1. RpcServer  
       负责导出（export）远程接口  
    2. RpcClient  
       负责导入（import）远程接口的代理实现  
    3. RpcProxy  
       远程接口的代理实现  
    4. RpcInvoker  
       客户方实现：负责编码调用信息和发送调用请求到服务方并等待调用结果返回  
       服务方实现：负责调用服务端接口的具体实现并返回调用结果  
    5. RpcProtocol  
       负责协议编/解码  
    6. RpcConnector  
       负责维持客户方和服务方的连接通道和发送数据到服务方  
    7. RpcAcceptor  
       负责接收客户方请求并返回请求结果  
    8. RpcProcessor  
       负责在服务方控制调用过程，包括管理调用线程池、超时时间等  
    9. RpcChannel  
       数据传输通道  
</code></pre><p>三、Java中常用的RPC框架</p>
<pre><code>目前常用的RPC框架如下：

1. Thrift：thrift是一个软件框架，用来进行可扩展且跨语言的服务的开发。它结合了功能强大的软件堆栈和代码生成引擎，以构建在 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml 这些编程语言间无缝结合的、高效的服务。

2. Dubbo：Dubbo是一个分布式服务框架，以及SOA治理方案。其功能主要包括：高性能NIO通讯及多协议集成，服务动态寻址与路由，软负载均衡与容错，依赖分析与降级等。 Dubbo是阿里巴巴内部的SOA服务化治理方案的核心框架，Dubbo自2011年开源后，已被许多非阿里系公司使用。 

3. Spring Cloud：Spring Cloud由众多子项目组成，如Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Consul 等，提供了搭建分布式系统及微服务常用的工具，如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性token、全局锁、选主、分布式会话和集群状态等，满足了构建微服务所需的所有解决方案。Spring Cloud基于Spring Boot, 使得开发部署极其简单。
</code></pre><p>四、RPC和消息队列的差异</p>
<pre><code>1. 功能差异

    在架构上，RPC和Message的差异点是，Message有一个中间结点Message Queue，可以把消息存储。
    消息的特点
    1. Message Queue把请求的压力保存一下，逐渐释放出来，让处理者按照自己的节奏来处理。
    2. Message Queue引入一下新的结点，系统的可靠性会受Message Queue结点的影响。
    3. Message Queue是异步单向的消息。发送消息设计成是不需要等待消息处理的完成。
    所以对于有同步返回需求，用Message Queue则变得麻烦了。
RPC的特点
    同步调用，对于要等待返回结果/处理结果的场景，RPC是可以非常自然直觉的使用方式(RPC也可以是异步调用)。
    由于等待结果，Consumer（Client）会有线程消耗。如果以异步RPC的方式使用，Consumer（Client）线程消耗可以去掉。但不能做到像消息一样暂存消息/请求，压力会直接传导到服务Provider。
    2. 适用场合差异
        1. 希望同步得到结果的场合，RPC合适。
        2. 希望使用简单，则RPC；RPC操作基于接口，使用简单，使用方式模拟本地调用。异步的方式编程比较复杂。
        3. 不希望发送端（RPC Consumer、Message Sender）受限于处理端（RPC Provider、Message Receiver）的速度时，使用Message Queue。
        随着业务增长，有的处理端处理量会成为瓶颈，会进行同步调用到异步消息的改造。这样的改造实际上有调整业务的使用方式。比如原来一个操作页面提交后就下一个页面会看到处理结果；改造后异步消息后，下一个页面就会变成“操作已提交，完成后会得到通知”。
    3. 不适用场合说明
        1. RPC同步调用使用Message Queue来传输调用信息。 上面分析可以知道，这样的做法，发送端是在等待，同时占用一个中间点的资源。变得复杂了，但没有对等的收益。
        2. 对于返回值是void的调用，可以这样做，因为实际上这个调用业务上往往不需要同步得到处理结果的，只要保证会处理即可。（RPC的方式可以保证调用返回即处理完成，使用消息方式后这一点不能保证了。）
        3. 返回值是void的调用，使用消息，效果上是把消息的使用方式Wrap成了服务调用（服务调用使用方式成简单，基于业务接口）。
</code></pre><p>五、RPC框架的核心技术点</p>
<pre><code>RPC框架实现的几个核心技术点：

（1）服务暴露：

    远程提供者需要以某种形式提供服务调用相关的信息，包括但不限于服务接口定义、数据结构、或者中间态的服务定义文件。例如Facebook的Thrift的IDL文件，Web service的WSDL文件；服务的调用者需要通过一定的途径获取远程服务调用相关的信息。

    目前，大部分跨语言平台 RPC 框架采用根据 IDL 定义通过 code generator 去生成 stub 代码，这种方式下实际导入的过程就是通过代码生成器在编译期完成的。代码生成的方式对跨语言平台 RPC 框架而言是必然的选择，而对于同一语言平台的 RPC 则可以通过共享接口定义来实现。这里的导入方式本质也是一种代码生成技术，只不过是在运行时生成，比静态编译期的代码生成看起来更简洁些。

    java 中还有一种比较特殊的调用就是多态，也就是一个接口可能有多个实现，那么远程调用时到底调用哪个？这个本地调用的语义是通过 jvm 提供的引用多态性隐式实现的，那么对于 RPC 来说跨进程的调用就没法隐式实现了。如果前面DemoService 接口有 2 个实现，那么在导出接口时就需要特殊标记不同的实现需要，那么远程调用时也需要传递该标记才能调用到正确的实现类，这样就解决了多态调用的语义问题。

（2）远程代理对象：

    服务调用者用的服务实际是远程服务的本地代理。说白了就是通过动态代理来实现。

    java 里至少提供了两种技术来提供动态代码生成，一种是 jdk 动态代理，另外一种是字节码生成。动态代理相比字节码生成使用起来更方便，但动态代理方式在性能上是要逊色于直接的字节码生成的，而字节码生成在代码可读性上要差很多。两者权衡起来，个人认为牺牲一些性能来获得代码可读性和可维护性显得更重要。

（3）通信：

    RPC框架与具体的协议无关。RPC 可基于 HTTP 或 TCP 协议，Web Service 就是基于 HTTP 协议的 RPC，它具有良好的跨平台性，但其性能却不如基于 TCP 协议的 RPC。

    1. TCP/HTTP：众所周知，TCP 是传输层协议，HTTP 是应用层协议，而传输层较应用层更加底层，在数据传输方面，越底层越快，因此，在一般情况下，TCP 一定比 HTTP 快。

    2. 消息ID：RPC 的应用场景实质是一种可靠的请求应答消息流，和 HTTP 类似。因此选择长连接方式的 TCP 协议会更高效，与 HTTP 不同的是在协议层面我们定义了每个消息的唯一 id，因此可以更容易的复用连接。

    3. IO方式：为了支持高并发，传统的阻塞式 IO 显然不太合适，因此我们需要异步的 IO，即 NIO。Java 提供了 NIO 的解决方案，Java 7 也提供了更优秀的 NIO.2 支持。

    4. 多连接：既然使用长连接，那么第一个问题是到底 client 和 server 之间需要多少根连接？实际上单连接和多连接在使用上没有区别，对于数据传输量较小的应用类型，单连接基本足够。单连接和多连接最大的区别在于，每根连接都有自己私有的发送和接收缓冲区，因此大数据量传输时分散在不同的连接缓冲区会得到更好的吞吐效率。所以，如果你的数据传输量不足以让单连接的缓冲区一直处于饱和状态的话，那么使用多连接并不会产生任何明显的提升，反而会增加连接管理的开销。
    5. 心跳：连接是由 client 端发起建立并维持。如果 client 和 server 之间是直连的，那么连接一般不会中断（当然物理链路故障除外）。如果 client 和 server 连接经过一些负载中转设备，有可能连接一段时间不活跃时会被这些中间设备中断。为了保持连接有必要定时为每个连接发送心跳数据以维持连接不中断。心跳消息是 RPC 框架库使用的内部消息，在前文协议头结构中也有一个专门的心跳位，就是用来标记心跳消息的，它对业务应用透明。

（4）序列化：

    两方面会直接影响 RPC 的性能，一是传输方式，二是序列化。

    1. 序列化方式：毕竟是远程通信，需要将对象转化成二进制流进行传输。不同的RPC框架应用的场景不同，在序列化上也会采取不同的技术。 就序列化而言，Java 提供了默认的序列化方式，但在高并发的情况下，这种方式将会带来一些性能上的瓶颈，于是市面上出现了一系列优秀的序列化框架，比如：Protobuf、Kryo、Hessian、Jackson 等，它们可以取代 Java 默认的序列化，从而提供更高效的性能。

    2. 编码内容：出于效率考虑，编码的信息越少越好（传输数据少），编码的规则越简单越好（执行效率高）。如下是编码需要具备的信息：

    -- 调用编码 --  
    1. 接口方法  
       包括接口名、方法名  
    2. 方法参数  
       包括参数类型、参数值  
    3. 调用属性  
       包括调用属性信息，例如调用附件隐式参数、调用超时时间等  

    -- 返回编码 --  
    1. 返回结果  
       接口方法中定义的返回值  
    2. 返回码  
       异常返回码  
    3. 返回异常信息  
       调用异常信息 

    除了以上这些必须的调用信息，我们可能还需要一些元信息以方便程序编解码以及未来可能的扩展。这样我们的编码消息里面就分成了两部分，一部分是元信息、另一部分是调用的必要信息。如果设计一种 RPC 协议消息的话，元信息我们把它放在协议消息头中，而必要信息放在协议消息体中。下面给出一种概念上的 RPC 协议消息设计格式：

    -- 消息头 --  
    magic      : 协议魔数，为解码设计  
    header size: 协议头长度，为扩展设计  
    version    : 协议版本，为兼容设计  
    st         : 消息体序列化类型  
    hb         : 心跳消息标记，为长连接传输层心跳设计  
    ow         : 单向消息标记，  
    rp         : 响应消息标记，不置位默认是请求消息  
    status code: 响应消息状态码  
    reserved   : 为字节对齐保留  
    message id : 消息 id  
    body size  : 消息体长度  

    -- 消息体 --  
    采用序列化编码，常见有以下格式  
    xml   : 如 webservie soap  
    json  : 如 JSON-RPC  
    binary: 如 thrift; hession; kryo 等  
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/01/01/RPC入门总结  RPC定义和原理/">
    <time datetime="2018-12-31T16:00:00.000Z" class="entry-date">
        2019-01-01
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/随记/">随记</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-String反转" class="post-String反转 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/02/06/String反转/">String 的反转</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2018/02/06/String反转/" data-id="cjzam8fz50005gouhcz61xs2d" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <pre><code>package com.example.demo;

import java.util.Stack;

/**
 * String 的反转
 */
public class Reverse {
    private String str = null;

    public Reverse(String str) {
        this.str = str;
    }

    // 数组实现String反转
    public String reverseByArray() {
        if (str == null || str.length() == 1) {
            return str;
        }
        char[] ch = str.toCharArray();// 字符串转换成字符数组
        for (int i = 0; i &lt; ch.length / 2; i++) {
            char temp = ch[i];
            ch[i] = ch[ch.length - i - 1];
            ch[ch.length - i - 1] = temp;
        }
        return new String(ch);
    }

    // 用栈实现String反转
    public String reverseByStack() {
        if (str == null || str.length() == 1) {
            return str;
        }
        Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();
        char[] ch = str.toCharArray();// 字符串转换成字符数组
        for (char c : ch) {
            stack.push(c);// 每个字符，推进栈
        }
        for (int i = 0; i &lt; ch.length; i++) {
            ch[i] = stack.pop();// 移除这个堆栈的顶部对象
        }
        return new String(ch);
    }

    // 用逆序遍历实现String反转
    public String reverseBySort() {
        if (str == null || str.length() == 1) {
            return str;
        }
        StringBuffer sb = new StringBuffer();
        for (int i = str.length() - 1; i &gt;= 0; i--) {
            sb.append(str.charAt(i));// 使用StringBuffer从右往左拼接字符
        }
        return sb.toString();
    }

    // 使用位运算实现String反转
    public String reverseByBit() {
        if (str == null || str.length() == 1) {
            return str;
        }
        char[] ch = str.toCharArray();// 字符串转换成字符数组
        int len = str.length();
        for (int i = 0; i &lt; len / 2; i++) {
            ch[i] ^= ch[len - 1 - i];
            ch[len - 1 - i] ^= ch[i];
            ch[i] ^= ch[len - 1 - i];
        }
        return new String(ch);
    }

    //使用递归实现String反转
    public String reverseByRecursive(String str) {
        if (str == null || str.length() == 0) {
            return str;
        }
        if (str.length() == 1) {
            return str;
        } else {
            // 从下标为1开始截取字符串，在返回下标为0的字符
            return reverseByRecursive(str.substring(1)) + str.charAt(0);
        }
    }

    // 使用 StringBuilder reverse() 方法反转
    public String reverseByStringBuilder(String str) {
        if (str == null || str.length() == 0) {
            return str;
        }
        StringBuilder sb = new StringBuilder(str);
        return sb.reverse().toString();
    }

    public static void main(String[] args) {
        String s = &quot;123456&quot;;

        Reverse r = new Reverse(s);
        System.out.println(r.reverseByArray());
        System.out.println(r.reverseByStack());
        System.out.println(r.reverseBySort());
        System.out.println(r.reverseByBit());
        System.out.println(r.reverseByRecursive(s));
        System.out.println(r.reverseByStringBuilder(s));
    }
}
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/02/06/String反转/">
    <time datetime="2018-02-05T16:00:00.000Z" class="entry-date">
        2018-02-06
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-maven-instruction" class="post-maven-instruction post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/01/29/maven-instruction/">maven使用简单介绍</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2018/01/29/maven-instruction/" data-id="cjzam8fzi000lgouhd9i6oo42" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>官网：<a href="http://maven.apache.org/" target="_blank" rel="noopener">http://maven.apache.org/</a></p>
<p>详细教程：<a href="https://www.w3cschool.cn/maven/" target="_blank" rel="noopener">https://www.w3cschool.cn/maven/</a></p>
<h3 id="简单使用maven做什么-？"><a href="#简单使用maven做什么-？" class="headerlink" title="简单使用maven做什么 ？"></a>简单使用maven做什么 <strong>？</strong></h3><ul>
<li>提供了项目对象模型（POM）文件来管理项目的构建。</li>
<li><p>仓库的搜索顺序为：本地仓库、中央仓库、远程仓库。</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本地仓库用来存储项目的依赖库；</span><br><span class="line">中央仓库是下载依赖库的默认位置；</span><br><span class="line">远程仓库，因为并非所有的库存储在中央仓库，或者中央仓库访问速度很慢，远程仓库是中央仓库的补充。</span><br></pre></td></tr></table></figure>
</code></pre></li>
<li><p>构建不依赖于IDE的标准化项目（导入IDE只需要以maven项目导入即可）</p>
</li>
<li>目录结构统一并且简单，约定大于配置，被其他构建工具以及项目广泛采用</li>
<li>统一对项目依赖的jar包进行管理，明确jar包依赖以及对应的版本自动下载等（<a href="https://www.w3cschool.cn/maven/" target="_blank" rel="noopener">细节请看详细教程</a>）</li>
</ul>
<h3 id="maven的下载安装"><a href="#maven的下载安装" class="headerlink" title="maven的下载安装"></a>maven的下载安装</h3><h4 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. <strong>下载</strong></h4><p>进入<a href="http://maven.apache.org/" target="_blank" rel="noopener">官网</a>选择download菜单进入下载页面<br><img src="/assets/mavenImg/download.png" alt="image"><br>tar.gz文件对应linux系统<br>zip文件对应windows系统</p>
<h4 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. <strong>安装</strong></h4><pre><code>解压即可使用  
对于在windows下使用maven，如果需要使用cmd执行命令的话，需要在path环境变量中添加maven/bin目录即可，使用IDE并不需要配置环境变量等  
推荐目录结构如下：
</code></pre><p><img src="/assets/mavenImg/maven-directory.png" alt="image"></p>
<pre><code>第一个为解压后的文件目录  
第二个用来作为maven的全局文件（settings.xml）存放目录（IDE中需要在maven配置中指向此文件才会生效，日后更换maven版本只需要更换原来的maven解压路径即可，不必再做配置）  
第三个用来作为maven下载jar包的本地仓库存放目录（需要在settings.xml配置文件中指定，不然存放到默认路径C盘中，不方便管理与查找）  
</code></pre><h4 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. <strong>配置</strong></h4><p>在解压的文件目录下进入conf文件夹，其中有默认的settings.xml配置文件<br><img src="/assets/mavenImg/maven-conf-directory.png" alt="image"><br>配置文件一般只需要配置2个地方，一个是下载jar包的本地仓库存放目录，另外一个为下载jar包的国内镜像地址（默认地址为国外，速度较慢）<br><img src="/assets/mavenImg/maven-conf-repository.png" alt="image"><br>从默认的注释中复制出来，配置上前面定好的本地仓库存放目录，如果不配置则会存放到注释中默认指向地址${user.home}/.m2/repository<br><img src="/assets/mavenImg/maven-conf-mirror.png" alt="image"><br>依旧从默认的注释中复制镜像出来，id与name可以随意起名，mirrorOf为central则说明是中央仓库，URL推荐填写阿里云maven仓库地址 <a href="http://maven.aliyun.com/nexus/content/groups/public" target="_blank" rel="noopener">http://maven.aliyun.com/nexus/content/groups/public</a><br>之后保存，复制出一份存放在前面设置的maven全局文件存放目录下面（当替换maven版本时，内置的配置文件使用IDE设置好全局文件时可不用更改，更换maven版本也只是解压新版本后在IDE中设置新的maven安装路径就完成了）  </p>
<h3 id="IDE中配置maven"><a href="#IDE中配置maven" class="headerlink" title="IDE中配置maven"></a>IDE中配置maven</h3><ol>
<li><p><strong>MyEclipse</strong><br>点击导航栏window进入preferences搜索maven<br><img src="/assets/mavenImg/myeclipse-maven.png" alt="image"><br>建议勾选Download Artifact Sources（下载jar包的同时下载源码，方便直接点方法进源码查看）<br><img src="/assets/mavenImg/myeclipse-maven-install.png" alt="image"><br>添加安装的maven<br><img src="/assets/mavenImg/myeclipse-maven-settings.png" alt="image"><br>设置好maven的全局配置文件路径（本地仓库存放目录自动扫描文件中的目录）<br>至此完成了MyEclipse中maven的配置  </p>
</li>
<li><p><strong>IDEA</strong><br>不要在打开项目的时候选择file/settings，那样设置完只会针对当前项目，若打开了项目，则选择file/Close Project关闭项目回退到初始idea界面</p>
</li>
</ol>
<p><img src="/assets/mavenImg/idea-settings.png" alt="image"><br><img src="/assets/mavenImg/idea-settings1.png" alt="image"><br>指定好maven的安装目录以及配置文件位置<br><img src="/assets/mavenImg/idea-maven.png" alt="image"><br><img src="/assets/mavenImg/idea-maven-importing.png" alt="image"><br>至此完成了idea中的maven的配置</p>
<h3 id="创建一个maven的java-web项目"><a href="#创建一个maven的java-web项目" class="headerlink" title="创建一个maven的java web项目"></a>创建一个maven的java web项目</h3><ol>
<li><p><strong>MyEclipse</strong><br><img src="/assets/mavenImg/myeclipse-create01.png" alt="image"><br><img src="/assets/mavenImg/myeclipse-create02.png" alt="image"><br>选取项目模板java web项目为maven-archetype-webapp<br><img src="/assets/mavenImg/myeclipse-create03.png" alt="image"><br><img src="/assets/mavenImg/myeclipse-create04.png" alt="image"><br>finish完成创建，第一次创建时需要下载一些jar包，会慢一点，至此就创建完毕了  </p>
</li>
<li><p><strong>IDEA</strong><br>新建项目<br><img src="/assets/mavenImg/idea-create01.png" alt="image"><br><img src="/assets/mavenImg/idea-create02.png" alt="image"><br><img src="/assets/mavenImg/idea-create03.png" alt="image"><br><img src="/assets/mavenImg/idea-create04.png" alt="image"><br>finish完成创建，第一次创建时需要下载一些jar包，会慢一点，至此就创建完毕了  </p>
</li>
</ol>
<h3 id="maven的java-web项目的目录结构"><a href="#maven的java-web项目的目录结构" class="headerlink" title="maven的java web项目的目录结构"></a>maven的java web项目的目录结构</h3><p><a href="/assets/mavenImg/pom.xml">pom.xml项目配置文件例子，包含普通项目所需jar包引入，行间内置注释</a><br><img src="/assets/mavenImg/maven-directory-javaweb.png" alt="文件目录结构">  </p>
<pre><code>```
project
│   pom.xml（maven项目配置文件）
│
└───src（源码根目录）
│   │
│   └───main（源码主目录）
│   │   │
│   │   └───java（java源码目录）
│   │   │   │
│   │   │   └───xxx（项目包名）
│   │   │   └───sql（包名，有清空数据库在java源码目录下同级放置）
│   │   │
│   │   └───resources（源码所使用的资源文件目录，存放配置文件）
│   │   │   │
│   │   │   └───config（配置文件）
│   │   │        │
│   │   │        └───jdbc
│   │   │        └───mybatis
│   │   │        └───spring
│   │   │
│   │   └───webapp（web文件目录，等同于WebRoot）
│   │   │
│   │
│   └───test（测试目录，测试用例等，小项目暂未使用）
│        │   xxxTest.java
│        │   ...
│    
└───target（maven项目默认编译输出目录，自动生成）
          │   ...
```  
</code></pre><ol>
<li>java源码目录使用模板生成没有此文件夹，自行创建并设置为源码目录，MyEclipse设置方式为文件夹右键Build Path/Use as Source Folder，idea为右键Make Directory as/Sources Root</li>
<li>resources资源文件目录在导入maven项目时此文件夹为普通文件夹，需要IDE设置为资源文件夹，MyEclipse设置方式同上，idea为右键Make Directory as/Resources Root</li>
<li>如果需要引入特殊jar包（第三方支付等），跟以前方式一致</li>
<li>旧项目转化为maven项目，按照上述创建一个maven项目，直接打开2边的文件夹，直接拷贝到相应地方，删除多余jar包以及原来多余编译生成的文件即可，无需其余操作，反之把maven项目转化也一样（需要把编译目录下的jar包拷过去）</li>
</ol>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/01/29/maven-instruction/">
    <time datetime="2018-01-28T16:00:00.000Z" class="entry-date">
        2018-01-29
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Maven/">Maven</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-刷新 DNS 解析缓存" class="post-刷新 DNS 解析缓存 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/01/01/刷新 DNS 解析缓存/">刷新 DNS 解析缓存</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2018/01/01/刷新 DNS 解析缓存/" data-id="cjzam8fzx001fgouhvlgwqj83" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>刷新 DNS 解析缓存</p>
<pre><code># cmd 执行 
ipconfig /flushdns
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/01/01/刷新 DNS 解析缓存/">
    <time datetime="2017-12-31T16:00:00.000Z" class="entry-date">
        2018-01-01
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/随记/">随记</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-javamelody" class="post-javamelody post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/01/01/javamelody/">javamelody java系统监控插件</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2018/01/01/javamelody/" data-id="cjzam8fzd000ggouhz2te7vqj" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><pre><code>&lt;!-- java系统监控插件 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;net.bull.javamelody&lt;/groupId&gt;
        &lt;artifactId&gt;javamelody-core&lt;/artifactId&gt;
        &lt;version&gt;1.60.0&lt;/version&gt;
    &lt;/dependency&gt;

# Configuration.java

import net.bull.javamelody.MonitoringFilter;
import net.bull.javamelody.SessionListener;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.boot.web.servlet.ServletListenerRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 *
 * @author zqs
 * @since
 */
@Configuration
public class JavamelodyConfiguration {
    @Bean
    public FilterRegistrationBean monitorFilter(){
        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new MonitoringFilter());
        filterRegistrationBean.addUrlPatterns(&quot;/*&quot;);
        return filterRegistrationBean;
    }

    @Bean
    public ServletListenerRegistrationBean sessionListener(){
        ServletListenerRegistrationBean servletListenerRegistrationBean = new ServletListenerRegistrationBean();
        servletListenerRegistrationBean.setListener(new SessionListener());
        return servletListenerRegistrationBean;
    }
}   
</code></pre><h2 id="普通javaweb项目"><a href="#普通javaweb项目" class="headerlink" title="普通javaweb项目"></a>普通javaweb项目</h2><pre><code>导入jar包：
javamelody.jar
jrobin-1.5.14.jar
启动项目的时候监控系统自动启动，无需配置（jdk1.7,tomcat 7 环境下）；

访问：http://主机地址：端口号/项目名/monitoring
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/01/01/javamelody/">
    <time datetime="2017-12-31T16:00:00.000Z" class="entry-date">
        2018-01-01
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-curl" class="post-curl post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/01/01/curl/">curl(选项)(参数)</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2018/01/01/curl/" data-id="cjzam8g0m002egouh48u06nik" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <pre><code>举个栗子

curl -l -H &quot;Content-type: application/json&quot; -X POST -d &apos;{&quot;serviceType&quot;:&quot;3&quot;}&apos; http://10.43.22.175:8661/scf/main/api/getSubMenu
curl -l -H &quot;Content-type: application/json&quot; -X POST -d &apos;serviceType=3&apos; http://10.43.22.175:8661/scf/main/api/getSubMenu
</code></pre><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>curl(选项)(参数)
</code></pre><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><pre><code>-a/--append  上传文件时，附加到目标文件
-A/--user-agent &lt;string&gt;  设置用户代理发送给服务器
-anyauth  可以使用“任何”身份验证方法
-b/--cookie &lt;name=string/file&gt;  cookie字符串或文件读取位置
   --basic  使用HTTP基本验证
-B/--use-ascii  使用ASCII /文本传输
-c/--cookie-jar &lt;file&gt;  操作结束后把cookie写入到这个文件中
-C/--continue-at &lt;offset&gt;  断点续转
-d/--data &lt;data&gt;  HTTP POST方式传送数据
   --data-ascii &lt;data&gt;  以ascii的方式post数据
   --data-binary &lt;data&gt;  以二进制的方式post数据
   --negotiate  使用HTTP身份验证
   --digest  使用数字身份验证
   --disable-eprt  禁止使用EPRT或LPRT
   --disable-epsv  禁止使用EPSV
-D/--dump-header &lt;file&gt;  把header信息写入到该文件中
   --egd-file &lt;file&gt;  为随机数据(SSL)设置EGD socket路径
   --tcp-nodelay  使用TCP_NODELAY选项
-e/--referer  来源网址
-E/--cert &lt;cert[:passwd]&gt;  客户端证书文件和密码 (SSL)
   --cert-type &lt;type&gt;  证书文件类型 (DER/PEM/ENG) (SSL)
   --key &lt;key&gt;  私钥文件名 (SSL)
   --key-type &lt;type&gt;  私钥文件类型 (DER/PEM/ENG) (SSL)
   --pass &lt;pass&gt;  私钥密码 (SSL)
   --engine &lt;eng&gt;  加密引擎使用 (SSL). &quot;--engine list&quot; for list
   --cacert &lt;file&gt;  CA证书 (SSL)
   --capath &lt;directory&gt;  CA目录 (made using c_rehash) to verify peer against (SSL)
   --ciphers &lt;list&gt;  SSL密码
   --compressed  要求返回是压缩的形势 (using deflate or gzip)
   --connect-timeout &lt;seconds&gt;  设置最大请求时间
   --create-dirs  建立本地目录的目录层次结构
   --crlf  上传是把LF转变成CRLF
-f/--fail  连接失败时不显示http错误
   --ftp-create-dirs  如果远程目录不存在，创建远程目录
   --ftp-method [multicwd/nocwd/singlecwd]  控制CWD的使用
   --ftp-pasv  使用 PASV/EPSV 代替端口
   --ftp-skip-pasv-ip  使用PASV的时候,忽略该IP地址
   --ftp-ssl  尝试用 SSL/TLS 来进行ftp数据传输
   --ftp-ssl-reqd  要求用 SSL/TLS 来进行ftp数据传输
-F/--form &lt;name=content&gt;  模拟http表单提交数据
   --form-string &lt;name=string&gt;  模拟http表单提交数据
-g/--globoff  禁用网址序列和范围使用{}和[]
-G/--get  以get的方式来发送数据
-H/--header &lt;line&gt;  自定义头信息传递给服务器
   --ignore-content-length  忽略的HTTP头信息的长度
-i/--include  输出时包括protocol头信息
-I/--head  只显示请求头信息
-j/--junk-session-cookies  读取文件进忽略session cookie
   --interface &lt;interface&gt;  使用指定网络接口/地址
   --krb4 &lt;level&gt;  使用指定安全级别的krb4
-k/--insecure  允许不使用证书到SSL站点
-K/--config  指定的配置文件读取
-l/--list-only  列出ftp目录下的文件名称
   --limit-rate &lt;rate&gt;  设置传输速度
   --local-port&lt;NUM&gt;  强制使用本地端口号
-m/--max-time &lt;seconds&gt;  设置最大传输时间
   --max-redirs &lt;num&gt;  设置最大读取的目录数
   --max-filesize &lt;bytes&gt;  设置最大下载的文件总量
-M/--manual  显示全手动
-n/--netrc  从netrc文件中读取用户名和密码
   --netrc-optional  使用 .netrc 或者 URL来覆盖-n
   --ntlm  使用 HTTP NTLM 身份验证
-N/--no-buffer  禁用缓冲输出
-o/--output  把输出写到该文件中
-O/--remote-name  把输出写到该文件中，保留远程文件的文件名
-p/--proxytunnel  使用HTTP代理
   --proxy-anyauth  选择任一代理身份验证方法
   --proxy-basic  在代理上使用基本身份验证
   --proxy-digest  在代理上使用数字身份验证
   --proxy-ntlm  在代理上使用ntlm身份验证
-P/--ftp-port &lt;address&gt;  使用端口地址，而不是使用PASV
-q  作为第一个参数，关闭 .curlrc
-Q/--quote &lt;cmd&gt;  文件传输前，发送命令到服务器
-r/--range &lt;range&gt;  检索来自HTTP/1.1或FTP服务器字节范围
--range-file  读取（SSL）的随机文件
-R/--remote-time  在本地生成文件时，保留远程文件时间
   --retry &lt;num&gt;  传输出现问题时，重试的次数
   --retry-delay &lt;seconds&gt;  传输出现问题时，设置重试间隔时间
   --retry-max-time &lt;seconds&gt;  传输出现问题时，设置最大重试时间
-s/--silent  静默模式。不输出任何东西
-S/--show-error  显示错误
   --socks4 &lt;host[:port]&gt;  用socks4代理给定主机和端口
   --socks5 &lt;host[:port]&gt;  用socks5代理给定主机和端口
   --stderr &lt;file&gt;   
-t/--telnet-option &lt;OPT=val&gt;  Telnet选项设置
   --trace &lt;file&gt;  对指定文件进行debug
   --trace-ascii &lt;file&gt;  Like --跟踪但没有hex输出
   --trace-time  跟踪/详细输出时，添加时间戳
-T/--upload-file &lt;file&gt;  上传文件
   --url &lt;URL&gt;  Spet URL to work with
-u/--user &lt;user[:password]&gt;  设置服务器的用户和密码
-U/--proxy-user &lt;user[:password]&gt;  设置代理用户名和密码
-w/--write-out [format]  什么输出完成后
-x/--proxy &lt;host[:port]&gt;  在给定的端口上使用HTTP代理
-X/--request &lt;command&gt;  指定什么命令
-y/--speed-time  放弃限速所要的时间，默认为30
-Y/--speed-limit  停止传输速度的限制，速度时间
</code></pre><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><pre><code>文件下载

  curl命令可以用来执行下载、发送各种HTTP请求，指定HTTP头部等操作。如果系统没有curl可以使用yum install curl安装，也可以下载安装。curl是将下载文件输出到stdout，将进度信息输出到stderr，不显示进度信息使用--silent选项。

  curl URL --silent

  这条命令是将下载文件输出到终端，所有下载的数据都被写入到stdout。

  使用选项-O将下载的数据写入到文件，必须使用文件的绝对地址：

  curl http://man.linuxde.net/text.iso --silent -O

  选项-o将下载数据写入到指定名称的文件中，并使用--progress显示进度条：

  curl http://man.linuxde.net/test.iso -o filename.iso --progress
  ######################################### 100.0%

 断点续传

  curl能够从特定的文件偏移处继续下载，它可以通过指定一个便宜量来下载部分文件：

  curl URL/File -C 偏移量

  #偏移量是以字节为单位的整数，如果让curl自动推断出正确的续传位置使用-C -：
  curl -C -URL

使用curl设置参照页字符串

  参照页是位于HTTP头部中的一个字符串，用来表示用户是从哪个页面到达当前页面的，如果用户点击网页A中的某个连接，那么用户就会跳转到B网页，网页B头部的参照页字符串就包含网页A的URL。

  使用--referer选项指定参照页字符串：

  curl --referer http://www.google.com http://man.linuxde.net

用curl设置cookies

  使用--cookie &quot;COKKIES&quot;选项来指定cookie，多个cookie使用分号分隔：

  curl http://man.linuxde.net --cookie &quot;user=root;pass=123456&quot;

  将cookie另存为一个文件，使用--cookie-jar选项：

  curl URL --cookie-jar cookie_file

用curl设置用户代理字符串

  有些网站访问会提示只能使用IE浏览器来访问，这是因为这些网站设置了检查用户代理，可以使用curl把用户代理设置为IE，这样就可以访问了。使用--user-agent或者-A选项：

  curl URL --user-agent &quot;Mozilla/5.0&quot;
  curl URL -A &quot;Mozilla/5.0&quot;

  其他HTTP头部信息也可以使用curl来发送，使用-H&quot;头部信息&quot; 传递多个头部信息，例如：

  curl -H &quot;Host:man.linuxde.net&quot; -H &quot;accept-language:zh-cn&quot; URL

 curl的带宽控制和下载配额

  使用--limit-rate限制curl的下载速度：

  curl URL --limit-rate 50k

  命令中用k（千字节）和m（兆字节）指定下载速度限制。

  使用--max-filesize指定可下载的最大文件大小：

  curl URL --max-filesize bytes

  如果文件大小超出限制，命令则返回一个非0退出码，如果命令正常则返回0。

用curl进行认证

  使用curl选项 -u 可以完成HTTP或者FTP的认证，可以指定密码，也可以不指定密码在后续操作中输入密码：

  curl -u user:pwd http://man.linuxde.net
  curl -u user http://man.linuxde.net

只打印响应头部信息

    通过-I或者-head可以只打印出HTTP头部信息：

    [root@localhost text]# curl -I http://man.linuxde.net
      HTTP/1.1 200 OK
      Server: nginx/1.2.5
      date: Mon, 10 Dec 2012 09:24:34 GMT
      Content-Type: text/html; charset=UTF-8
      Connection: keep-alive
      Vary: Accept-Encoding
      X-Pingback: http://man.linuxde.net/xmlrpc.php
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/01/01/curl/">
    <time datetime="2017-12-31T16:00:00.000Z" class="entry-date">
        2018-01-01
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/随记/">随记</a>
  </div>

    
    </footer>
</article>






  
  
    <nav id="pagination">
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
      </nav>
    </nav>
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value name="s" id="s">
        <input type="submit" id="searchsubmit" value="搜索">
    </div>
</form></aside>
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-content">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/">JS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Markdown/">Markdown</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SVN/">SVN</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud-Spring-Boot-微服务/">Spring Cloud Spring Boot 微服务</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随记/">随记</a><span class="category-list-count">6</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2019/07/16/vscode vue 用户代码片段/">vscode vue 用户代码片段</a>
          </li>
        
          <li>
            <a href="/2019/06/03/netstat查看端口占用情况/">netstat 查看端口占用情况</a>
          </li>
        
          <li>
            <a href="/2019/06/03/使用 VS Code 断点调试/">vue 使用 VS Code 断点调试</a>
          </li>
        
          <li>
            <a href="/2019/06/03/vue async await/">vue 事件中的 (native)</a>
          </li>
        
          <li>
            <a href="/2019/06/03/vue 事件中的 .native/">vue 事件中的 (native)</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2019 花皮松
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>