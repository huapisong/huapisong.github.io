<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  

  
  
  
  
  
  
  <title>随记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="随记">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="随记">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="随记">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src="//push.zhanzhang.baidu.com/push.js"></script>
</head></html>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="随记" rel="home">随记</a>
      </h1>
      
        <h2 class="site-description hitokoto"></h2>
        <script type="text/javascript" src="https://v1.hitokoto.cn/?encode=js"></script>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-4.使用Lets Encrypt为站点快速部署SSL证书" class="post-4.使用Lets Encrypt为站点快速部署SSL证书 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/01/01/4.使用Lets Encrypt为站点快速部署SSL证书/">使用Lets Encrypt为站点快速部署SSL证书</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2017/01/01/4.使用Lets Encrypt为站点快速部署SSL证书/" data-id="cjwk8gcku00051k0yzighz9qg" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>4.1.使用背景</p>
<pre><code>时常搜索”免费ssl证书”，申请和验证步骤很麻烦，审核时间也不定，”Lets Encrypt“是一个倡导互联网上所有网站都该使用https的组织，提供免费的ssl证书服务。
</code></pre><p>4.2.下载安装脚本</p>
<pre><code>下载Github上贡献者做好的安装脚本，如下：
wget https://raw.githubusercontent.com/xdtianyu/scripts/master/lets-encrypt/letsencrypt.conf
wget https://raw.githubusercontent.com/xdtianyu/scripts/master/lets-encrypt/letsencrypt.sh

# 赋予执行权限
chmod +x letsencrypt.sh
</code></pre><p>4.3.配置相关信息</p>
<pre><code>使用vi letsencrypt.conf打开配置文件，将里面的 example.com 换成自己的域名，如下：
# only modify the values, key files will be generated automaticly.
ACCOUNT_KEY=&quot;letsencrypt-account.key&quot;
DOMAIN_KEY=&quot;tiger.com.key&quot;
DOMAIN_DIR=&quot;/usr/local/openresty/nginx/html&quot;
DOMAINS=&quot;DNS:test.tiger.com&quot;
#ECC=TRUE
#LIGHTTPD=TRUE
</code></pre><p>按以往免费申请ssl的经历，通常都需要验证域名的所属权，不是通过配置二级域名验证就是需要在网站根目录上传验证文件，经过试用 Lets Encrypt，发现它使用的是第二种方式。</p>
<p>所以在使用nginx做动态代理时，需要先注释掉，使用基本的静态文件方式配置nginx的虚拟主机以便 Lets Encrypt 去做验证，等ssl安装好之后在配置成动态代理即可。<br>所以上述配置文件中的 DOMAIN_DIR 很重要，否则会执行失败</p>
<p>4.4.执行证书生成</p>
<pre><code>./letsencrypt.sh ./letsencrypt.conf
</code></pre><p>没有什么错误就会生成如下的几个文件，其中tiger.chained.crt和tiger.com.key就是需要的文件。</p>
<pre><code>letsencrypt-account.key
tiger.crt
tiger.csr
tiger.chained.crt
tiger.com.key
</code></pre><p>4.5.配置证书安装</p>
<p>这里使用nginx进行证书安装的服务器</p>
<pre><code>server {
    listen       443;
    server_name  test.tiger.com;

    ssl on;
    ssl_certificate tiger.chained.crt;
    ssl_certificate_key tiger.com.key;
    ssl_session_timeout 5m;

    location / {
        root html;
        index  index.html index.htm;
    }
}
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/01/01/4.使用Lets Encrypt为站点快速部署SSL证书/">
    <time datetime="2016-12-31T16:00:00.000Z" class="entry-date">
        2017-01-01
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-3.服务器上的iptables防火墙应该如何配置才能更安全" class="post-3.服务器上的iptables防火墙应该如何配置才能更安全 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/01/01/3.服务器上的iptables防火墙应该如何配置才能更安全/">服务器上的iptables防火墙应该如何配置才能更安全</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2017/01/01/3.服务器上的iptables防火墙应该如何配置才能更安全/" data-id="cjwk8gckt00041k0yf4b7fmbq" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>3.1 背景</p>
<pre><code>新入网的服务器在不做任何配置的情况下将会出现很多安全问题。端口肆意暴露、来源请求不明，恶意的数据包源源不断的流入服务器中。
公有云或许会控制非常用端口的访问，只开通如22、80、8080或者8443这样的常用端口，尽管屏蔽了大多数端口，但有效的做好防火墙规则仍然很重要。
下面流程化说明防火墙配置步骤
</code></pre><p>3.2 封口</p>
<p>将输入、输出、转向的数据包丢弃，对服务器进行彻底隔离，在封闭的环境中配置规则。这里值得提醒的是此操作需要在本机执行，因为 telnet 或者 ssh 的连接会当即断开。</p>
<pre><code> # 丢弃输入数据流向 
iptables -P INPUT DROP
 # 丢弃输出数据流向 
iptables -P OUTPUT DROP
# 丢弃转向数据流向 
iptables -P FORWARD DROP
</code></pre><p>3.3 开放SSH服务</p>
<p>首先确保 ssh 远程连接开放，添加对 ssh 服务的出入站规则，正常端口为22（端口应该更换成非22）</p>
<pre><code># 允许任务来源接入服务器的22端口
iptables -A INPUT -p tcp --dport 22 -j ACCEPT
# 允许服务器通过22端口向任何来源发送数据包
iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT
做好以上的 ssh 服务规则后，任何来源等可以连接，若要求更高级的安全则可以添加准入IP，可以添加多条，其他服务同理。
# 允许来源IP为221.4.12.28的地址访问服务器的22端口，即ssh服务
iptables -I INPUT -s 221.4.12.28 -p tcp --dport 22 -j ACCEPT
</code></pre><p>3.4 启用Ping命令</p>
<p>当执行 ping 命令时，其实是向目标地址发送 icmp 的数据包并得到回显信息。在服务器内部 ping 外部地址时，属于 OUTPUT，由于服务器的输出已经被DROP掉，所以服务器目前 ping 不通任何外部 IP 地址，考虑到运维的需要，添加允许 ping 外部IP的规则。</p>
<pre><code># 允许服务器向外部发送icmp的数据包
iptables -A OUTPUT -p icmp --icmp-type echo-request -j ACCEPT
# 允许服务器接收来自外部服务器返回的icmp数据包
iptables -A INPUT -p icmp --icmp-type echo-reply -j ACCEPT
</code></pre><p>目前服务器可以 ping 外部IP地址了，但外部来源 ping 服务器是不通的。选择不开放来自外部的 ping 请求或许是一个好想法，这样可以迷惑扫描工具避免暴露主机的存活性(高级的扫描工具除外，如 nmap)。<br>下面是服务器接收和响应 ping 请求的出入站规则</p>
<pre><code># 允许任何来源向服务器发送icmp的数据包
iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT
# 允许服务器向任何来源回显icmp的数据包
iptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT
</code></pre><p>3.5 启用DNS服务<br>服务器 ping 外部IP地址正常了，但 ping 外部的域名时则会显示 unknown host 的错误，这是因为 DNS 服务的53端口没有配置出入站规则。<br>下面是 DNS 服务的规则:</p>
<pre><code>iptables -A INPUT -p udp -i eth0 --sport 53 -j ACCEPT
iptables -A OUTPUT -p udp -o eth0 --dport 53 -j ACCEPT
</code></pre><p>3.6 下载软件<br>现在服务器需要从外部下载某些软件，通常我们会使用 wget 或者 curl 这样的工具，执行时发现一直卡着不动。这是因为服务器访问外网的80端口出站和入站规则没有配置，需要添加，如下：</p>
<pre><code>iptables -A OUTPUT -p tcp --dport 80 -j ACCEPT
iptables -A INPUT -p tcp --sport 80 -j ACCEPT
</code></pre><p>备注：使用类似与nginx代理转发到内网主机上某个服务时，同样也需要添加如上规则。如转发到内网 192.168.1.22 上的 48443的服务，规则如下：<br>    iptables -A OUTPUT -p tcp –dport 48843 -j ACCEPT<br>    iptables -A INPUT -p tcp –sport 48843 -j ACCEPT<br>3.7 启用本地回路loopback<br>本地回路即 localhost，运维时通常会使用本地回路判断某些服务是否正常，这个必要有。</p>
<pre><code>iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT
</code></pre><p>当需要开放本地端口，如127.0.0.1或者localhost的端口时，可以使用以下命令使 通过127.0.0.1的访问全部通过<br>    iptables -A INPUT -i lo -j ACCEPT<br>3.8 应用端规则<br>应用端规则指的是如 nginx、apache 等应用，启动后，默认情况下外网是不能访问的。如需要开通 nginx 的 80 和 443 端口，其他应用类似。</p>
<pre><code>iptables -A INPUT -p tcp --dport 80 -j ACCEPT
iptables -A OUTPUT -p tcp --sport 80 -j ACCEPT
iptables -A INPUT -p tcp --dport 443 -j ACCEPT
iptables -A OUTPUT -p tcp --sport 443 -j ACCEPT
</code></pre><p>3.9 删除规则</p>
<pre><code>iptables -L -n --line-number
iptables -D INPUT 15
iptables -D OUTPUT 13
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/01/01/3.服务器上的iptables防火墙应该如何配置才能更安全/">
    <time datetime="2016-12-31T16:00:00.000Z" class="entry-date">
        2017-01-01
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-java中set接口的用法" class="post-java中set接口的用法 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2016/06/03/java中set接口的用法/">java中set接口的用法</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2016/06/03/java中set接口的用法/" data-id="cjwk8gclh000x1k0y4cmrov7r" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>java中的set接口有如下的特点：</p>
<pre><code>不允许出现重复元素；
集合中的元素位置无顺序；
有且只有一个值为null的元素。
</code></pre><p>因为java中的set接口模仿了数学上的set抽象，所以，对应的数学上set的特性为：</p>
<pre><code>互异性：一个集合中，任何两个元素都认为是不相同的，即每个元素只能出现一次。

无序性：一个集合中，每个元素的地位都是相同的，元素之间是无序的。集合上可以定义序关系，定义了序关系后，元素之间就可以按照序关系排序。但就集合本身的特性而言，元素之间没有必然的序。

空集的性质：空集是一切集合的子集



  Set不保存重复的元素。Set中最常被使用的是测试归属性，你可以很容易的询问某个对象是否在某个Set中。Set具有与Collection完全一样的接口，因此没有任何额外的功能。实际上Set就是Collection，只是行为不同。
</code></pre><p>实现了Set接口的主要有HashSet、TreeSet、LinkedHashSet这几个共同点就是每个相同的项只保存一份。他们也有不同点，区别如下：</p>
<h1 id="1-HashSet："><a href="#1-HashSet：" class="headerlink" title="1.HashSet："></a>1.HashSet：</h1><p>HashSet使用的是相当复杂的方式来存储元素的，使用HashSet能够最快的获取集合中的元素，效率非常高（以空间换时间）。会根据hashcode和equals来庞端是否是同一个对象，如果hashcode一样，并且equals返回true，则是同一个对象，不能重复存放。 </p>
<pre><code>package cn.set;

import java.util.HashSet;
import java.util.Set;

class Student{
    int id;
    public Student(int id) {
        this.id = id;
    }
    @Override
    public String toString() {
        return this.id+&quot;&quot;;
    }
    @Override
    public int hashCode() {
        return this.id;
    }
    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Student){
            Student  stu = (Student) obj;
            if (stu.id == this.id)
                return true;
        }
        return false;
    }
}
public class HashSetTest {
    public static void main(String[] args) {
        Set&lt;Student&gt; set = new HashSet&lt;Student&gt;();
        Student s1 = new Student(1);
        Student s2 = new Student(1);
        Student s3 = new Student(2);
        set.add(s1);
        set.add(s2);
        set.add(s3);
        for (Student s : set) {
            System.out.println(s);
        }
    }
}
</code></pre><p>正如上例所示，重写了hashCode()和equals()方法来区分同意对象后，就不能存放同以对象了。如果注释这两个方法，则所有Student对象视为不同对象，都可以存放。</p>
<h1 id="2-TreeSet"><a href="#2-TreeSet" class="headerlink" title="2.TreeSet"></a>2.TreeSet</h1><p>　　TreeSet也不能存放重复对象，但是TreeSet会自动排序，如果存放的对象不能排序则会报错，所以存放的对象必须指定排序规则。排序规则包括自然排序和客户排序。</p>
<p>　　①自然排序：TreeSet要添加哪个对象就在哪个对象类上面实现java.lang.Comparable接口，并且重写comparaTo()方法，返回0则表示是同一个对象，否则为不同对象。</p>
<p>　　②客户排序：建立一个第三方类并实现java.util.Comparator接口。并重写方法。定义集合形式为TreeSet ts = new TreeSet(new 第三方类());</p>
<p>下面一个例子用TreeSet存放自然排序的对象：</p>
<pre><code>package cn.set;

import java.util.Set;
import java.util.TreeSet;

class Student1 implements Comparable&lt;Student1&gt;{
    int id;
    public Student1(int id) {
        this.id = id;
    }
    @Override
    public String toString() {
        return this.id+&quot;&quot;;
    }
    @Override
    public int hashCode() {
        return this.id;
    }
    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Student1){
            Student1  stu = (Student1) obj;
            if (stu.id == this.id)
                return true;
        }
        return false;
    }
    public int compareTo(Student1 o) {
        return (this.id-o.id);
    }
}

public class TreeSetTest {
    public static void main(String[] args) {
        Set&lt;Student1&gt; set = new TreeSet&lt;Student1&gt;();
        Student1 s1 = new Student1(5);
        Student1 s2 = new Student1(1);
        Student1 s3 = new Student1(2);
        Student1 s4 = new Student1(4);
        Student1 s5 = new Student1(3);
        set.add(s1);
        set.add(s2);
        set.add(s3);
        set.add(s4);
        set.add(s5);
        for (Student1 s : set) {
            System.out.println(s);
        }
    }

}
</code></pre><p>输出结果为：<br>    1<br>    2<br>    3<br>    4<br>    5</p>
<p>下面一个例子用TreeSet存放客户排序的对象：</p>
<pre><code>package com.set;

import java.util.Set;
import java.util.TreeSet;

class Student1 implements Comparable&lt;Student1&gt;{
    int id;
    public Student1(int id) {
        this.id = id;
    }
    @Override
    public String toString() {
        return this.id+&quot;&quot;;
    }
    @Override
    public int hashCode() {
        return this.id;
    }
    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Student1){
            Student1  stu = (Student1) obj;
            if (stu.id == this.id)
                return true;
        }
        return false;
    }
    public int compareTo(Student1 o) {
        return (this.id-o.id);
    }
}

public class TreeSetTest {
    public static void main(String[] args) {
        Set&lt;Student1&gt; set = new TreeSet&lt;Student1&gt;();
        Student1 s1 = new Student1(5);
        Student1 s2 = new Student1(1);
        Student1 s3 = new Student1(2);
        Student1 s4 = new Student1(4);
        Student1 s5 = new Student1(3);
        set.add(s1);
        set.add(s2);
        set.add(s3);
        set.add(s4);
        set.add(s5);
        for (Student1 s : set) {
            System.out.println(s);
        }
    }

}
</code></pre><p>输出结果为：</p>
<pre><code>5
4
3
2
1
</code></pre><p>大家都知道List存放时按照插入顺序排序的，其实也可以用自然排序和客户排序对List集合排序，大家请看：</p>
<pre><code>package cn.set;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

class MySort1 implements java.util.Comparator&lt;Student3&gt;{
    public int compare(Student3 o1, Student3 o2) {
        return o2.id-o1.id;
    }
}
class Student3 implements Comparable&lt;Student3&gt;{
    int id;
    public Student3(int id) {
        this.id = id;
    }
    @Override
    public String toString() {
        return this.id+&quot;&quot;;
    }
    public int compareTo(Student3 o) {
        return (this.id-o.id);
    }
}

public class ListSort {
    public static void main(String[] args) {
        List&lt;Student3&gt; list = new ArrayList&lt;Student3&gt;();
        Student3 s1 = new Student3(5);
        Student3 s2 = new Student3(1);
        Student3 s3 = new Student3(2);
        Student3 s4 = new Student3(4);
        Student3 s5 = new Student3(3);
        list.add(s1);
        list.add(s2);
        list.add(s3);
        list.add(s4);
        list.add(s5);
        System.out.println(list);
        //自然排序：
        Collections.sort(list);
        System.out.println(list);
        //客户排序
        Collections.sort(list, new MySort1());
        System.out.println(list);
    }
}
</code></pre><p>输出结果为：</p>
<pre><code>[5, 1, 2, 4, 3]
[1, 2, 3, 4, 5]
[5, 4, 3, 2, 1]
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2016/06/03/java中set接口的用法/">
    <time datetime="2016-06-02T16:00:00.000Z" class="entry-date">
        2016-06-03
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-http协议介绍" class="post-http协议介绍 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2014/01/01/http协议介绍/">http协议介绍</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2014/01/01/http协议介绍/" data-id="cjwk8gcl0000b1k0ywizb5t4e" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。</p>
<p>HTTP协议的主要特点</p>
<pre><code>1.支持客户/服务器模式
2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。 请求方法常用的有GET、HEAD、POST。 每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单， 使得HTTP服务器的程序规模小，因而通信速度很快。
3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
4.无连接： 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求， 并收到客户的应答后， 即断开连接。 采用这种方式可以节省传输时间。
5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
</code></pre><p>HTTP协议之请求</p>
<pre><code>http请求由三部分组成，分别是：请求行、消息报头、请求正文
请求方法有多种， 各个方法的解释如下：
GET请求获取Request-URI所标识的资源
POST在Request-URI所标识的资源后附加新的数据
HEAD请求获取由Request-URI所标识的资源的响应消息报头
PUT请求服务器存储一个资源， 并用Request-URI作为其标识
DELETE请求服务器删除Request-URI所标识的资源
TRACE请求服务器回送收到的请求信息，主要用于测试或诊断
CONNECT保留将来使用
OPTIONS请求查询服务器的性能，或者查询与资源相关的选项和需求
</code></pre><p>应用举例：</p>
<pre><code>GET方法在浏览器的地址栏中输入网址的方式访问网页时， 浏览器采用GET方法向服务器获取资源，eg:GET /form.html HTTP/1.1 (CRLF)
POST方法要求被请求服务器接受附在请求后面的数据， 常用于提交表单。
</code></pre><p>HTTP协议之响应</p>
<pre><code>在接收和解释请求消息后，服务器返回一个HTTP响应消息。
HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文
状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：
1xx：指示信息--表示请求已接收，继续处理
2xx：成功--表示请求已被成功接收、理解、接受
3xx：重定向--要完成请求必须进行更进一步的操作
4xx：客户端错误--请求有语法错误或请求无法实现
5xx：服务器端错误--服务器未能实现合法的请求
</code></pre><p>常见状态代码、状态描述、说明：</p>
<pre><code>200 OK //客户端请求成功
400 Bad Request //客户端请求有语法错误， 不能被服务器所理解
401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
403 Forbidden //服务器收到请求，但是拒绝提供服务
404 Not Found //请求资源不存在，eg： 输入了错误的URL
500 Internal Server Error //服务器发生不可预期的错误
503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2014/01/01/http协议介绍/">
    <time datetime="2013-12-31T16:00:00.000Z" class="entry-date">
        2014-01-01
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/随记/">随记</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-初识git" class="post-初识git post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2014/01/01/初识git/">初识git</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2014/01/01/初识git/" data-id="cjwk8gcn000291k0yklgb8xtr" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id><a href="#" class="headerlink" title=" "></a> </h1><hr>
<pre><code>ssh-keygen -t rsa -C &quot;gitcafe 注册邮箱&quot;  
</code></pre><p>密码一定要设置，这是为了防止别人往你的项目里乱push 东西。</p>
<hr>
<pre><code>less ~/.ssh/id_rsa.pub  
</code></pre><p>就会看到你生成的密钥了，打开gitcafe 账户设置的SSH 公钥管理，点添加新的密钥，输入你less 得到的那一坨东西提交。</p>
<p>之后进行一下git 的全局设置</p>
<hr>
<pre><code>git config --global user.name &quot;gitcafe 用户名&quot;  
git config --global user.email &quot;gitcafe 注册邮箱&quot;  
</code></pre><p>下面选择你的项目目录，假设是「~/gitcafe/hello」吧，cd 进去，里面新建一个测试文件。</p>
<p>配置一下你的项目（和目录同名不同名无所谓）</p>
<hr>
<pre><code>git init  
git remote add origin git@gitcafe.com:用户名/项目名.git  
</code></pre><p>上面第二行「git remote add」其实还设置了一个别称，以后输入origin 这个更加简短的别称就可以了。</p>
<p>然后add 下文件，第一次先把整个当前目录add 进去就行</p>
<hr>
<pre><code>git add .  
</code></pre><p>然后你可以看下当前你的项目里各个文件的提交状态</p>
<hr>
<pre><code>git status  
</code></pre><p>这时候你还不能push，因为你的gitcafe 还没有建立这个项目呢（虽然你git remote add 在本地添加了）。进去你的gitcafe，新建一个和你本地指定的项目名字一样的项目（不一定是你的项目的目录名，是git remote add 指定的那个）。这时候选择那个「初始化项目README.md 文件」之类的东西吧，正好练习下怎么整合远程变更，因为当很多人做项目的时候，别人push 了你这边就需要整合下变更才能push。</p>
<p>先写一个commit 信息并且push 一下（默认的分支名称是master）</p>
<hr>
<pre><code>git commit -m &quot;hello gitcafe&quot;  
git push -u origin master  
</code></pre><p>因为gitcafe 上有本地不存在的两个文件「README.md」和「.gitignore」，所以这次push 肯定是失败的。</p>
<p>把gitcafe 上的文件都pull 过来</p>
<hr>
<pre><code>git pull origin master  
</code></pre><p>这个时候本地和gitcafe 就一致了，这个时候push 就可以了。</p>
<p>如果想删除项目中的文件，例如删除hello 项目中的「README.md」和「.gitignore」（就像git add 那样）</p>
<hr>
<pre><code>git commit -m &quot;delete README.md .gitignore&quot;  
git rm README.md .gitignore  
</code></pre><p>写个commit 信息然后push 一下，你的项目里（无论本地和gitcafe）就没有这两个文件了。</p>
<p>这就是看了百度了半小时git 使用方法依葫芦画瓢学的，很少一点东西，而且感觉比右键拯救世界的TortoiseSVN 麻烦好多=。=</p>
<h1 id="2-git-常用指令"><a href="#2-git-常用指令" class="headerlink" title="2. git 常用指令"></a>2. git 常用指令</h1><p>只是记录备用</p>
<p>git branch 查看本地所有分支<br>git status 查看当前状态<br>git commit 提交<br>git branch -a 查看所有的分支<br>git branch -r 查看远程所有分支<br>git commit -am “init” 提交并且加注释<br>git remote add origin <a href="mailto:git@192.168.1.119" target="_blank" rel="noopener">git@192.168.1.119</a>:ndshow 增加一个远程服务器端<br>git push origin master 将文件给推到服务器上<br>git remote show origin 显示远程库origin里的资源<br>git push origin master:develop<br>git push origin master:hb-dev 将本地库与服务器上的库进行关联<br>git checkout –track origin/dev 切换到远程dev分支<br>git branch -D master develop 删除本地库develop<br>git checkout -b dev 建立一个新的本地分支dev<br>git merge origin/dev 将分支dev与当前分支进行合并<br>git checkout dev 切换到本地dev分支<br>git remote show 查看远程库<br>git add . 添加当前目录<br>git rm 文件名(包括路径) 从git中删除指定文件<br>git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来<br>git config –list 看所有用户<br>git ls-files 看已经被提交的<br>git rm [file name] 删除一个文件<br>git commit -a 提交当前repos的所有的改变<br>git add [file name] 添加一个文件到git index<br>git commit -v 当你用－v参数的时候可以看commit的差异<br>git commit -m “This is the message describing the commit” 添加commit信息<br>git commit -a -a是代表add，把所有的change加到git index里然后再commit<br>git commit -a -v 一般提交命令<br>git log 看你commit的日志<br>git diff 查看尚未暂存的更新<br>git rm a.a 移除文件(从暂存区和工作区中删除)<br>git rm –cached a.a 移除文件(只从暂存区中删除)<br>git commit -m “remove” 移除文件(从Git中删除)<br>git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)<br>git diff –cached 或 $ git diff –staged 查看尚未提交的更新<br>git stash push 将文件给push到一个临时空间中</p>
<h2 id="git-stash-pop-将文件从临时空间pop下来"><a href="#git-stash-pop-将文件从临时空间pop下来" class="headerlink" title="git stash pop 将文件从临时空间pop下来"></a>git stash pop 将文件从临时空间pop下来</h2><p>git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:username/Hello-World.git</p>
<h2 id="git-push-origin-master-将本地项目给提交到服务器中"><a href="#git-push-origin-master-将本地项目给提交到服务器中" class="headerlink" title="git push origin master 将本地项目给提交到服务器中"></a>git push origin master 将本地项目给提交到服务器中</h2><h2 id="git-pull-本地与服务器端同步"><a href="#git-pull-本地与服务器端同步" class="headerlink" title="git pull 本地与服务器端同步"></a>git pull 本地与服务器端同步</h2><p>git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。</p>
<h2 id="git-push-origin-serverfix-awesomebranch"><a href="#git-push-origin-serverfix-awesomebranch" class="headerlink" title="git push origin serverfix:awesomebranch"></a>git push origin serverfix:awesomebranch</h2><p>git fetch 相当于是从远程获取最新版本到本地，不会自动merge<br>git commit -a -m “log_message” (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：<br>git branch branch_0.1 master 从主分支master创建branch_0.1分支<br>git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0<br>git checkout branch_1.0/master 切换到branch_1.0/master分支</p>
<hr>
<p>git branch 删除远程branch<br>git push origin :branch_remote_name<br>git branch -r -d branch_remote_name</p>
<h1 id="3-git-指令速查表"><a href="#3-git-指令速查表" class="headerlink" title="3. git 指令速查表"></a>3. git 指令速查表</h1><p>至于这一堆高达上的表格？这个是凑字数的，我还不知道这辈子能不能用到呢！</p>
<h3 id="1、常用的Git命令"><a href="#1、常用的Git命令" class="headerlink" title="1、常用的Git命令"></a>1、常用的Git命令</h3><p>命令                     简要说明</p>
<p>git add                  添加至暂存区</p>
<p>git add–interactive     交互式添加</p>
<p>git apply                应用补丁</p>
<p>git am                   应用邮件格式补丁</p>
<p>git annotate             同义词，等同于 git blame</p>
<p>git archive              文件归档打包</p>
<p>git bisect               二分查找</p>
<p>git blame                文件逐行追溯</p>
<p>git branch               分支管理</p>
<p>git cat-file             版本库对象研究工具</p>
<p>git checkout             检出到工作区、切换或创建分支</p>
<p>git cherry-pick          提交拣选</p>
<p>git citool               图形化提交，相当于 git gui 命令</p>
<p>git clean                清除工作区未跟踪文件</p>
<p>git clone                克隆版本库</p>
<p>git commit               提交</p>
<p>git config               查询和修改配置</p>
<p>git describe             通过里程碑直观地显示提交ID</p>
<p>git diff                 差异比较</p>
<p>git difftool             调用图形化差异比较工具</p>
<p>git fetch                获取远程版本库的提交</p>
<p>git format-patch         创建邮件格式的补丁文件。参见 git am 命令</p>
<p>git grep                 文件内容搜索定位工具</p>
<p>git gui                  基于Tcl/Tk的图形化工具，侧重提交等操作</p>
<p>git help                 帮助</p>
<p>git init                 版本库初始化</p>
<p>git init-db*             同义词，等同于 git init</p>
<p>git log                 显示提交日志</p>
<p>git merge               分支合并</p>
<p>git mergetool           图形化冲突解决</p>
<p>git mv                  重命名</p>
<p>git pull                拉回远程版本库的提交</p>
<p>git push                推送至远程版本库</p>
<p>git rebase              分支变基</p>
<p>git rebase–interactive 交互式分支变基</p>
<p>git reflog              分支等引用变更记录管理</p>
<p>git remote              远程版本库管理</p>
<p>git repo-config*        同义词，等同于 git config</p>
<p>git reset               重置改变分支“游标”指向</p>
<p>git rev-parse           将各种引用表示法转换为哈希值等</p>
<p>git revert              反转提交</p>
<p>git rm                  删除文件</p>
<p>git show                显示各种类型的对象</p>
<p>git stage*              同义词，等同于 git add</p>
<p>git stash               保存和恢复进度</p>
<p>git status              显示工作区文件状态</p>
<p>git tag                 里程碑管理</p>
<h3 id="2、对象库操作相关命令"><a href="#2、对象库操作相关命令" class="headerlink" title="2、对象库操作相关命令"></a>2、对象库操作相关命令</h3><p>命令                    简要说明</p>
<p>git commit-tree         从树对象创建提交</p>
<p>git hash-object         从标准输入或文件计算哈希值或创建对象</p>
<p>git ls-files            显示工作区和暂存区文件</p>
<p>git ls-tree             显示树对象包含的文件</p>
<p>git mktag               读取标准输入创建一个里程碑对象</p>
<p>git mktree              读取标准输入创建一个树对象</p>
<p>git read-tree           读取树对象到暂存区</p>
<p>git update-index        工作区内容注册到暂存区及暂存区管理</p>
<p>git unpack-file         创建临时文件包含指定 blob 的内容</p>
<p>git write-tree          从暂存区创建一个树对象</p>
<h3 id="3、引用操作相关命令"><a href="#3、引用操作相关命令" class="headerlink" title="3、引用操作相关命令"></a>3、引用操作相关命令</h3><p>命令                    简要说明</p>
<p>git check-ref-format    检查引用名称是否符合规范</p>
<p>git for-each-ref        引用迭代器，用于shell编程</p>
<p>git ls-remote           显示远程版本库的引用</p>
<p>git name-rev            将提交ID显示为友好名称</p>
<p>git peek-remote*        过时命令，请使用 git ls-remote</p>
<p>git rev-list            显示版本范围</p>
<p>git show-branch         显示分支列表及拓扑关系</p>
<p>git show-ref            显示本地引用</p>
<p>git symbolic-ref        显示或者设置符号引用</p>
<p>git update-ref          更新引用的指向</p>
<p>git verify-tag          校验 GPG 签名的Tag</p>
<h3 id="4、版本库管理相关命令"><a href="#4、版本库管理相关命令" class="headerlink" title="4、版本库管理相关命令"></a>4、版本库管理相关命令</h3><p>命令                    简要说明</p>
<p>git count-objects       显示松散对象的数量和磁盘占用</p>
<p>git filter-branch       版本库重构</p>
<p>git fsck                对象库完整性检查</p>
<p>git fsck-objects*       同义词，等同于 git fsck</p>
<p>git gc                  版本库存储优化</p>
<p>git index-pack          从打包文件创建对应的索引文件</p>
<p>git lost-found*         过时，请使用 git fsck –lost-found 命令</p>
<p>git pack-objects        从标准输入读入对象ID，打包到文件</p>
<p>git pack-redundant      查找多余的 pack 文件</p>
<p>git pack-refs           将引用打包到 .git/packed-refs 文件中</p>
<p>git prune               从对象库删除过期对象</p>
<p>git prune-packed        将已经打包的松散对象删除</p>
<p>git relink              为本地版本库中相同的对象建立硬连接</p>
<p>git repack              将版本库未打包的松散对象打包</p>
<p>git show-index          读取包的索引文件，显示打包文件中的内容</p>
<p>git unpack-objects      从打包文件释放文件</p>
<p>git verify-pack         校验对象库打包文件</p>
<h3 id="5、数据传输相关命令"><a href="#5、数据传输相关命令" class="headerlink" title="5、数据传输相关命令"></a>5、数据传输相关命令</h3><p>命令                    简要说明</p>
<p>git fetch-pack          执行 git fetch 或 git pull 命令时在本地执行此命令，用于从其他版本库获取缺失的对象</p>
<p>git receive-pack        执行 git push 命令时在远程执行的命令，用于接受推送的数据</p>
<p>git send-pack           执行 git push 命令时在本地执行的命令，用于向其他版本库推送数据</p>
<p>git upload-archive      执行 git archive –remote 命令基于远程版本库创建归档时，远程版本库执行此命令传送归档</p>
<p>git upload-pack         执行 git fetch 或 git pull 命令时在远程执行此命令，将对象打包、上传</p>
<p>6、邮件相关命令</p>
<p>命令                    简要说明</p>
<p>git imap-send           将补丁通过 IMAP 发送</p>
<p>git mailinfo            从邮件导出提交说明和补丁</p>
<p>git mailsplit           将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件</p>
<p>git request-pull        创建包含提交间差异和执行PULL操作地址的信息</p>
<p>git send-email          发送邮件</p>
<p>7、协议相关命令</p>
<p>命令                    简要说明</p>
<p>git daemon              实现Git协议</p>
<p>git http-backend        实现HTTP协议的CGI程序，支持智能HTTP协议</p>
<p>git instaweb            即时启动浏览器通过 gitweb 浏览当前版本库</p>
<p>git shell               受限制的shell，提供仅执行Git命令的SSH访问</p>
<p>git update-server-info  更新哑协议需要的辅助文件</p>
<p>git http-fetch          通过HTTP协议获取版本库</p>
<p>git http-push           通过HTTP/DAV协议推送</p>
<p>git remote-ext          由Git命令调用，通过外部命令提供扩展协议支持</p>
<p>git remote-fd           由Git命令调用，使用文件描述符作为协议接口</p>
<p>git remote-ftp          由Git命令调用，提供对FTP协议的支持</p>
<p>git remote-ftps         由Git命令调用，提供对FTPS协议的支持</p>
<p>git remote-http         由Git命令调用，提供对HTTP协议的支持</p>
<p>git remote-https        由Git命令调用，提供对HTTPS协议的支持</p>
<p>git remote-testgit      协议扩展示例脚本</p>
<p>8、版本库转换和交互相关命令</p>
<p>命令                    简要说明</p>
<p>git archimport          导入Arch版本库到Git</p>
<p>git bundle              提交打包和解包，以便在不同版本库间传递</p>
<p>git cvsexportcommit     将Git的一个提交作为一个CVS检出</p>
<p>git cvsimport           导入CVS版本库到Git。或者使用 cvs2git</p>
<p>git cvsserver           Git的CVS协议模拟器，可供CVS命令访问Git版本库</p>
<p>git fast-export         将提交导出为 git-fast-import 格式</p>
<p>git fast-import         其他版本库迁移至Git的通用工具</p>
<p>git svn                 Git 作为前端操作 Subversion</p>
<p>9、合并相关的辅助命令</p>
<p>命令                    简要说明</p>
<p>git merge-base          供其他脚本调用，找到两个或多个提交最近的共同祖先</p>
<p>git merge-file          针对文件的两个不同版本执行三向文件合并</p>
<p>git merge-index         对index中的冲突文件调用指定的冲突解决工具</p>
<p>git merge-octopus       合并两个以上分支。参见 git merge 的octopus合并策略</p>
<p>git merge-one-file      由 git merge-index 调用的标准辅助程序</p>
<p>git merge-ours          合并使用本地版本，抛弃他人版本。参见 git merge 的ours合并策略</p>
<p>git merge-recursive     针对两个分支的三向合并。参见 git merge 的recursive合并策略</p>
<p>git merge-resolve       针对两个分支的三向合并。参见 git merge 的resolve合并策略</p>
<p>git merge-subtree       子树合并。参见 git merge 的 subtree 合并策略</p>
<p>git merge-tree          显式三向合并结果，不改变暂存区</p>
<p>git fmt-merge-msg       供执行合并操作的脚本调用，用于创建一个合并提交说明</p>
<p>git rerere              重用所记录的冲突解决方案</p>
<p>10、 杂项</p>
<p>命令                    简要说明</p>
<p>git bisect–helper      由 git bisect 命令调用，确认二分查找进度</p>
<p>git check-attr          显示某个文件是否设置了某个属性</p>
<p>git checkout-index      从暂存区拷贝文件至工作区</p>
<p>git cherry              查找没有合并到上游的提交</p>
<p>git diff-files          比较暂存区和工作区，相当于 git diff –raw</p>
<p>git diff-index          比较暂存区和版本库，相当于 git diff –cached –raw</p>
<p>git diff-tree           比较两个树对象，相当于 git diff –raw A B</p>
<p>git difftool–helper    由 git difftool 命令调用，默认要使用的差异比较工具</p>
<p>git get-tar-commit-id   从 git archive 创建的 tar 包中提取提交ID</p>
<p>git gui–askpass        命令 git gui 的获取用户口令输入界面</p>
<p>git notes               提交评论管理</p>
<p>git patch-id            补丁过滤行号和空白字符后生成补丁唯一ID</p>
<p>git quiltimport         将Quilt补丁列表应用到当前分支</p>
<p>git replace             提交替换</p>
<p>git shortlog            对 git log 的汇总输出，适合于产品发布说明</p>
<p>git stripspace          删除空行，供其他脚本调用</p>
<p>git submodule           子模组管理</p>
<p>git tar-tree            过时命令，请使用 git archive</p>
<p>git var                 显示 Git 环境变量</p>
<p>git web–browse         启动浏览器以查看目录或文件</p>
<p>git whatchanged         显示提交历史及每次提交的改动</p>
<p>git-mergetool–lib      包含于其他脚本中，提供合并/差异比较工具的选择和执行</p>
<p>git-parse-remote        包含于其他脚本中，提供操作远程版本库的函数</p>
<p>git-sh-setup            包含于其他脚本中，提供 shell 编程的函数库</p>
<h3 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h3><pre><code>#删除分支&amp;添加分支
 # 添加本地关联的远程库
git remote add zqs git@172.81.205.48:scf-service/scf-service.git
git remote add zqs git@172.81.205.48:scf-service/scf_modules_app.git

# 删除本地关联的远程库
git remote remove zqs

# 将某个远程主机的更新，全部取回本地
$ git fetch --all
# 将某个远程主机分支最新更新，取回本地
$ git reset --hard origin/development 
# 合并版本 根据 commit id 
git cherry-pick 134ceeb9aa3c3e4c1565978b07311cb308eefebe
 # 打包 commit 版本
 git diff-tree -r -no-commit-id --name-only 41242f6f3cfe6f712a9cd2e1858d94de8a51ee09 | xargs tar -rf dev_061401.tar

# 合并版本 根据 commit id 
git cherry-pick 134ceeb9aa3c3e4c1565978b07311cb308eefebe aa2eb06db72615d1369fd4bd889526a580de37d7
----------------------------------添加项目------------------------------

--Git global setup

git config --global user.name &quot;zangqisong&quot;
git config --global user.email &quot;zangqisong@cangoonline.com&quot;

--Create a new repository

mkdir scf-service
cd scf-service
git init
--touch README.md
git add .
git commit -m &quot;first commit&quot;
git remote add origin git@172.81.205.48:scf-service/scf-service.git
git push -u origin master

--Push an existing Git repository

cd scf-service
git remote add origin git@172.81.205.48:scf-service/scf-service.git
git push -u origin master
----------------------------------添加项目------------------------------

----------------------------------忽略文件------------------------------
# 添加忽略文件
touch .gitignore
#   清除记录
git rm -r --cached .
# 添加记录
git add .
git commit -m &quot;update .gitignore&quot;
----------------------------------忽略文件------------------------------
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2014/01/01/初识git/">
    <time datetime="2013-12-31T16:00:00.000Z" class="entry-date">
        2014-01-01
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Git/">Git</a>
  </div>

    
    </footer>
</article>






  
  
    <nav id="pagination">
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
      </nav>
    </nav>
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value name="s" id="s">
        <input type="submit" id="searchsubmit" value="搜索">
    </div>
</form></aside>
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-content">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SVN/">SVN</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud-Spring-Boot-微服务/">Spring Cloud Spring Boot 微服务</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/node-vue/">node vue</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随记/">随记</a><span class="category-list-count">5</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2019/06/04/vue 事件中的 .native/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/06/03/java 正则表达式 手机号 邮箱/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/05/14/node-vue-webpack构建项目/">node-vue-webpack 构建项目</a>
          </li>
        
          <li>
            <a href="/2019/05/07/关于Java 23种设计模式/">关于Java 23种设计模式</a>
          </li>
        
          <li>
            <a href="/2019/05/06/vue + webpack 多模块静态文件导入/">vue + webpack 多模块静态文件导入</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2019 花皮松
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>