<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  

  
  
  
  
  
  
  <title>随记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="随记">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="随记">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="随记">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src="//push.zhanzhang.baidu.com/push.js"></script>
</head></html>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="随记" rel="home">随记</a>
      </h1>
      
        <h2 class="site-description hitokoto"></h2>
        <script type="text/javascript" src="https://v1.hitokoto.cn/?encode=js"></script>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-前端学习" class="post-前端学习 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2023/03/03/前端学习/">前端学习</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2023/03/03/前端学习/" data-id="clesbyv2g0057psia5bk2v2ua" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="前端学习"><a href="#前端学习" class="headerlink" title="前端学习"></a>前端学习</h1><h2 id="一、HTML-CSS3-部分"><a href="#一、HTML-CSS3-部分" class="headerlink" title="一、HTML/CSS3 部分"></a>一、HTML/CSS3 部分</h2><p>前端概念总览、vscode开发工具使用、markdown文档工具使用、浏览器平台环境、标签基础、DTD与META</p>
<p>语义化、选择器、权重与优先级、匹配规则、浮动与清除、BFC、类名组合规则、SEO前端技巧、定位、叠加技巧、</p>
<p>伪类、伪元素、盒子模型、代码规范、性能优化、渲染原理、CSS Sprites 、 iconfont字体图标、布局思路、布局定式</p>
<p>css3动画、 css3选择器、 css3过渡、flex布局、背景渐变、css3实用动效、3D模块、css3变量、em/rem/vw</p>
<p>企业内部多页面项目实战（非仿站）有完整PSD与切图</p>
<h2 id="二、JavaScript-部分"><a href="#二、JavaScript-部分" class="headerlink" title="二、JavaScript 部分"></a>二、JavaScript 部分</h2><p>JavaScript概念、基础认知、发展历史、应用范围、优缺点。</p>
<p>ECMAScript</p>
<p>语言概览、语句语法、数据类型、运算符、隐式转换、运算规则、控制流程、作用域、作用域链、作用域解析、js解释引擎、字符串属性方法、for of/for in</p>
<p>数组属性方法、对象、广义对象概念、对象特性、存储机制、深拷贝、对象实际应用、工厂模式、构造函数、原型、原型链、原型指向、封装、</p>
<p>多种继承、包装对象、this、this指向、js数据处理、垃圾GC、闭包原理与应用、debug方法论、浏览器控制台工具应用、面向对象开发、函数式开发、</p>
<p>纯函数、递归函数、回调函数、组合函数、缓存函数、柯里化函数、偏函数、函数防抖与节流、高级函数、IIFE函数、模块化、</p>
<p>数学对象、高级数组方法（reduce、filter、map、every、some、forEach、find、findIndex、include）等、</p>
<p>高级对象方法（entires、defineProperty、freeze、fromEntries、assign、keys、create、hasOwnProperty）等</p>
<p>this通过bind、call、apply指向偏移、同步与异步、闭包模块化、数据形变处理、性能处理</p>
<p>DOM/BOM</p>
<p>DOM对象与方法、节点与遍历树、DOM选择器、DOM节点增删改查、DOM样式操作、DOM位置获取与偏移、DOM对象与标签区别、DOM虚拟化、DOM事件、</p>
<p>Event对象、定时器与监听器、事件委托、事件代理、事件分流、事件冒泡、默认行为、事件捕获、防抖、节流、滚动、键盘行为、事件降频、行为锁机制、</p>
<p>拖拽模组、碰撞检测、距离判断、三角函数、方向判断、运动框架、弹性运动、重力加速度、DOM树、CSSOM树、渲染解析、加载、回流、重绘、浏览器线程与阻塞。</p>
<p>BOM深入、window对象、navigator、history、screen、location、spa概念、本地传参、日期对象使用、日期格式化封装、随机封装、DOM分片容器</p>
<p>JS业务应用扩展</p>
<p>JSON对象、数据解析、JSON方法、模板渲染、缓存懒加载、正则表达式RegExp、元字符、修饰符、正向预查、贪婪模式、replace方法、分组与不分组、test、match与exec</p>
<p>正则库封装、表单校验、图片预存懒加载、自定义封装滚动组件、多重轮播（循环、视差、旋转木马）、选项卡切换、楼梯导航、吸顶导航、拖拽导航 、</p>
<p>JavaScript编码风格指南、console应用技巧</p>
<p>ECMAScript5 — ECMAScript9扩展</p>
<p>版本解读、应用环境、let、const、解构赋值、箭头函数、对象解构、reset参数解构、class、set、get、extends、super、static、private实现、symbol、promise、proxy代理拦截、async/await</p>
<p>对象新增API、数组新增API、字符串新增API、原型属性、对象修饰、代理拦截、链式询问、空值合并运算符、泡泡龙面向对象游戏开发</p>
<h2 id="三、HTML5-移动端开发-部分"><a href="#三、HTML5-移动端开发-部分" class="headerlink" title="三、HTML5 / 移动端开发 部分"></a>三、HTML5 / 移动端开发 部分</h2><p>HTML5标签与API</p>
<p>HTML5概念、定义、新增特性、DTD对比、新增H5标签、新增语义化H5标签、H5表单</p>
<p>H5拖拽事件 video、audio、fullScreen、FileReader文件流、Blob对象、sessionStorage、localStorage、</p>
<p>网络状态、页面生命周期、网页状态监听、地理信息与定位、canvas画布、worker多线程、Notifications桌面通知</p>
<p>播放器开发 canvas交互特效开发</p>
<p>移动端适配/事件</p>
<p>移动端适配概念、尺寸与分辨率原理、PPI与DPI计算、DIP与DPR设备像素概念、视口viewport概念、布局视口、视觉视口、理想视口</p>
<p>视口适配方案（Meta viewport）缩放设置 、screen窗口大小API、媒体查询@media、rem适配、vw vh适配</p>
<p>移动端适配方案、flexible rem方案、 vh vw方案 、复合方案、高清适配方案、移动端字体缩放解决、1px边框问题解决、半像素线</p>
<p>图片高清适配、image-set、srcset、js拼接URL技巧、IPhonex刘海屏适配、安全区域、fit与env</p>
<p>Meta权限管理、兼容优化、IOS头部底部闪屏回退输入框问题、输入法空格问题、默认首字母大写问题、滑动卡顿问题等</p>
<p>终端样式美化与访问判断</p>
<p>Touch事件组封装、click延迟处理、FastClick使用、禁用缩放设置理想视口</p>
<p>常用类库/工具</p>
<p>jquery: 元素选择、增删改差、事件处理、位置获取、动画过渡、高级方法、特效应用</p>
<p>zepto：移动端的jquery、DOM操作、移动端事件、click延迟处理、touch事件组</p>
<p>基础UI库: layerUI 、easyUI、bootStrap、UI模块化、UI库使用技巧、文档解读、案例调试、表单系统</p>
<p>iScroll、touchjs等移动端事件库使用</p>
<p>swiper：移动端网站触摸滑动、轮播图插件、模块化应用、源码解读</p>
<p>art-template: 模板引擎 模板语法、渲染方法、原生模板引擎实现</p>
<p>CSS预处理：sass、less使用 stylus深入学习 、预处理语法、css编程、 Minxin 、预处理函数、继承、嵌套</p>
<p>vscode高级插件与配置 liveserver sass</p>
<p>模板化应用 、预处理应用</p>
<p>date-picker移动端原生组件开发</p>
<p>需求分析、业务规则、技术栈选型、文件输出规则、技术分析</p>
<p>MVC模型概念与设计、业务逻辑分类</p>
<p>view层适配方案 原型布局搭建 模板化生成</p>
<p>工具函数开发、面向对象式业务设计 功能类日期对象开发</p>
<p>交互业务封装 模块对接 优化设计 面向对象高级程序设计</p>
<h2 id="四、Nodejs与工程化开发-部分"><a href="#四、Nodejs与工程化开发-部分" class="headerlink" title="四、Nodejs与工程化开发 部分"></a>四、Nodejs与工程化开发 部分</h2><p>Node原生基础</p>
<p>Node基础概念、NPM命令、V8引擎概念、JavaScript模块化 CMD AMD UMD、EventLoop事件循环、同步异步、 阻塞非阻塞 、任务队列、宏任务、微任务、</p>
<p>原生Node模块、核心模块与require、module、触发器events与path模块、fs模块、Buffer对象、URL模块、HTTP模块 、stream流</p>
<p>Node原生封装HTTP与文件服务器</p>
<p>Node框架</p>
<p>express框架使用、中间件、核心对象、路由配置、模板引擎、数据脚本、Router核心、CORS配置、错误处理、校验封装、PM2管理、nodemoon管理</p>
<p>MORGAN日志处理、查询正则捕获、中间件开发、bodyParse等第三方中间件使用 、文件流上传下载、文件流切分</p>
<p>webpack工程化构建</p>
<p>工程化概念、工程化工具介绍、webpack基础知识、webpack配置与运行、plugin插件、loader使用、入口出口配置、模块modules、依赖处理、dev Server</p>
<p>target 、文件切分、build打包、热处理、package管理、性能优化、测试处理 、第三方插件使用、babel等</p>
<p>前后端数据交互</p>
<p>HTTP通信交互原理、请求响应、MIME、URI地址、报文解析、端口、报文流、测试监听抓包、TCP/IP握手机制、网络业务模型</p>
<p>代理、缓存、网关、隧道等概念、method与请求头分类</p>
<p>基础XMLHTTPRequest对象方法属性、方法、ajax异步交互 、同源策略原理</p>
<p>原生js封装ajax交互、 jquery的ajax封装交互、jsonp跨域处理、cors跨域处理、携带cookie与跨域处理、代理服务器跨域处理、</p>
<p>cookie验证与通信 、axios库的使用 代理、封装、拦截、合并、二次封装</p>
<p>通信加密策略、数据对称加密、数据非对称加密、RSA加密实践、MD5加密实践</p>
<p>登录注册与鉴权机制、Authenticity认证、Token认证、JWT认证、session状态管理、 oauth认证</p>
<p>RESTful接口设计</p>
<p>RESTful设计原则、状态码设计与规范、服务器响应规则与格式、前后端接口协议制定、传统RESTful改进</p>
<p>API设计规范、 资源定位、JSON模式、合约说明、资源标识符、缓存友好API、HTTP头管理、文档定义、松耦合原则、一致性、重用、稳定性原则</p>
<p>数据库存储</p>
<p>MongoDB基础概念、NoSQL与SQL、CAP定理、RDBMS、MongoDB语法、指令、监控与GUI、MongoDb驱动、Mongoose应用</p>
<p>数据库创建、集合增删改查、文档增删改查、数据库查询、高级查询操作、通道查询、多条件查询、反向筛选、索引处理、aggregate聚合管道、</p>
<p>validation验证、population联表、middleware中间件处理、查询ERROR类二次封装</p>
<p>博客后台项目实战</p>
<p>数据库设计、服务端路由搭建、接口设计与API管理、通信交互管道封装、注册登录、路由导航、前端路由管理、权限管理、用户管理、分类管理、标签管理</p>
<p>、文章管理、模块化功能封装、校验库封装、promise链式行为封装、</p>
<p>异步模块处理、SPA单页面应用初级实现、原生集中行为控制器、模板化+模块化+预处理+工程化实现前端页面</p>
<p>组件化封装</p>
<p>组件化基础概念、组件设计原则、组件封装、组件耦合与解耦、工程化+模板化+模块化实现原生组件化功能、</p>
<h2 id="五、Vue框架部分"><a href="#五、Vue框架部分" class="headerlink" title="五、Vue框架部分"></a>五、Vue框架部分</h2><p>vue基础</p>
<p>vue开发准备、工具与插件、mvc mvp mvvm设计理念、原生js实现MVVM核心框架、vue设计模式、生命周期、命令与属性、组件化</p>
<p>数据驱动与双向绑定、虚拟DOM概念原理、模板语法、条件与列表、数组监测、计算属性、事件处理、修饰与表单、监听器、过滤器、</p>
<p>methods watch computed filter对比、组件化开发、动态组件、组件通信、高级组件通信、插槽、vue动画 、实例对象、set、get、nextTick、vue插件</p>
<p>vue工程化</p>
<p>Babel、webpack配置vue、vue单文件组件、vue-cli、工程平台处理、postCss、animate、core、socket、lodash工具、vue-cli插件、preset、静态资源处理、</p>
<p>环境变量与膜还是切换、工程化部署、工程构建</p>
<p>vue Router</p>
<p>vue路由概念、嵌套路由、路由视图、动态路由、路由匹配、编程式导航、history、hash模式管理、命名视图、重定向与别名、导航守卫、路由元信息、滚动与懒加载、导航故障处理</p>
<p>vuex</p>
<p>vuex核心概念、EventBus对比、状态管理模式、Store、state、getter、mutation、action、moudule</p>
<p>vuex辅助函数与API功能、vuex环境选择、vuex模块化处理规则与技巧、对象风格提交方式、模块重用等</p>
<p>vue项目实战</p>
<p>vue博客项目实战 PC + 移动端、 elementUI、vantUI、websocket聊天室、虚拟人偶、vueScroll、store、qs、nprogress、editor、</p>
<p>文章分类、词云效果、spa单页面应用、移动PC无缝切换、完整注册登录、vue加密鉴权、http封装管理、错误处理封装、vuex核心状态管理、本地存储状态更新、令牌处理、</p>
<p>文章富文本编辑、点赞、收藏、访问、评论、组件封装、组件复用、组件混合、高级组件开发、复合性组件通信、vue中处理原生DOM行为、vue常见错误处理、</p>
<p>重置vue数据响应、个人信息修改、头像上传、通知组件封装、postcss应用、项目打包优化</p>
<p>能够把这些知识点掌握，你就是一名优秀的前端工程师了。</p>

      
    </div><!-- .entry-content -->
    <!-- busuanzi  start -->
    
    <!-- busuanzi  end -->

    <footer class="entry-meta">
    <a href="/2023/03/03/前端学习/">
    <time datetime="2023-03-02T16:00:00.000Z" class="entry-date">
        2023-03-03
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/前端学习/">前端学习</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-关于Java 23种设计模式" class="post-关于Java 23种设计模式 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2021/11/10/关于Java 23种设计模式/">关于Java 23种设计模式</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2021/11/10/关于Java 23种设计模式/" data-id="clesbyv2g005kpsia4r9vb6w5" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="java的设计模式大体上分为三大类"><a href="#java的设计模式大体上分为三大类" class="headerlink" title="java的设计模式大体上分为三大类"></a>java的设计模式大体上分为三大类</h2><pre><code>创建型模式（5种）：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式。
结构型模式（7种）：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式。
行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
</code></pre><h2 id="设计模式遵循的原则有6个"><a href="#设计模式遵循的原则有6个" class="headerlink" title="设计模式遵循的原则有6个"></a>设计模式遵循的原则有6个</h2><h3 id="1、开闭原则（Open-Close-Principle）"><a href="#1、开闭原则（Open-Close-Principle）" class="headerlink" title="1、开闭原则（Open Close Principle）"></a>1、开闭原则（Open Close Principle）</h3><pre><code>对扩展开放，对修改关闭。
</code></pre><h3 id="2、里氏代换原则（Liskov-Substitution-Principle）"><a href="#2、里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏代换原则（Liskov Substitution Principle）"></a>2、里氏代换原则（Liskov Substitution Principle）</h3><pre><code>只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。
</code></pre><h3 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a>3、依赖倒转原则（Dependence Inversion Principle）</h3><pre><code>这个是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。
</code></pre><h3 id="4、接口隔离原则（Interface-Segregation-Principle）"><a href="#4、接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="4、接口隔离原则（Interface Segregation Principle）"></a>4、接口隔离原则（Interface Segregation Principle）</h3><pre><code>使用多个隔离的借口来降低耦合度。
</code></pre><h3 id="5、迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#5、迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="5、迪米特法则（最少知道原则）（Demeter Principle）"></a>5、迪米特法则（最少知道原则）（Demeter Principle）</h3><pre><code>一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。
</code></pre><h3 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a>6、合成复用原则（Composite Reuse Principle）</h3><pre><code>原则是尽量使用合成/聚合的方式，而不是使用继承。继承实际上破坏了类的封装性，超类的方法可能会被子类修改。
</code></pre><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="1-工厂模式（Factory）"><a href="#1-工厂模式（Factory）" class="headerlink" title="1. 工厂模式（Factory）"></a>1. 工厂模式（Factory）</h3><p>工厂模式：客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。</p>
<p> 常用的工厂模式是静态工厂，利用static方法，作为一种类似于常见的工具类Utils等辅助效果，一般情况下工厂类不需要实例化。</p>
<pre><code>interface food{}

class A implements food{}
class B implements food{}
class C implements food{}

public class StaticFactory {

    private StaticFactory(){}

    public static food getA(){  return new A(); }
    public static food getB(){  return new B(); }
    public static food getC(){  return new C(); }
}

class Client{
    //客户端代码只需要将相应的参数传入即可得到对象
    //用户不需要了解工厂类内部的逻辑。
    public void get(String name){
        food x = null ;
        if ( name.equals(&quot;A&quot;)) {
            x = StaticFactory.getA();
        }else if ( name.equals(&quot;B&quot;)){
            x = StaticFactory.getB();
        }else {
            x = StaticFactory.getC();
        }
    }
}
</code></pre><h3 id="2-建造者模式（Builder）"><a href="#2-建造者模式（Builder）" class="headerlink" title="2. 建造者模式（Builder）"></a>2. 建造者模式（Builder）</h3><p>建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。</p>
<p>在了解之前，先假设有一个问题，我们需要创建一个学生对象，属性有name,number,class,sex,age,school等属性，如果每一个属性都可以为空，也就是说我们可以只用一个name,也可以用一个school,name,或者一个class,number，或者其他任意的赋值来创建一个学生对象，这时该怎么构造？</p>
<p>难道我们写6个1个输入的构造函数，15个2个输入的构造函数…….吗？这个时候就需要用到Builder模式了。给个例子，大家肯定一看就懂：</p>
<pre><code>public class Builder {

    static class Student{
        String name = null ;
        int number = -1 ;
        String sex = null ;
        int age = -1 ;
        String school = null ;

        //构建器，利用构建器作为参数来构建Student对象
        static class StudentBuilder{
            String name = null ;
            int number = -1 ;
            String sex = null ;
            int age = -1 ;
            String school = null ;
            public StudentBuilder setName(String name) {
                this.name = name;
                return  this ;
            }

            public StudentBuilder setNumber(int number) {
                this.number = number;
                return  this ;
            }

            public StudentBuilder setSex(String sex) {
                this.sex = sex;
                return  this ;
            }

            public StudentBuilder setAge(int age) {
                this.age = age;
                return  this ;
            }

            public StudentBuilder setSchool(String school) {
                this.school = school;
                return  this ;
            }
            public Student build() {
                return new Student(this);
            }
        }

        public Student(StudentBuilder builder){
            this.age = builder.age;
            this.name = builder.name;
            this.number = builder.number;
            this.school = builder.school ;
            this.sex = builder.sex ;
        }
    }

    public static void main( String[] args ){
        Student a = new Student.StudentBuilder().setAge(13).setName(&quot;LiHua&quot;).build();
        Student b = new Student.StudentBuilder().setSchool(&quot;sc&quot;).setSex(&quot;Male&quot;).setName(&quot;ZhangSan&quot;).build();
    }
}
</code></pre><h3 id="3、工厂模式（Factory-Method）"><a href="#3、工厂模式（Factory-Method）" class="headerlink" title="3、工厂模式（Factory Method）"></a>3、工厂模式（Factory Method）</h3><p>工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p>
<p>一个基础接口定义了功能，每个实现接口的子类就是产品，然后定义一个工厂接口，实现了工厂接口的就是工厂，这时候，接口编程的优点就出现了，我们可以新增产品类（只需要实现产品接口），只需要同时新增一个工厂类，客户端就可以轻松调用新产品的代码。</p>
<p> 实例代码：</p>
<pre><code>interface food{}

class A implements food{}
class B implements food{}

interface produce{ food get();}

class FactoryForA implements produce{
    @Override
    public food get() {
        return new A();
    }
}
class FactoryForB implements produce{
    @Override
    public food get() {
        return new B();
    }
}
public class AbstractFactory {
    public void ClientCode(String name){
        food x= new FactoryForA().get();
        x = new FactoryForB().get();
    }
}
</code></pre><h3 id="4、prototype"><a href="#4、prototype" class="headerlink" title="4、prototype"></a>4、prototype</h3><p>原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。</p>
<p>浅拷贝<br>    public class Prototype implements Cloneable{</p>
<pre><code>    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    protected Object clone()   {
        try {
            return super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }finally {
            return null;
        }
    }

    public static void main ( String[] args){
        Prototype pro = new Prototype();
        Prototype pro1 = (Prototype)pro.clone();
    }
}
</code></pre><p>深拷贝</p>
<pre><code>public class Professor implements Cloneable {

    private String name;
    private Integer age;

    public Professor(String name, Integer age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Object clone() {

        Object o = null;
        try {
            o = super.clone();
        } catch (CloneNotSupportedException e) {
            System.out.println(e.toString());
        }
        return o;
    }

}

Student类:
public class Student implements Cloneable {

    private String name;
    private Integer age;
    private Professor professor;

    public Student(String name, Integer age, Professor professor) {
        this.name = name;
        this.age = age;
        this.professor = professor;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Professor getProfessor() {
        return professor;
    }

    public void setProfessor(Professor professor) {
        this.professor = professor;
    }

    public Object clone() {

        Student o = null;
        try {
            o = (Student) super.clone();
        } catch (CloneNotSupportedException e) {
            System.out.println(e.toString());
        }
        o.professor = (Professor) professor.clone();
        return o;
    }
}

测试：
public class Demo01 {

    public static void main(String[] args) {

        Professor p = new Professor(&quot;wangwu&quot;, 50);
        Student s1 = new Student(&quot;xiaoming&quot;, 20, p);
        Student s2 = (Student) s1.clone();
        s2.getProfessor().setName(&quot;xiaowangwu&quot;);
        s2.getProfessor().setAge(40);
        System.out.println(&quot;name=&quot; + s1.getProfessor().getName()
                + &quot;,&quot; + &quot;age=&quot; + s1.getProfessor().getAge());
        System.out.println(&quot;name=&quot; + s2.getProfessor().getName()
                + &quot;,&quot; + &quot;age=&quot; + s2.getProfessor().getAge());
    }
}

输出结果：

name=wangwu,age=50
name=xiaowangwu,age=40
</code></pre><h3 id="5、Sigleton"><a href="#5、Sigleton" class="headerlink" title="5、Sigleton"></a>5、Sigleton</h3><p>单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。</p>
<p>在内部创建一个实例，构造器全部设置为private，所有方法均在该实例上改动，在创建上要注意类的实例化只能执行一次，可以采用许多种方法来实现，如Synchronized关键字，或者利用内部类等机制来实现。</p>
<pre><code>public class Singleton {
    private Singleton(){}

    private static class SingletonBuild{
        private static Singleton value = new Singleton();
    }

    public Singleton getInstance(){  return  SingletonBuild.value ;}

}
</code></pre><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="6、适配器模式（Adapter）"><a href="#6、适配器模式（Adapter）" class="headerlink" title="6、适配器模式（Adapter）"></a>6、适配器模式（Adapter）</h3><p>适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。</p>
<p>适配器模式的作用就是在原来的类上提供新功能。主要可分为3种：</p>
<pre><code>类适配：创建新类，继承源类，并实现新接口，例如 

class  adapter extends oldClass  implements newFunc{}

对象适配：创建新类持源类的实例，并实现新接口，例如 

class adapter implements newFunc { private oldClass oldInstance ;}

接口适配：创建新的抽象类实现旧接口方法。例如 

abstract class adapter implements oldClassFunc { void newFunc();}
</code></pre><h3 id="7、桥接模式（Bridge）"><a href="#7、桥接模式（Bridge）" class="headerlink" title="7、桥接模式（Bridge）"></a>7、桥接模式（Bridge）</h3><p>桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。</p>
<pre><code>interface DrawAPI {
    public void drawCircle(int radius, int x, int y);
}
class RedCircle implements DrawAPI {
    @Override
    public void drawCircle(int radius, int x, int y) {
        System.out.println(&quot;Drawing Circle[ color: red, radius: &quot;
                + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);
    }
}
class GreenCircle implements DrawAPI {
    @Override
    public void drawCircle(int radius, int x, int y) {
        System.out.println(&quot;Drawing Circle[ color: green, radius: &quot;
                + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);
    }
}

abstract class Shape {
    protected DrawAPI drawAPI;
    protected Shape(DrawAPI drawAPI){
        this.drawAPI = drawAPI;
    }
    public abstract void draw();
}

class Circle extends Shape {
    private int x, y, radius;

    public Circle(int x, int y, int radius, DrawAPI drawAPI) {
        super(drawAPI);
        this.x = x;
        this.y = y;
        this.radius = radius;
    }

    public void draw() {
        drawAPI.drawCircle(radius,x,y);
    }
}

//客户端使用代码
Shape redCircle = new Circle(100,100, 10, new RedCircle());
Shape greenCircle = new Circle(100,100, 10, new GreenCircle());
redCircle.draw();
greenCircle.draw();
</code></pre><h3 id="8、组合模式（Composite）"><a href="#8、组合模式（Composite）" class="headerlink" title="8、组合模式（Composite）"></a>8、组合模式（Composite）</h3><p>合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。</p>
<pre><code>abstract class component{}

class File extends  component{ String filename;}

class Folder extends  component{
    component[] files ;  //既可以放文件File类，也可以放文件夹Folder类。Folder类下又有子文件或子文件夹。
    String foldername ;
    public Folder(component[] source){ files = source ;}

    public void scan(){
        for ( component f:files){
            if ( f instanceof File){
                System.out.println(&quot;File &quot;+((File) f).filename);
            }else if(f instanceof Folder){
                Folder e = (Folder)f ;
                System.out.println(&quot;Folder &quot;+e.foldername);
                e.scan();
            }
        }
    }

}
</code></pre><h3 id="9、装饰模式（Decorator）"><a href="#9、装饰模式（Decorator）" class="headerlink" title="9、装饰模式（Decorator）"></a>9、装饰模式（Decorator）</h3><p>装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。</p>
<p>给一类对象增加新的功能，装饰方法与具体的内部逻辑无关。例如：</p>
<pre><code>interface Source{ void method();}
public class Decorator implements Source{

    private Source source ;
    public void decotate1(){
        System.out.println(&quot;decorate&quot;);
    }
    @Override
    public void method() {
        decotate1();
        source.method();
    }
}
</code></pre><h3 id="10、外观模式（Facade）"><a href="#10、外观模式（Facade）" class="headerlink" title="10、外观模式（Facade）"></a>10、外观模式（Facade）</h3><p>门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。</p>
<pre><code>public class Facade {
    private subSystem1 subSystem1 = new subSystem1();
    private subSystem2 subSystem2 = new subSystem2();
    private subSystem3 subSystem3 = new subSystem3();

    public void startSystem(){
        subSystem1.start();
        subSystem2.start();
        subSystem3.start();
    }

    public void stopSystem(){
        subSystem1.stop();
        subSystem2.stop();
        subSystem3.stop();
    }
}
</code></pre><h3 id="11、享元模式（Flyweight）"><a href="#11、享元模式（Flyweight）" class="headerlink" title="11、享元模式（Flyweight）"></a>11、享元模式（Flyweight）</h3><p>享元模式：FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。</p>
<pre><code>abstract class flywei{ }

public class Flyweight extends flywei{
    Object obj ;
    public Flyweight(Object obj){
        this.obj = obj;
    }
}

class  FlyweightFactory{
    private HashMap&lt;Object,Flyweight&gt; data;

    public FlyweightFactory(){ data = new HashMap&lt;&gt;();}

    public Flyweight getFlyweight(Object object){
        if ( data.containsKey(object)){
            return data.get(object);
        }else {
            Flyweight flyweight = new Flyweight(object);
            data.put(object,flyweight);
            return flyweight;
        }
    }
}
</code></pre><h3 id="12、代理模式（Proxy）"><a href="#12、代理模式（Proxy）" class="headerlink" title="12、代理模式（Proxy）"></a>12、代理模式（Proxy）</h3><p>代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。</p>
<pre><code>interface Source{ void method();}

class OldClass implements Source{
    @Override
    public void method() {
    }
}

class Proxy implements Source{
    private Source source = new OldClass();

    void doSomething(){}
    @Override
    public void method() {
        new Class1().Func1();
        source.method();
        new Class2().Func2();
        doSomething();
    }
}
</code></pre><h2 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h2><h3 id="13、chain-of-responsibleity"><a href="#13、chain-of-responsibleity" class="headerlink" title="13、chain of responsibleity"></a>13、chain of responsibleity</h3><p>责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接</p>
<p>起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。</p>
<h3 id="14、command"><a href="#14、command" class="headerlink" title="14、command"></a>14、command</h3><p>命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。</p>
<h3 id="15、interpreter"><a href="#15、interpreter" class="headerlink" title="15、interpreter"></a>15、interpreter</h3><p>解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。</p>
<h3 id="16、iterator"><a href="#16、iterator" class="headerlink" title="16、iterator"></a>16、iterator</h3><p>迭代子模式：迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。</p>
<h3 id="17、mediator"><a href="#17、mediator" class="headerlink" title="17、mediator"></a>17、mediator</h3><p>调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>
<h3 id="18、memento"><a href="#18、memento" class="headerlink" title="18、memento"></a>18、memento</h3><p>备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</p>
<h3 id="19、observer"><a href="#19、observer" class="headerlink" title="19、observer"></a>19、observer</h3><p>观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。</p>
<h3 id="20、state"><a href="#20、state" class="headerlink" title="20、state"></a>20、state</h3><p>状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</p>
<h3 id="21、strategy"><a href="#21、strategy" class="headerlink" title="21、strategy"></a>21、strategy</h3><p>策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模式把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。</p>
<h3 id="22、template-method"><a href="#22、template-method" class="headerlink" title="22、template method"></a>22、template method</h3><p>模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</p>
<h3 id="23、visitor"><a href="#23、visitor" class="headerlink" title="23、visitor"></a>23、visitor</h3><p>访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。</p>

      
    </div><!-- .entry-content -->
    <!-- busuanzi  start -->
    
    <!-- busuanzi  end -->

    <footer class="entry-meta">
    <a href="/2021/11/10/关于Java 23种设计模式/">
    <time datetime="2021-11-10T01:59:51.581Z" class="entry-date">
        2021-11-10
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-java生命周期" class="post-java生命周期 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2021/11/10/java生命周期/">java生命周期</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2021/11/10/java生命周期/" data-id="clesbyv2g004xpsiafy9f7146" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>引言</p>
<pre><code>最近有位细心的朋友在阅读笔者的文章时，对java类的生命周期问题有一些疑惑，笔者打开百度搜了一下相关的问题，看到网上的资料很少有把这个问题讲明白的，主要是因为目前国内java方面的教材大多只是告诉你“怎样做”，但至于“为什么这样做”却不多说，所以造成大家在基础和原理方面的知识比较匮乏，所以笔者今天就斗胆来讲一下这个问题，权当抛砖引玉，希望对在这个问题上有疑惑的朋友有所帮助，文中有说的不对的地方，也希望各路高手前来指正。

方法区：在java的虚拟机中有一块专门用来存放已经加载的类信息、常量、静态变量以及方法代码的内存区域，叫做方法区。
常量池：常量池是方法区的一部分，主要用来存放常量和类中的符号引用等信息。
堆区：用于存放类的对象实例。
栈区：也叫java虚拟机栈，是由一个一个的栈帧组成的后进先出的栈式结构，栈桢中存放方法运行时产生的局部变量、方法出口等信息。当调用一个方法时，虚拟机栈中就会创建一个栈帧存放这些数据，当方法调用完成时，栈帧消失，如果方法中调用了其他方法，则继续在栈顶创建新的栈桢。
</code></pre><p>除了以上四个内存区域之外，jvm中的运行时内存区域还包括本地方法栈和程序计数器</p>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>当我们编写一个java的源文件后，经过编译会生成一个后缀名为class的文件，这种文件叫做字节码文件，只有这种字节码文件才能够在java虚拟机中运行，java类的生命周期就是指一个class文件从加载到卸载的全过程。</p>
<p>一个java类的完整的生命周期会经历加载、连接、初始化、使用、和卸载五个阶段，当然也有在加载或者连接之后没有被初始化就直接被使用的情况，如图所示：<br><img src="/assets/javaImg/lifeCycle.jpg" alt="Image text"></p>
<p>下面我们就依次来说一说这五个阶段。</p>
<p>加载</p>
<p>在java中，我们经常会接触到一个词——类加载，它和这里的加载并不是一回事，通常我们说类加载指的是类的生命周期中加载、连接、初始化三个阶段。在加载阶段，java虚拟机会做什么工作呢？其实很简单，就是找到需要加载的类并把类的信息加载到jvm的方法区中，然后在堆区中实例化一个java.lang.Class对象，作为方法区中这个类的信息的入口。</p>
<p>类的加载方式比较灵活，我们最常用的加载方式有两种，一种是根据类的全路径名找到相应的class文件，然后从class文件中读取文件内容；另一种是从jar文件中读取。另外，还有下面几种方式也比较常用：</p>
<pre><code>从网络中获取：比如10年前十分流行Applet。
根据一定的规则实时生成，比如设计模式中的动态代理模式，就是根据相应的类自动生成它的代理类。
从非class文件中获取，其实这与直接从class文件中获取的方式本质上是一样的，这些非class文件在jvm中运行之前会被转换为可被jvm所识别的字节码文件。
</code></pre><p>对于加载的时机，各个虚拟机的做法并不一样，但是有一个原则，就是当jvm“预期”到一个类将要被使用时，就会在使用它之前对这个类进行加载。比如说，在一段代码中出现了一个类的名字，jvm在执行这段代码之前并不能确定这个类是否会被使用到，于是，有些jvm会在执行前就加载这个类，而有些则在真正需要用的时候才会去加载它，这取决于具体的jvm实现。我们常用的hotspot虚拟机是采用的后者，就是说当真正用到一个类的时候才对它进行加载。</p>
<p>加载阶段是类的生命周期中的第一个阶段，加载阶段之后，是连接阶段。有一点需要注意，就是有时连接阶段并不会等加载阶段完全完成之后才开始，而是交叉进行，可能一个类只加载了一部分之后，连接阶段就已经开始了。但是这两个阶段总的开始时间和完成时间总是固定的：加载阶段总是在连接阶段之前开始，连接阶段总是在加载阶段完成之后完成。</p>
<p>连接</p>
<p>连接阶段比较复杂，一般会跟加载阶段和初始化阶段交叉进行，这个阶段的主要任务就是做一些加载后的验证工作以及一些初始化前的准备工作，可以细分为三个步骤：验证、准备和解析。</p>
<p>1、验证：当一个类被加载之后，必须要验证一下这个类是否合法，比如这个类是不是符合字节码的格式、变量与方法是不是有重复、数据类型是不是有效、继承与实现是否合乎标准等等。总之，这个阶段的目的就是保证加载的类是能够被jvm所运行。</p>
<p>2、准备：准备阶段的工作就是为类的静态变量分配内存并设为jvm默认的初值，对于非静态的变量，则不会为它们分配内存。有一点需要注意，这时候，静态变量的初值为jvm默认的初值，而不是我们在程序中设定的初值。jvm默认的初值是这样的：</p>
<pre><code>基本类型（int、long、short、char、byte、boolean、float、double）的默认值为0。
引用类型的默认值为null。
常量的默认值为我们程序中设定的值，比如我们在程序中定义final static int a = 100，则准备阶段中a的初值就是100。
</code></pre><p>3、解析：这一阶段的任务就是把常量池中的符号引用转换为直接引用。那么什么是符号引用，什么又是直接引用呢？我们来举个例子：我们要找一个人，我们现有的信息是这个人的身份证号是1234567890。只有这个信息我们显然找不到这个人，但是通过公安局的身份系统，我们输入1234567890这个号之后，就会得到它的全部信息：比如安徽省黄山市余暇村18号张三，通过这个信息我们就能找到这个人了。这里，123456790就好比是一个符号引用，而安徽省黄山市余暇村18号张三就是直接引用。在内存中也是一样，比如我们要在内存中找一个类里面的一个叫做show的方法，显然是找不到。但是在解析阶段，jvm就会把show这个名字转换为指向方法区的的一块内存地址，比如c17164，通过c17164就可以找到show这个方法具体分配在内存的哪一个区域了。这里show就是符号引用，而c17164就是直接引用。在解析阶段，jvm会将所有的类或接口名、字段名、方法名转换为具体的内存地址。</p>
<p>4、连接阶段完成之后会根据使用的情况（直接引用还是被动引用）来选择是否对类进行初始化。</p>
<p>初始化</p>
<p>如果一个类被直接引用，就会触发类的初始化。在java中，直接引用的情况有：</p>
<p>通过new关键字实例化对象、读取或设置类的静态变量、调用类的静态方法。</p>
<p>通过反射方式执行以上三种行为。</p>
<p>初始化子类的时候，会触发父类的初始化。</p>
<p>作为程序入口直接运行时（也就是直接调用main方法）。</p>
<p>除了以上四种情况，其他使用类的方式叫做被动引用，而被动引用不会触发类的初始化。请看主动引用的示例代码：</p>
<pre><code>import java.lang.reflect.Field;  
import java.lang.reflect.Method;  

class InitClass{  
    static {  
        System.out.println(&quot;初始化InitClass&quot;);  
    }  
    public static String a = null;  
    public static void method(){}  
}  

class SubInitClass extends InitClass{}  

public class Test1 {  

    /**  
     * 主动引用引起类的初始化的第四种情况就是运行Test1的main方法时  
     * 导致Test1初始化，这一点很好理解，就不特别演示了。  
     * 本代码演示了前三种情况，以下代码都会引起InitClass的初始化，  
     * 但由于初始化只会进行一次，运行时请将注解去掉，依次运行查看结果。  
     * @param args  
     * @throws Exception  
     */ 
    public static void main(String[] args) throws Exception{  
    //  主动引用引起类的初始化一: new对象、读取或设置类的静态变量、调用类的静态方法。  
    //  new InitClass();  
    //  InitClass.a = &quot;&quot;;  
    //  String a = InitClass.a;  
    //  InitClass.method();  

    //  主动引用引起类的初始化二：通过反射实例化对象、读取或设置类的静态变量、调用类的静态方法。  
    //  Class cls = InitClass.class;  
    //  cls.newInstance();  

    //  Field f = cls.getDeclaredField(&quot;a&quot;);  
    //  f.get(null);  
    //  f.set(null, &quot;s&quot;);  

    //  Method md = cls.getDeclaredMethod(&quot;method&quot;);  
    //  md.invoke(null, null);  

    //  主动引用引起类的初始化三：实例化子类，引起父类初始化。  
    //  new SubInitClass();  

    }  
} 
</code></pre><p>上面的程序演示了主动引用触发类的初始化的四种情况。</p>
<p>类的初始化过程是这样的：按照顺序自上而下运行类中的变量赋值语句和静态语句，如果有父类，则首先按照顺序运行父类中的变量赋值语句和静态语句。先看一个例子，首先建两个类用来显示赋值操作：</p>
<pre><code>public class Field1{  
    public Field1(){  
        System.out.println(&quot;Field1构造方法&quot;);  
    }  
}  
public class Field2{  
    public Field2(){  
        System.out.println(&quot;Field2构造方法&quot;);  
    }  
}  
</code></pre><p>下面是演示初始化顺序的代码：</p>
<pre><code>class InitClass2{  
    static{  
        System.out.println(&quot;运行父类静态代码&quot;);  
    }  
    public static Field1 f1 = new Field1();  
    public static Field1 f2;   
}  

class SubInitClass2 extends InitClass2{  
    static{  
        System.out.println(&quot;运行子类静态代码&quot;);  
    }  
    public static Field2 f2 = new Field2();  
}  

public class Test2 {  
    public static void main(String[] args) throws ClassNotFoundException{  
        new SubInitClass2();  
    }  
} 
</code></pre><p>上面的代码中，初始化的顺序是：第03行，第05行，第11行，第13行。第04行是声明操作，没有赋值，所以不会被运行。而下面的代码：</p>
<pre><code>class InitClass2{  
    public static Field1 f1 = new Field1();  
    public static Field1 f2;  
    static{  
        System.out.println(&quot;运行父类静态代码&quot;);  
    }  
}  

class SubInitClass2 extends InitClass2{  
    public static Field2 f2 = new Field2();  
    static{  
        System.out.println(&quot;运行子类静态代码&quot;);  
    }  
}  

public class Test2 {  
    public static void main(String[] args) throws ClassNotFoundException{  
        new SubInitClass2();  
    }  
}  
</code></pre><p>初始化顺序为：第02行、第05行、第10行、第12行，各位可以运行程序查看结果。</p>
<p>在类的初始化阶段，只会初始化与类相关的赋值语句和静态语句，也就是有static关键字修饰的信息，没有static修饰的赋值语句和静态语句在实例化对象的时候才会运行。</p>
<p>使用</p>
<p>类的使用包括主动引用和被动引用，主动引用在初始化的章节中已经说过了，下面我们主要来说一下被动引用：</p>
<pre><code>引用父类的静态字段，只会引起父类的初始化，而不会引起子类的初始化。
定义类数组，不会引起类的初始化。
引用类的常量，不会引起类的初始化。
</code></pre><p>被动引用的示例代码：</p>
<pre><code>class InitClass{  
    static {  
        System.out.println(&quot;初始化InitClass&quot;);  
    }  
    public static String a = null;  
    public final static String b = &quot;b&quot;;  
    public static void method(){}  
}  

class SubInitClass extends InitClass{  
    static {  
        System.out.println(&quot;初始化SubInitClass&quot;);  
    }  
}  

public class Test4 {  

    public static void main(String[] args) throws Exception{  
    //  String a = SubInitClass.a;// 引用父类的静态字段，只会引起父类初始化，而不会引起子类的初始化  
    //  String b = InitClass.b;// 使用类的常量不会引起类的初始化  
        SubInitClass[] sc = new SubInitClass[10];// 定义类数组不会引起类的初始化  
    }  
}  
</code></pre><p>最后总结一下使用阶段：使用阶段包括主动引用和被动引用，主动饮用会引起类的初始化，而被动引用不会引起类的初始化。</p>
<p>当使用阶段完成之后，java类就进入了卸载阶段。</p>
<p>卸载</p>
<p>关于类的卸载，笔者在单例模式讨论篇：单例模式与垃圾回收一文中有过描述，在类使用完之后，如果满足下面的情况，类就会被卸载：</p>
<p>该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。</p>
<p>加载该类的ClassLoader已经被回收。</p>
<p>该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
<p>如果以上三个条件全部满足，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，java类的整个生命周期就结束了。</p>
<p>总结</p>
<p>做java的朋友对于对象的生命周期可能都比较熟悉，对象基本上都是在jvm的堆区中创建，在创建对象之前，会触发类加载（加载、连接、初始化），当类初始化完成后，根据类信息在堆区中实例化类对象，初始化非静态变量、非静态代码以及默认构造方法，当对象使用完之后会在合适的时候被jvm垃圾收集器回收。读完本文后我们知道，对象的生命周期只是类的生命周期中使用阶段的主动引用的一种情况（即实例化类对象）。而类的整个生命周期则要比对象的生命周期长的多。</p>
<p>原文链接：<a href="http://blog.csdn.net/zhengzhb/article/details/7517213" target="_blank" rel="noopener">http://blog.csdn.net/zhengzhb/article/details/7517213</a></p>

      
    </div><!-- .entry-content -->
    <!-- busuanzi  start -->
    
    <!-- busuanzi  end -->

    <footer class="entry-meta">
    <a href="/2021/11/10/java生命周期/">
    <time datetime="2021-11-10T01:59:50.894Z" class="entry-date">
        2021-11-10
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-webpack-spritesmith" class="post-webpack-spritesmith post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2020/09/03/webpack-spritesmith/">webpack中如何使用雪碧图</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2020/09/03/webpack-spritesmith/" data-id="clesbyv1q0037psia1cane7vy" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>一、什么是雪碧图？</p>
<pre><code>CSS雪碧 即CSS Sprite，也有人叫它CSS精灵，是一种CSS图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分。
</code></pre><p>二：为什么要用雪碧图<br>在开发过程中，我们需要用到很多图标，这些图标大小不是很大，但是每张图是一个请求加重服务器负担，这样是很可怕的，所以为了优化性能，减少http请求，决定采用雪碧图的形式。</p>
<p>雪碧图是将你想要的很多张图片整理成一张图片，然后通过icon-*来进行图片识别和定位来达到之前的效果。<br>三：如何使用雪碧图</p>
<p>雪碧图在之前有很多方式，如ps之类，现在最佳的方案还是在webpack-spritesmith。</p>
<p>我其实对webpack并不是很了解，我现在列出使用方法和我在使用webpack时候遇到的问题。<br>1.安装</p>
<p>执行命令行：npm install –save-dev webpack-spritesmith<br>2.在webpack.config.js中写入</p>

      
    </div><!-- .entry-content -->
    <!-- busuanzi  start -->
    
    <!-- busuanzi  end -->

    <footer class="entry-meta">
    <a href="/2020/09/03/webpack-spritesmith/">
    <time datetime="2020-09-03T07:49:55.000Z" class="entry-date">
        2020-09-03
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-work-wechat-start" class="post-work-wechat-start post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2020/08/13/work-wechat-start/">企业微信小程序开发流程</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2020/08/13/work-wechat-start/" data-id="clesbyv1r0038psiamquc29t7" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>为其他公司开发一个小程序，这个小程序要只能在企业微信里面访问，不能通过普通微信访问。</p>
<p>企业微信里只有授权的用户可以使用该小程序</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>首先，这里面需要解决几个问题：</p>
<p>1、只在企业微信里使用，不能在普通小程序使用</p>
<pre><code>判断当前运行环境
</code></pre><p>2、只有授权的用户可以使用该小程序</p>
<pre><code>权限校验

1：普通微信，使用账号+密码登陆，审核专用，可限制账号权限

2：企业微信，校验企业id，校验用户id，有权限的才允许使用
</code></pre><p>3、控制搜索</p>
<pre><code>在小程序管理后台设置「不允许被搜索」
</code></pre><p>4、控制分享</p>
<pre><code>小程序里面关闭分享
</code></pre><p>OK，做到以上几点，就实现了只有企业微信里授权的用户，才能够在企业微信的 工作台 看到该小程序。</p>
<h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><h3 id="1、小程序基础功能开发，提交审核"><a href="#1、小程序基础功能开发，提交审核" class="headerlink" title="1、小程序基础功能开发，提交审核"></a>1、小程序基础功能开发，提交审核</h3><p>对，没看错，先提交审核，因为只有审核通过的小程序才能被企业微信绑定。所以，先把小程序的基础功能做出来，可以限制一部分功能，总之，就是先让这个小程序上架。同时，在小程序的管理后台设置「不允许被搜索」，避免不必要的麻烦。</p>
<h3 id="2、企业微信关联小程序"><a href="#2、企业微信关联小程序" class="headerlink" title="2、企业微信关联小程序"></a>2、企业微信关联小程序</h3><p>进入企业微信后台 -&gt; 应用管理 -&gt; 小程序 -&gt; 关联小程序，然后使用小程序管理员的微信扫码，按照指引操作即可。</p>
<h3 id="3、获取关联小程序的-Secret，设置可见范围"><a href="#3、获取关联小程序的-Secret，设置可见范围" class="headerlink" title="3、获取关联小程序的 Secret，设置可见范围"></a>3、获取关联小程序的 Secret，设置可见范围</h3><p>上一步的小程序页面会出现刚才关联的小程序，点击进入，然后就看到 secret 及可见范围。</p>
<p>这个 secret 相当于该小程序访问该企业微信数据的令牌，请妥善保存。</p>
<p>可见范围就是授权，哪些用户能看到这个小程序，被设置可见的人将会在自己企业微信的工作台看到该小程序。</p>
<h3 id="4、修改小程序"><a href="#4、修改小程序" class="headerlink" title="4、修改小程序"></a>4、修改小程序</h3><h4 id="4-1、判断运行环境"><a href="#4-1、判断运行环境" class="headerlink" title="4.1、判断运行环境"></a>4.1、判断运行环境</h4><p>小程序需要判断当前的运行环境（普通微信 or 企业微信），需要判断使用当前小程序的用户是否有权限使用。</p>
<pre><code>var isWxWork = false;
wx.getSystemInfo({
  success(res) {
    console.log(res.environment);

    isWxWork = res.environment == &apos;wxwork&apos;;
    if (!isWxWork) {
        // 当前环境不是企业微信，怎么处理你随便
        return;
    }

    // 当前环境是企业微信，执行登陆，获取用户 code，用于后面的权限校验
    wx.qy.login({
      success: function (res) {
        if (res.code) {
            console.log(res.code);

            // 这里可以将 res.code 通过请求发送给后台，让后台做权限校验
        } else {
            console.log(&apos;登录失败！&apos; + res.errMsg);
        }
      }
    });
  }
})
</code></pre><h4 id="4-2、权限校验"><a href="#4-2、权限校验" class="headerlink" title="4.2、权限校验"></a>4.2、权限校验</h4><p>后台需要调用以下几个接口来进行权限校验。</p>
<p>1、获取 access_token</p>
<pre><code>https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=xxxx&amp;corpsecret=xxxx

请求方式：GET
</code></pre><p>这个接口和普通微信获取 token 的方法类似。</p>
<p>其中，corpid 在企业微信管理后台-&gt;我的企业-&gt;企业信息-&gt;企业ID；corpsecret 就是我们上一步关联小程序后获取的 secret。</p>
<p>返回内容如下：</p>
<pre><code>{
    &quot;errcode&quot;: 0,
    &quot;errmsg&quot;: &quot;ok&quot;,
    &quot;access_token&quot;: &quot;xxxxxx&quot;,
    &quot;expires_in&quot;: 7200
}
</code></pre><p>2、获取 userid</p>
<pre><code>https://qyapi.weixin.qq.com/cgi-bin/miniprogram/jscode2session?access_token=xxx&amp;js_code=xxx&amp;grant_type=authorization_code

请求方式：GET
</code></pre><p>其中，access_token 是我们前一步 gettoken 获取到的；js_code 是前面判断运行环境时获取到的 res.code；grant_type 固定传 authorization_code</p>
<p>返回内容如下：</p>
<pre><code>{
    &quot;userid&quot;: &quot;bottle&quot;,
    &quot;session_key&quot;: &quot;xxxxx&quot;,
    &quot;corpid&quot;: &quot;xxxxxx&quot;,
    &quot;deviceid&quot;: &quot;xxxxxx&quot;,
    &quot;errcode&quot;: 0,
    &quot;errmsg&quot;: &quot;ok&quot;
}
</code></pre><p>这里的 corpid 可以用来初步校验当前用户是否有权限，因为无论哪个公司的人，只要他用企业微信，使用这个小程序，都会返回这样的结果，你需要根据 corpid 是否是你授权的企业的ID来校验，如果不是，直接返回无权限就可以，不用进行下一步。</p>
<p>当然 corpid 也可以用于处理一个小程序关联多家公司的情况，不过这是另一个问题了。这里简单提一嘴，因为是给其他公司开发的小程序，所以我们这个小程序也关联了两个企业，一个我们公司，一个对方公司，这样也方便我们测试，只需要给我们自己的测试人员授权就可以让他们使用完全相同的环境进行测试了。</p>
<p>3、获取用户信息（判断权限）</p>
<pre><code>https://qyapi.weixin.qq.com/cgi-bin/user/get?access_token=xxx&amp;userid=xxx

请求方式：GET
</code></pre><p>其中，access_token 是我们前一步 gettoken 获取到的；userid 就是我们上一步获取到的 userid。</p>
<p>返回内容如下：</p>
<ul>
<li>有权限</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;errcode&quot;: 0,</span><br><span class="line">    &quot;errmsg&quot;: &quot;ok&quot;,</span><br><span class="line">    &quot;userid&quot;: &quot;xxx&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;xxx&quot;,</span><br><span class="line">    &quot;department&quot;: [],</span><br><span class="line">    &quot;position&quot;: &quot;&quot;,</span><br><span class="line">    &quot;mobile&quot;: &quot;xxx&quot;,</span><br><span class="line">    &quot;gender&quot;: &quot;2&quot;,</span><br><span class="line">    &quot;email&quot;: &quot;&quot;,</span><br><span class="line">    &quot;avatar&quot;: &quot;http://p.qlogo.cn/bizmail/xxx/0&quot;,</span><br><span class="line">    &quot;status&quot;: 1,</span><br><span class="line">    &quot;isleader&quot;: 0,</span><br><span class="line">    &quot;extattr&quot;: &#123;</span><br><span class="line">        &quot;attrs&quot;: []</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;telephone&quot;: &quot;&quot;,</span><br><span class="line">    &quot;enable&quot;: 1,</span><br><span class="line">    &quot;hide_mobile&quot;: 0,</span><br><span class="line">    &quot;order&quot;: [],</span><br><span class="line">    &quot;qr_code&quot;: &quot;https://open.work.weixin.qq.com/wwopen/userQRCode?vcode=xxx&quot;,</span><br><span class="line">    &quot;alias&quot;: &quot;&quot;,</span><br><span class="line">    &quot;is_leader_in_dept&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>无权限</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;errcode&quot;: 60011,</span><br><span class="line">    &quot;errmsg&quot;: &quot;no privilege to access/modify contact/party/agent , hint: [1564556097_7_8d45297bd21be3702ff430560e1f0652], from ip: 118.113.1.217, more info at https://open.work.weixin.qq.com/devtool/query?e=60011&quot;,</span><br><span class="line">    &quot;department&quot;: [],</span><br><span class="line">    &quot;order&quot;: [],</span><br><span class="line">    &quot;is_leader_in_dept&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，后面根据有权限还是无权限，执行不同的操作就可以了，这里不再赘述。</p>
<p>参考资料</p>
<p>企业微信API（小程序）：<a href="https://work.weixin.qq.com/api/doc#90000/90136/90289" target="_blank" rel="noopener">https://work.weixin.qq.com/api/doc#90000/90136/90289</a></p>
<p>企业微信接口调试工具：<a href="https://work.weixin.qq.com/api/devtools/devtool.php" target="_blank" rel="noopener">https://work.weixin.qq.com/api/devtools/devtool.php</a></p>
<p>错误码查询工具：<a href="https://open.work.weixin.qq.com/devtool/query" target="_blank" rel="noopener">https://open.work.weixin.qq.com/devtool/query</a></p>

      
    </div><!-- .entry-content -->
    <!-- busuanzi  start -->
    
    <!-- busuanzi  end -->

    <footer class="entry-meta">
    <a href="/2020/08/13/work-wechat-start/">
    <time datetime="2020-08-13T02:15:41.000Z" class="entry-date">
        2020-08-13
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/WeCaht/">WeCaht</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-node-process-argv" class="post-node-process-argv post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2020/08/11/node-process-argv/">node.js获取命令参数</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2020/08/11/node-process-argv/" data-id="clesbyv1c002apsiagxgfwtb1" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="新建-process-js"><a href="#新建-process-js" class="headerlink" title="新建 process.js"></a>新建 process.js</h2><pre><code># 代码
var params = process.argv.splice(2);
console.log(params);

# 执行
$ node process.js a b c d
# 输出
[ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos; ]
</code></pre><ol>
<li>process是一个全局对象，argv返回的是一组包含命令行参数的数组。</li>
<li>第一项为”node”，第二项为执行的js的完整路径，后面是附加在命令行后的参数。</li>
<li>多个参数用空格隔，process.argv.splice(2)获取的是一个数组，[0]表示第一个参数，以此类推</li>
</ol>

      
    </div><!-- .entry-content -->
    <!-- busuanzi  start -->
    
    <!-- busuanzi  end -->

    <footer class="entry-meta">
    <a href="/2020/08/11/node-process-argv/">
    <time datetime="2020-08-11T07:18:56.000Z" class="entry-date">
        2020-08-11
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Node/">Node</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-github-hosts" class="post-github-hosts post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2020/08/05/github-hosts/">GitHub 访问加速方法</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2020/08/05/github-hosts/" data-id="clesbyv0q001fpsiasghe5dns" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>国内的 GitHub 无论是打开，还是下载都挺慢，我参考网上的方法修改 host 文件，提升了速度</p>
<h2 id="1-打开-hosts-文件"><a href="#1-打开-hosts-文件" class="headerlink" title="1. 打开 hosts 文件"></a>1. 打开 hosts 文件</h2><p>首先打开路径 C:\Windows\System32\drivers\etc 下的 hosts 文件（需要管理员身份）</p>
<p>注意：</p>
<p>windows系统的hosts文件的位置如下：C:\Windows\System32\drivers\etc\hosts</p>
<p>mac/linux系统的hosts文件的位置如下：/etc/hosts</p>
<h2 id="2-查询-IP"><a href="#2-查询-IP" class="headerlink" title="2. 查询 IP"></a>2. 查询 IP</h2><p>访问：<a href="https://www.ipaddress.com/ip-lookup" target="_blank" rel="noopener">https://www.ipaddress.com/ip-lookup</a></p>
<p>在输入框分别输入下面名称，查询它们对应的 IP 地址：</p>
<pre><code>github.com
gist.github.com
github.global.ssl.fastly.net
raw.githubusercontent.com
</code></pre><p>  <img src="/assets/common/github-hosts.jpg" alt="image"></p>
<h2 id="3-修改-hosts-文件"><a href="#3-修改-hosts-文件" class="headerlink" title="3. 修改 hosts 文件"></a>3. 修改 hosts 文件</h2><p>  添加到末尾</p>
<pre><code>140.82.112.3 github.com
140.82.113.4 gist.github.com
199.232.69.194 github.global.ssl.fastly.net
199.232.68.133 raw.githubusercontent.com
</code></pre>
      
    </div><!-- .entry-content -->
    <!-- busuanzi  start -->
    
    <!-- busuanzi  end -->

    <footer class="entry-meta">
    <a href="/2020/08/05/github-hosts/">
    <time datetime="2020-08-05T09:39:37.000Z" class="entry-date">
        2020-08-05
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/github/">github</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-vscode-settings-sync" class="post-vscode-settings-sync post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2020/08/05/vscode-settings-sync/">vscode-settings-sync</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2020/08/05/vscode-settings-sync/" data-id="clesbyv1j002npsiag9y28r67" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>网上很多同步教程，按照教程操作upload时一直报错：sync:invalid gist ID</p>
<p>查找问题很久才知道 gist和token是两个东西。下面重新梳理下：</p>
<h2 id="一、下载安装插件-Setting-sync"><a href="#一、下载安装插件-Setting-sync" class="headerlink" title="一、下载安装插件 Setting sync"></a>一、下载安装插件 Setting sync</h2><h2 id="二、GitHub-上生成-token"><a href="#二、GitHub-上生成-token" class="headerlink" title="二、GitHub 上生成 token"></a>二、GitHub 上生成 token</h2><p>  <img src="/assets/vscodeSync/vscode-sync-token-1.jpg" alt="image"><br>  <img src="/assets/vscodeSync/vscode-sync-token-2.jpg" alt="image"><br>  <img src="/assets/vscodeSync/vscode-sync-token-3.jpg" alt="image"><br>  <img src="/assets/vscodeSync/vscode-sync-token-4.jpg" alt="image"><br>  <img src="/assets/vscodeSync/vscode-sync-token-5.jpg" alt="image"><br>  <img src="/assets/vscodeSync/vscode-sync-token-6.jpg" alt="image"></p>
<h2 id="三、GitHub-上生成-gist"><a href="#三、GitHub-上生成-gist" class="headerlink" title="三、GitHub 上生成 gist"></a>三、GitHub 上生成 gist</h2><p><img src="/assets/vscodeSync/vscode-sync-gist-1.jpg" alt="image"><br>进入 your gists<br><img src="/assets/vscodeSync/vscode-sync-gist-2.jpg" alt="image"><br>随便给自己的gist起个名，添加内容，然后”Create secret gist”<br><img src="/assets/vscodeSync/vscode-sync-gist-3.jpg" alt="image"><br>上图中的1ab3dd43250115fac4fddb64f2f45830就是gist id</p>
<h2 id="四、vscode配置gist和token"><a href="#四、vscode配置gist和token" class="headerlink" title="四、vscode配置gist和token"></a>四、vscode配置gist和token</h2><p>vscode里：<br>    1,、Ctrl + P调出命令框<br>    2、输入&gt;sync:advanced option<br>    3、找到打开设置<br>    4、出现下面的设置界面<br>    5、shift+alt+u ：将本地配置上传到github上<br>    6、在其他设备上，下载sync插件，shift+alt+d ：从github上下载配置到本地</p>
<p><img src="/assets/vscodeSync/vscode-sync-config.jpg" alt="image"></p>

      
    </div><!-- .entry-content -->
    <!-- busuanzi  start -->
    
    <!-- busuanzi  end -->

    <footer class="entry-meta">
    <a href="/2020/08/05/vscode-settings-sync/">
    <time datetime="2020-08-05T08:51:25.000Z" class="entry-date">
        2020-08-05
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/vscode/">vscode</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-java-getstarted" class="post-java-getstarted post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2020/08/04/java-getstarted/">下载、安装、配置和调试 JDK</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2020/08/04/java-getstarted/" data-id="clesbyv0q001npsia99qzoetl" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>本章介绍了如何下载、安装、配置和调试 JDK</p>
<h2 id="下载、安装-JDK"><a href="#下载、安装-JDK" class="headerlink" title="下载、安装 JDK"></a>下载、安装 JDK</h2><p>JDK(Java Development Kit)是用于 Java 开发的工具箱。</p>
<p>在<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a>下载</p>
<p>JDK 支持如下操作系统的安装：</p>
<table>
<thead>
<tr>
<th>操作系统类型</th>
<th>文件大小</th>
<th>文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linux x86</td>
<td>154.67 MB</td>
<td>jdk-8u66-linux-i586.rpm</td>
</tr>
<tr>
<td>Linux x86</td>
<td>174.83 MB</td>
<td>jdk-8u66-linux-i586.tar.gz</td>
</tr>
<tr>
<td>Linux x64</td>
<td>152.69 MB</td>
<td>jdk-8u66-linux-x64.rpm</td>
</tr>
<tr>
<td>Linux x64</td>
<td>172.89 MB</td>
<td>jdk-8u66-linux-x64.tar.gz</td>
</tr>
<tr>
<td>Mac OS X x64</td>
<td>227.12 MB</td>
<td>jdk-8u66-macosx-x64.dmg</td>
</tr>
<tr>
<td>Solaris SPARC 64-bit (SVR4 package)</td>
<td>139.65 MB</td>
<td>jdk-8u66-solaris-sparcv9.tar.</td>
</tr>
<tr>
<td>Solaris SPARC 64-bit</td>
<td>99.05 MB</td>
<td>jdk-8u66-solaris-sparcv9.tar.g</td>
</tr>
<tr>
<td>Solaris x64 (SVR4 package)</td>
<td>140 MB</td>
<td>jdk-8u66-solaris-x64.tar.Z</td>
</tr>
<tr>
<td>Solaris x64</td>
<td>96.2 MB</td>
<td>jdk-8u66-solaris-x64.tar.gz</td>
</tr>
<tr>
<td>Windows x86</td>
<td>181.33 MB</td>
<td>jdk-8u66-windows-i586.exe</td>
</tr>
<tr>
<td>Windows x64</td>
<td>186.65 MB</td>
<td>jdk-8u66-windows-x64.exe</td>
</tr>
</tbody>
</table>
<p>安装路径默认安装在 C:\Program Files\Java\jdk1.8.0_66 或者 usr/local/java/jdk1.8.0_66</p>
<h2 id="基于-RPM-的-Linux"><a href="#基于-RPM-的-Linux" class="headerlink" title="基于 RPM 的 Linux"></a>基于 RPM 的 Linux</h2><ul>
<li>下载安装文件<br>文件名类似于jdk-8uversion-linux-x64.rpm。</li>
<li>切换到 root 用户身份</li>
<li>检查当前的安装情况。卸载老版本的 JDK</li>
</ul>
<p>检查当前的安装情况，比如：</p>
<pre><code>$rpm -qa | grep  jdk
jdk1.8.0_102-1.8.0_102-fcs.x86_64
</code></pre><p>若有老版本 JDK，则需先卸载老版本：</p>
<pre><code>$rpm -e package_name
</code></pre><p>比如：</p>
<pre><code>$rpm -e jdk1.8.0_102-1.8.0_102-fcs.x86_64
</code></pre><ul>
<li><p>安装</p>
<p>  $ rpm -ivh jdk-8uversion-linux-x64.rpm</p>
</li>
</ul>
<p>比如：</p>
<pre><code>$ rpm -ivh jdk-8u102-linux-x64.rpm
Preparing...                ########################################### [100%]
  1:jdk1.8.0_102           ########################################### [100%]
Unpacking JAR files...
    tools.jar...
    plugin.jar...
    javaws.jar...
    deploy.jar...
    rt.jar...
    jsse.jar...
    charsets.jar...
    localedata.jar...
</code></pre><ul>
<li><p>升级</p>
<p>  $ rpm -Uvh jdk-8uversion-linux-x64.rpm</p>
</li>
</ul>
<p>安装完成后，可以删除.rpm文件，以节省空间。 安装完后，无需重启主机，即可使用 JDK。</p>
<h2 id="设置执行路径"><a href="#设置执行路径" class="headerlink" title="设置执行路径"></a>设置执行路径</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>增加一个 JAVA_HOME 环境变量，值是 JDK 的安装目录。如 C:\Program Files\Java\jdk1.8.0_66 ，注意后边不带分号</p>
<p>在 PATH 的环境变量里面增加 %JAVA_HOME%\bin;</p>
<p>在 CLASSPATH增加.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;（前面有点号和分号，后边结尾也有分号。 或者可以写成.;%JAVA_HOME%\lib如图所示，一样的效果。</p>
<h3 id="UNIX"><a href="#UNIX" class="headerlink" title="UNIX"></a>UNIX</h3><p>包括 Linux、Mac OS X 和 Solaris 环境下，在~/.profile、~/.bashrc或 ~/.bash_profile 文件末尾添加：</p>
<pre><code>export JAVA_HOME=/usr/java/jdk1.8.0_66
export PATH=$JAVA_HOME/bin:$PATH
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
</code></pre><p>其中：</p>
<pre><code>JAVA_HOME 是 JDK 安装目录
Linux 下用冒号“:”来分隔路径
$PATH 、$CLASSPATH、 $JAVA_HOME 是用来引用原来的环境变量的值
export 是把这三个变量导出为全局变量
</code></pre><p>比如，在 CentOS 下，需编辑/etc/profile文件。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试安装是否正确，可以在 shell 窗口，键入：</p>
<pre><code>$java -version
</code></pre><p>若能看到如下信息，则说明 JDK 安装成功：</p>
<pre><code>java version &quot;1.8.0_66&quot;
Java(TM) SE Runtime Environment (build 1.8.0_66-b17)
Java HotSpot(TM) 64-Bit Server VM (build 25.66-b17, mixed mode)
</code></pre><p>最好再执行下javac，以测试环境变量是否设置正确：</p>
<pre><code>$ javac
用法: javac &lt;options&gt; &lt;source files&gt;
其中, 可能的选项包括:
  -g                         生成所有调试信息
  -g:none                    不生成任何调试信息
  -g:{lines,vars,source}     只生成某些调试信息
  -nowarn                    不生成任何警告
  -verbose                   输出有关编译器正在执行的操作的消息
  -deprecation               输出使用已过时的 API 的源位置
  -classpath &lt;路径&gt;            指定查找用户类文件和注释处理程序的位置
  -cp &lt;路径&gt;                   指定查找用户类文件和注释处理程序的位置
  -sourcepath &lt;路径&gt;           指定查找输入源文件的位置
  -bootclasspath &lt;路径&gt;        覆盖引导类文件的位置
  -extdirs &lt;目录&gt;              覆盖所安装扩展的位置
  -endorseddirs &lt;目录&gt;         覆盖签名的标准路径的位置
  -proc:{none,only}          控制是否执行注释处理和/或编译。
  -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] 要运行的注释处理程序的名称; 绕过默认的搜索进程
  -processorpath &lt;路径&gt;        指定查找注释处理程序的位置
  -parameters                生成元数据以用于方法参数的反射
  -d &lt;目录&gt;                    指定放置生成的类文件的位置
  -s &lt;目录&gt;                    指定放置生成的源文件的位置
  -h &lt;目录&gt;                    指定放置生成的本机标头文件的位置
  -implicit:{none,class}     指定是否为隐式引用文件生成类文件
  -encoding &lt;编码&gt;             指定源文件使用的字符编码
  -source &lt;发行版&gt;              提供与指定发行版的源兼容性
  -target &lt;发行版&gt;              生成特定 VM 版本的类文件
  -profile &lt;配置文件&gt;            请确保使用的 API 在指定的配置文件中可用
  -version                   版本信息
  -help                      输出标准选项的提要
  -A关键字[=值]                  传递给注释处理程序的选项
  -X                         输出非标准选项的提要
  -J&lt;标记&gt;                     直接将 &lt;标记&gt; 传递给运行时系统
  -Werror                    出现警告时终止编译
  @&lt;文件名&gt;                     从文件读取选项和文件名
</code></pre><p>  有时候java -version能够执行成功，但javac命令不成功的情况，一般是环境变量配置问题，请参阅上面“设置执行路径”章节内容，再仔细检测环境变量的配置。</p>

      
    </div><!-- .entry-content -->
    <!-- busuanzi  start -->
    
    <!-- busuanzi  end -->

    <footer class="entry-meta">
    <a href="/2020/08/04/java-getstarted/">
    <time datetime="2020-08-04T06:20:08.000Z" class="entry-date">
        2020-08-04
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/java/">java</a>
  </div>

    
    </footer>
</article>






  
    <article id="post-hexo-create-config" class="post-hexo-create-config post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2020/08/04/hexo-create-config/">hexo-create-config</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2020/08/04/hexo-create-config/" data-id="clesbyv2d004rpsia64j0kqwc" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="准备启程"><a href="#准备启程" class="headerlink" title="准备启程"></a>准备启程</h1><p>一旦安装了Hexo,运行以下命令初始化Hexo在<code>目录</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ cnpm install</span><br></pre></td></tr></table></figure></p>
<p>一旦初始化，你的项目文件夹是这个样子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── scripts</span><br><span class="line">├── <span class="built_in">source</span></span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure></p>
<p>下面依次介绍上面各个文件或者目录的用途：</p>
<ul>
<li><code>_config.yml</code>站点配置文件，很多全局配置都在这个文件中。</li>
<li><code>package.json</code> 应用数据。从它可以看出hexo版本信息，以及它所默认或者说依赖的一些组件。</li>
<li><code>scaffolds</code> 模版文件。当你创建一篇新的文章时，hexo会依据模版文件进行创建，主要用在你想在每篇文章都添加一些共性的内容的情况下。</li>
<li><code>scripts</code> 放脚本的文件夹， 就是放js文件的地方</li>
<li><code>source</code> 这个文件夹就是放文章的地方了，除了文章还有一些主要的资源，比如文章里的图片，文件等等东西。这个文件夹最好定期做一个备份，丢了它，整个站点就废了。</li>
<li><code>themes</code> 主题文件夹。</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="config-yml配置文件"><a href="#config-yml配置文件" class="headerlink" title="_config.yml配置文件"></a>_config.yml配置文件</h3><p>站点配置文件，你可以在这里进行大多数配置。</p>
<h3 id="网站设置"><a href="#网站设置" class="headerlink" title="网站设置"></a>网站设置</h3><table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td>站点名字，也就是html的title，会显示在浏览器标签上</td>
</tr>
<tr>
<td>subtitle</td>
<td>站点副标题，会显示在首页上，可以不填</td>
</tr>
<tr>
<td>description</td>
<td>站点描述，可以不填</td>
</tr>
<tr>
<td>author</td>
<td>作者名称</td>
</tr>
<tr>
<td>language</td>
<td>语言</td>
</tr>
<tr>
<td>timezone</td>
<td>站点时区，默认是电脑时间</td>
</tr>
</tbody>
</table>
<h3 id="链接设置"><a href="#链接设置" class="headerlink" title="链接设置"></a>链接设置</h3><table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>url</td>
<td>站点网址</td>
</tr>
<tr>
<td>root</td>
<td>站点根目录</td>
</tr>
<tr>
<td>permalink</td>
<td>文章的永久网址链接，默认是<code>:year/:month/:day/:title/</code>，指的什么意思？比如我一篇叫『love』的文章是在2012年1月1日写的，那么它对应的链接就是<code>http://yoururl/2012/01/01/love/</code></td>
</tr>
<tr>
<td>permalink_default</td>
</tr>
</tbody>
</table>
<blockquote>
<p>如果网址是次级目录，比如：<code>http://example.com/blog</code>，那么就要设置url为<code>http://example.com/blog</code>，并且root要设置为<code>/blog/</code>。</p>
</blockquote>
<h3 id="目录设置"><a href="#目录设置" class="headerlink" title="目录设置"></a>目录设置</h3><table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>source_dir</td>
<td>source目录，默认值为source</td>
</tr>
<tr>
<td>public_dir</td>
<td>public目录，静态网站生成的地方，默认值为public</td>
</tr>
<tr>
<td>tag_dir</td>
<td>tag目录</td>
</tr>
<tr>
<td>archive_dir</td>
<td>Archive目录</td>
</tr>
<tr>
<td>category_dir</td>
<td>分类目录</td>
</tr>
<tr>
<td>code_dir</td>
<td>代码目录</td>
</tr>
<tr>
<td>i18n_dir</td>
<td>i18n目录</td>
</tr>
<tr>
<td>skip_render</td>
<td>不想被渲染的路径</td>
</tr>
</tbody>
</table>
<h3 id="写作设置"><a href="#写作设置" class="headerlink" title="写作设置"></a>写作设置</h3><table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>new_post_name</td>
<td>新建文章默认文件名，默认值为 :title.md，比如你执行命令hexo new hello，就会默认在_post目录下创建一个hello.md的文件</td>
</tr>
<tr>
<td>default_layout</td>
<td>默认布局</td>
</tr>
<tr>
<td>titlecase</td>
<td></td>
</tr>
<tr>
<td>external_link</td>
<td>在新标签中打开一个外部链接，默认为true</td>
</tr>
<tr>
<td>filename_case</td>
<td>转换文件名，1代表小写；2代表大写；默认为0，意思就是创建文章的时候，是否自动帮你转换文件名，默认就行，意义不大</td>
</tr>
<tr>
<td>render_drafts</td>
<td>是否渲染_drafts目录下的文章，默认为false</td>
</tr>
<tr>
<td>post_asset_folder</td>
<td>是否启用Asset Folder，默认为false，至于什么是Asset Folder，后面有讲解</td>
</tr>
<tr>
<td>relative_link</td>
<td>使链接相对于根文件夹，默认false</td>
</tr>
<tr>
<td>future</td>
<td>是否显示未来日期文章，默认为true</td>
</tr>
<tr>
<td>highlight</td>
<td>代码块设置</td>
</tr>
</tbody>
</table>
<h3 id="分类-amp-标签"><a href="#分类-amp-标签" class="headerlink" title="分类 &amp; 标签"></a>分类 &amp; 标签</h3><table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>default_category</td>
<td>默认分类，默认为无分类，当然你可以设置一个默认分类。</td>
</tr>
<tr>
<td>category_map</td>
<td>分类缩略名</td>
</tr>
<tr>
<td>tag_map</td>
<td>标签缩略名</td>
</tr>
</tbody>
</table>
<h3 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h3><p>Hexo使用的<a href="http://momentjs.com/" target="_blank" rel="noopener">Moment.js</a>来处理时间的。<br>| 配置         | 描述|<br>| ———– |———————————————|<br>| date_format       |日期格式，默认为MMM D YYYY，一般我们喜欢使用YYYY-MM-DD的格式，其他格式模版可以查看<a href="http://momentjs.com/" target="_blank" rel="noopener">Moment.js</a>|<br>| time_format    |时间格式，默认为H:mm:ss|</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>per_page</td>
<td>一页显示多少篇文章，0 为不分页，默认值为 10</td>
</tr>
<tr>
<td>pagination_dir</td>
<td>分页目录，默认值为page</td>
</tr>
</tbody>
</table>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>theme</td>
<td>主题配置，此处填上主题名就OK了，当然在themes目录下一定要有你配置的主题文件夹</td>
</tr>
<tr>
<td>deploy</td>
<td>部署配置，将本地public目录也就是网站部署到服务器上的配置</td>
</tr>
</tbody>
</table>
<h3 id="package-json文件"><a href="#package-json文件" class="headerlink" title="package.json文件"></a>package.json文件</h3><p>应用数据，默认安装了 <code>EJS</code>，<code>Stylus</code> 和 <code>Markdown</code> 来渲染。如果你不需要可以卸载它们。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"hexo-site"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"hexo"</span>: &#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">""</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"hexo"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-archive"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-category"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-index"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-tag"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-ejs"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-stylus"</span>: <span class="string">"^0.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-marked"</span>: <span class="string">"^0.2.4"</span>,</span><br><span class="line">    <span class="attr">"hexo-server"</span>: <span class="string">"^0.1.2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p>脚手架文件夹。当你创建一个新文章,Hexo基于<code>scaffolds</code>文件夹里的类型来创建。</p>
<h3 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h3><p>脚本文件夹。扩展Hexo最简单的方法，它会自动执行这个文件夹下的JavaScript文件。</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure>
<p>初始化一个网站。如果没有提供<code>folder</code>,Hexo会在当前目录设置网站。</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>创建一篇文章，如果不指定layout，那么就使用<code>_config.yml</code>中<code>default_layout</code>的值，标题中如果有空格，将整个<code>title</code>放到引号中。<br>比如，<code>hexo new &quot;hello world&quot;</code>创建一篇叫hello world的文章。</p>
<h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>生成静态文件：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-d</code>, <code>--deploy</code></td>
<td>生成完后直接部署</td>
</tr>
<tr>
<td><code>-w</code>, <code>--watch</code></td>
<td>监控文件的改变</td>
</tr>
</tbody>
</table>
<h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>发布为草稿</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>启动一个本地服务，默认情况下访问 <code>http://localhost:4000/</code></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-p</code>, <code>--port</code></td>
<td>指定端口</td>
</tr>
<tr>
<td><code>-s</code>, <code>--static</code></td>
<td>仅服务静态文件</td>
</tr>
<tr>
<td><code>-l</code>, <code>--log</code></td>
<td>开启日志</td>
</tr>
</tbody>
</table>
<h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>部署你的站点</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-g</code>, <code>--generate</code></td>
<td>表示在部署前先重新生成一下站点</td>
</tr>
</tbody>
</table>
<h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure>
<p>渲染文件</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-o</code>, <code>--output</code></td>
<td>输出到指定文件，我没用过</td>
</tr>
</tbody>
</table>
<h3 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo migrate &lt;<span class="built_in">type</span>&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://hexo.io/docs/migration.html" target="_blank" rel="noopener">迁移</a>到其他模块的命令。</p>
<h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
<p>删除缓存文件<code>db.json</code>以及生成的public目录，当你修改了某些样式或者配置时，如果发现<code>hexo g</code>后也没有反应，就可以执行一下这个命令。</p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo list &lt;<span class="built_in">type</span>&gt;</span><br></pre></td></tr></table></figure>
<p>列出所有路由</p>
<h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo version</span><br></pre></td></tr></table></figure>
<p>显示hexo的版本信息到控制台</p>
<h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><h3 id="Safe-mode"><a href="#Safe-mode" class="headerlink" title="Safe mode"></a>Safe mode</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --safe</span><br></pre></td></tr></table></figure>
<p>安全模式，使所有插件和脚本不生效</p>
<h3 id="Debug-mode"><a href="#Debug-mode" class="headerlink" title="Debug mode"></a>Debug mode</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --debug</span><br></pre></td></tr></table></figure>
<p>日志详细信息输出到终端。</p>
<h3 id="Silent-mode"><a href="#Silent-mode" class="headerlink" title="Silent mode"></a>Silent mode</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --silent</span><br></pre></td></tr></table></figure>
<p>静默模式，不在终端上显示任何信息</p>
<h3 id="Customize-config-file-path"><a href="#Customize-config-file-path" class="headerlink" title="Customize config file path"></a>Customize config file path</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --config custom.yml</span><br></pre></td></tr></table></figure>
<p>使用一个自定义配置文件替换默认<code>_config.yml</code></p>
<h3 id="Display-drafts"><a href="#Display-drafts" class="headerlink" title="Display drafts"></a>Display drafts</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --draft</span><br></pre></td></tr></table></figure>
<p>显示草稿文章（位于<code>source/_drafts</code>目录下）</p>
<h3 id="Customize-CWD"><a href="#Customize-CWD" class="headerlink" title="Customize CWD"></a>Customize CWD</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --cwd /path/to/cwd</span><br></pre></td></tr></table></figure>
<p>自定义当前工作目录路径，假如你没在工作目录下，可以使用这个命令指定一下工作目录路径</p>

      
    </div><!-- .entry-content -->
    <!-- busuanzi  start -->
    
    <!-- busuanzi  end -->

    <footer class="entry-meta">
    <a href="/2020/08/04/hexo-create-config/">
    <time datetime="2020-08-04T03:20:09.000Z" class="entry-date">
        2020-08-04
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/hexo/">hexo</a>
  </div>

    
    </footer>
</article>






  
  
    <nav id="pagination">
      <nav id="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
      </nav>
    </nav>
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value name="s" id="s">
        <input type="submit" id="searchsubmit" value="搜索">
    </div>
</form></aside>
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-content">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AES/">AES</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/">JS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Markdown/">Markdown</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Openoffice/">Openoffice</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/POI/">POI</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SVN/">SVN</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shell/">Shell</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud-Spring-Boot-微服务/">Spring Cloud Spring Boot 微服务</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Springboot/">Springboot</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WeCaht/">WeCaht</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/console/">console</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/github/">github</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vscode/">vscode</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端学习/">前端学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/加密算法/">加密算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随记/">随记</a><span class="category-list-count">6</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2023/03/03/前端学习/">前端学习</a>
          </li>
        
          <li>
            <a href="/2021/11/10/关于Java 23种设计模式/">关于Java 23种设计模式</a>
          </li>
        
          <li>
            <a href="/2021/11/10/java生命周期/">java生命周期</a>
          </li>
        
          <li>
            <a href="/2020/09/03/webpack-spritesmith/">webpack中如何使用雪碧图</a>
          </li>
        
          <li>
            <a href="/2020/08/13/work-wechat-start/">企业微信小程序开发流程</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2023 花皮松
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
    <!-- busuanzi start -->
    
    <!-- busuanzi end -->
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>