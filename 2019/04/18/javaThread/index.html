<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  <meta name="description" content="进程和线程的区别进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。
线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。
线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。
多进程是指操作">
  

  
  
  
  
  
  
  <title>java 线程 | 随记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="进程和线程的区别进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。 线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。 线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。 多进程是指操作系统能同时运行多个任务（程序）。 多线程是指在同一程序中有多个顺序流在执行。  多线程的存在其实就是">
<meta property="og:type" content="article">
<meta property="og:title" content="java 线程">
<meta property="og:url" content="http://yoursite.com/2019/04/18/javaThread/index.html">
<meta property="og:site_name" content="随记">
<meta property="og:description" content="进程和线程的区别进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。 线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。 线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。 多进程是指操作系统能同时运行多个任务（程序）。 多线程是指在同一程序中有多个顺序流在执行。  多线程的存在其实就是">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-08-13T01:28:12.620Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java 线程">
<meta name="twitter:description" content="进程和线程的区别进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。 线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。 线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。 多进程是指操作系统能同时运行多个任务（程序）。 多线程是指在同一程序中有多个顺序流在执行。  多线程的存在其实就是">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src="//push.zhanzhang.baidu.com/push.js"></script>
</head></html>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="随记" rel="home">随记</a>
      </h1>
      
        <h2 class="site-description hitokoto"></h2>
        <script type="text/javascript" src="https://v1.hitokoto.cn/?encode=js"></script>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main"><article id="post-javaThread" class="post-javaThread post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title article-title">
      java 线程
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/04/18/javaThread/" data-id="cksik2u2f0054owifug5knx7y" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><pre><code>进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。
线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。
线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。
多进程是指操作系统能同时运行多个任务（程序）。
多线程是指在同一程序中有多个顺序流在执行。

多线程的存在其实就是“最大限度的利用cpu资源”，当某一个线程的处理不需要占用cpu而之和I/O打交道的时候，让需要占用cpu资源的其他线程有机会获得cpu资源。从根本上说，这就是说多线程编程的目的。
多线程目的： 使用多线程，可以帮助我们编写出cpu最大利用率的高效程序，使得空闲时间降到最低

在java中要想实现多线程：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">继续Thread类</span><br><span class="line">实现Runable接口</span><br><span class="line">通过Callable创建线程</span><br><span class="line">线程池来实现</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="ExecutorService-创建线程池"><a href="#ExecutorService-创建线程池" class="headerlink" title="ExecutorService  创建线程池"></a>ExecutorService  创建线程池</h3><pre><code>// 创建一个可缓存的线程池，调用execute将重用以前构成的线程（如果线程可用）。
// 如果没有可用的线程，则创建一个新线程并添加到池中。终止并从缓存中移出那些已有60秒钟未被使用的线程。
Executors.newCachedThreadPool();
// 创建固定数目的线程池
Executors.newFixedThreadPool(1);
// 创建一个单线程化的Executor
Executors.newSingleThreadExecutor();
// 创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Time类。
Executors.newScheduledThreadPool(1);
</code></pre><p> 为什么不推荐通过Executors直接创建线程池</p>
<pre><code>原因：
java中BlockingQueue主要有两种实现，分别是ArrayBlockingQueue和LinkedBlockingQueue。ArrayBlockingQueue是一个用数组实现的有界阻塞队列，必须设置容量。
而LinkedBlockingQueue是一个用链表实现的有界阻塞队列，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE.

查看new SingleExecutor时的源码可以发现，在创建LinkedBlockingQueue时，并未指定容量。
此时，LinkedBlockingQueue就是一个无边界队列，对于一个无边界队列来说，是可以不断的向队列中加入任务的，这种情况下就有可能因为任务过多而导致内存溢出的问题。
</code></pre><p> 创建线程池的正确方法：</p>
<pre><code>避免使用Executors创建线程池，主要是避免使用其中的默认实现，那么我们可以自己直接调用ThreadPoolExecutor的构造函数自己创建线程池。在创建的同时，给BlockQueue指定容量就可以了。

ExecutorService executor = new ThreadPoolExecutor(10, 10,
        60L, TimeUnit.SECONDS,
        new ArrayBlockingQueue&lt;Runnable&gt;(10));

这种情况下，一旦提交的线程数超过当前可用线程数时，就会抛出java.util.concurrent.RejectedExecutionException，
这是因为当前线程池使用的队列是有界边界队列，队列已经满了便无法继续处理新的请求。但是异常（Exception）总比发生错误（Error）要好。
</code></pre><h3 id="ExecutorService-shutdown-、ShutdownNow-、awaitTermination"><a href="#ExecutorService-shutdown-、ShutdownNow-、awaitTermination" class="headerlink" title="ExecutorService  shutdown()、ShutdownNow()、awaitTermination()"></a>ExecutorService  shutdown()、ShutdownNow()、awaitTermination()</h3><pre><code>shutdown() 停止接收新任务，原来的任务继续执行
    1、停止接收新的submit的任务；
    2、已经提交的任务（包括正在跑的和队列中等待的）,会继续执行完成；
    3、等到第2步完成后，才真正停止；

ShutdownNow() 停止接收新任务，原来的任务停止执行
    1、跟 shutdown() 一样，先停止接收新submit的任务；
    2、忽略队列里等待的任务；
    3、尝试将正在执行的任务interrupt中断；
    4、返回未执行的任务列表；

awaitTermination(long timeOut, TimeUnit unit)：当前线程阻塞
    当前线程阻塞，直到：
    等所有已提交的任务（包括正在跑的和队列中等待的）执行完；
    或者 等超时时间到了（timeout 和 TimeUnit设定的时间）；
    或者 线程被中断，抛出InterruptedException

区别

    1、shutdown() 和 shutdownNow() 的区别
        shutdown() 只是关闭了提交通道，用submit()是无效的；而内部该怎么跑还是怎么跑，跑完再停。
        shutdownNow() 能立即停止线程池，正在跑的和正在等待的任务都停下了。
    2、shutdown() 和 awaitTermination() 的区别
        shutdown() 后，不能再提交新的任务进去；但是 awaitTermination() 后，可以继续提交。
        awaitTermination()是阻塞的，返回结果是线程池是否已停止（true/false）；shutdown() 不阻塞。

总结
    1、优雅的关闭，用 shutdown()
    2、想立马关闭，并得到未执行任务列表，用shutdownNow()
    3、优雅的关闭，并允许关闭声明后新任务能提交，用 awaitTermination()
    4、关闭功能 【从强到弱】 依次是：shuntdownNow() &gt; shutdown() &gt; awaitTermination()
</code></pre><p>例：</p>
<p>1、扩展Thread类实现的多线程例子</p>
<pre><code>public static void main(String[] args) {
    MyThread T1 = new MyThread(&quot;A&quot;);
    MyThread T2 = new MyThread(&quot;B&quot;);
    T1.start();
    T2.start();
}
class MyThread extends Thread {
    private String name;
    public MyThread(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        for (int i = 0; i &lt; 5; i++) {
            System.out.println(name+&quot;:&quot;+i);
            try {
                sleep(1000); //休眠1秒，避免太快导致看不到同时执行
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }
}

结果：
   A:0
   B:0
   A:1
   B:1
   A:2
   B:2
   A:3
   B:3
   A:4
   B:4
</code></pre><p>2、实现Runnable 、 ExecutorService 接口的多线程例子</p>
<pre><code>    ExecutorService executor = new ThreadPoolExecutor(10, 10,
                     60L, TimeUnit.SECONDS,
                     new ArrayBlockingQueue&lt;Runnable&gt;(10));
    public static void main(String[] args) {
        // executor
        /*for (int i = 0; i &lt; Integer.MAX_VALUE; i++) {
            executor.execute(new SubThread());
        }*/

        // Runnable
        executor.execute(new MyRunnable());
    }

 // 1. Runnable
class SubThread implements Runnable {
    @Override
    public void run() {
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) { //do nothing
        }
    }
}

 // 2. Runnable
class MyRunnable implements Runnable{

    public void run(){
        System.out.println(&quot;Runnable:run()....&quot;);
        int i=0;
        while(i&lt;20){
            i++;
            for(int j=0;j&lt;1000000;j++);
            System.out.println(&quot;i=&quot;+i);
        }
    }
}
结果：
    Runnable:run()....
    i=1
    i=2
    i=3
    i=4
    i=5
    i=6
    i=7
    i=8
    i=9
    i=10
    i=11
    i=12
    i=13
    i=14
    i=15
    i=16
    i=17
    i=18
    i=19
    i=20
</code></pre><p>3、实现Callable接口的多线程例子  </p>
<pre><code>    ExecutorService executor = new ThreadPoolExecutor(10, 10,
                             60L, TimeUnit.SECONDS,
                             new ArrayBlockingQueue&lt;Runnable&gt;(10));
    public static void main(String[] args) {
        // Callable
        Future future1 = executor.submit(new MyCallable());
        Future future2 = executor.submit(new MyCallable());
        try {
            System.out.println(future1.get());
            System.out.println(future2.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
        // 停止接收新任务，原来的任务继续执行
        executor.shutdown();
    }
class MyCallable implements Callable&lt;String&gt; {
    public String call() throws Exception {
        System.out.println(&quot;开始执行Callable&quot;);
        String[] ss={&quot;zhangsan&quot;,&quot;lisi&quot;};
        long[] num=new long[2];
        for(int i=0;i&lt;1000000;i++){
            num[(int)(Math.random()*2)]++;
        }

        if(num[0]&gt;num[1]){
            return ss[0];
        }else if(num[0]&lt;num[1]){
            throw new Exception(&quot;弃权!&quot;);
        }else{
            return ss[1];
        }
    }
}

结果;

开始执行Callable
开始执行Callable
zhangsan
zhangsan
</code></pre><h3 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h3><pre><code>1.wait和notify方法定义在Object类中，因此会被所有的类所继承。 这些方法都是final的，即它们都是不能被重写的，不能通过子类覆写去改变它们的行为。 而sleep方法是在Thread类中是由native修饰的，本地方法。
2.当线程调用了wait()方法时，它会释放掉对象的锁。 
    Thread.sleep()，它会导致线程睡眠指定的毫秒数，但线程在睡眠的过程中是不会释放掉对象的锁的。
3.正因为wait方法会释放锁，所以调用该方法时，当前的线程必须拥有当前对象的monitor，也即lock，就是锁。
要确保调用wait()方法的时候拥有锁，即，wait()方法的调用必须放在synchronized方法或synchronized块中。
4.sleep方法时间到，线程处于临时阻塞状态或者运行状态。 wait方法如果没有被设置时间，就必须要通过notify或者notifyAll来唤醒。
</code></pre><p>notify()</p>
<pre><code>notify()方法会唤醒一个等待当前对象的锁的线程。 如果多个线程在等待，它们中的一个将会选择被唤醒。
这种选择是随意的，和具体实现有关。（线程等待一个对象的锁是由于调用了wait方法中的一个）。

被唤醒的线程是不能被执行的，需要等到当前线程放弃这个对象的锁。
被唤醒的线程将和其他线程以通常的方式进行竞争，来获得对象的锁。也就是说，被唤醒的线程并没有什么优先权，也没有什么劣势，对象的下一个线程还是需要通过一般性的竞争。
且notify方法和wait一样，是需要放在synchronized方法或synchronized块中。

notifyAll()方法会唤醒在此对象监视器上等待的所有线程。线程通过调用其中一个 wait 方法，在对象的监视器上等待。
直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；
</code></pre><p>   尽量使用notifyAll()，notify()非常容易导致死锁。</p>
<h2 id="ThreadLocal-的简单使用及实现的原理"><a href="#ThreadLocal-的简单使用及实现的原理" class="headerlink" title="ThreadLocal 的简单使用及实现的原理"></a>ThreadLocal 的简单使用及实现的原理</h2><h3 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h3><pre><code>ThreadLocal的实例代表了一个线程局部的变量，每条线程都只能看到自己的值，并不会意识到其它的线程中也存在该变量。

它采用采用空间来换取时间的方式，解决多线程中相同变量的访问冲突问题。
</code></pre><h3 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h3><pre><code>ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。
</code></pre><h3 id="ThreadLocal的核心机制"><a href="#ThreadLocal的核心机制" class="headerlink" title="ThreadLocal的核心机制"></a>ThreadLocal的核心机制</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每个Thread线程内部都有一个Map。</span><br><span class="line">Map里面存储线程本地对象（key）和线程的变量副本（value）</span><br><span class="line">但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。</span><br></pre></td></tr></table></figure>
</code></pre><p>所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰</p>
<h3 id="ThreadLocal的简单使用"><a href="#ThreadLocal的简单使用" class="headerlink" title="ThreadLocal的简单使用"></a>ThreadLocal的简单使用</h3><p>下面的例子中，创建了两个线程，然后线程对各自的局部变量进行递增的操作。每个线程中的局部变量的初始值都是100。</p>
<pre><code>public class ThreadLocalTest {
    // ThreadLocal中的值
    static class Bank {
        ThreadLocal&lt;Integer&gt; t = new ThreadLocal&lt;Integer&gt;() {
            // 重写里面的方法就可以修改初始值了
            @Override
            protected Integer initialValue(){
                return 100;
            }
        };
        public int get() {
            return t.get();
        }
        public void set() {
            // 获取值
            t.set(t.get() + 10);
        }
        public void set(Integer value) {
            // 获取值
            t.set(value);
        }
    }
    /** 定义对ThreadLocal的操作，也就是在原来的基础上进行加10的操作，然后打印出结果。 */
    // 对ThreadLocal的操作
    static class Transfer implements Runnable {
        Bank bank;
        public Transfer(Bank bank) {
            this.bank = bank;
        }
        @Override
        public void run() {
            for (int i = 0; i &lt; 10; i++) {
                //
                bank.set();
                // 输出不同线程的ThreadLocal的值
                System.out.println(Thread.currentThread() + &quot;：：：&quot; + bank.get());
            }
        }
    }
    /** 创建两个线程并启动，主线程等待这两个线程执行完成。最值得注意的就是主线程中输出的bank.get()，输出的初始值100。 */
    // 创建线程并等待线程执行完成
    public static void main(String[] args) throws InterruptedException {
        //
        Bank bank = new Bank();
        // bank.set(50);
        // 多个线程都是同时操作一个变量，但是不同线程的结果是互不影响的
        Transfer t = new Transfer(bank);
        Thread t1 = new Thread(t);
        t1.start();
        Thread t2 = new Thread(t);
        t2.start();
        t1.join();
        t2.join();
        // 需要注意的是，这个是main（） 线程中的变量，输出的是 ThreadLocal&lt;Integer&gt; t 的初始值， 也就是100
        System.out.println(bank.get());
    }
}
</code></pre><h3 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h3><p>ThreadLocal类提供如下几个核心方法：</p>
<pre><code>public T get() { }
public void set(T value) { }
public void remove() { }
protected T initialValue() { }
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get()方法用于获取当前线程的副本变量值。</span><br><span class="line">set()方法用于保存当前线程的副本变量值。</span><br><span class="line">initialValue()为当前线程初始副本变量值。</span><br><span class="line">remove()方法移除当前前程的副本变量值</span><br></pre></td></tr></table></figure>
</code></pre><p>每个Thread的对象都有一个ThreadLocalMap，当创建一个ThreadLocal的时候，就会将该ThreadLocal对象添加到该Map中，其中键就是ThreadLocal，值可以是任意类型。</p>
<p>在该类中，重要的方法就是两个：set()和get()方法。当调用ThreadLocal的get()方法的时候，会先找到当前线程的ThreadLocalMap，然后再找到对应的值。set()方法也是一样。</p>
<pre><code>public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings(&quot;unchecked&quot;)
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}

public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
</code></pre>
      
    </div><!-- .entry-content -->
    <!-- busuanzi  start -->
    
    <!-- busuanzi  end -->

    <footer class="entry-meta">
    <a href="/2019/04/18/javaThread/">
    <time datetime="2019-04-17T16:00:00.000Z" class="entry-date">
        2019-04-18
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

    
    </footer>
</article>


    
<nav class="nav-single">
    <h3 class="assistive-text">文章导航</h3>
    
        <span class="nav-previous"><a href="/2019/04/18/oracle和mysql区别/" rel="prev"><span class="meta-nav">←</span> MySQL与Oracle的区别</a></span>
    
    
        <span class="nav-next"><a href="/2019/04/17/Spring Cloud高可用/" rel="next">Spring Cloud构建微服务架构  高可用 <span class="meta-nav">→</span></a></span>
    
</nav><!-- .nav-single -->







</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value name="s" id="s">
        <input type="submit" id="searchsubmit" value="搜索">
    </div>
</form></aside>
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-content">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AES/">AES</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/">JS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Markdown/">Markdown</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Openoffice/">Openoffice</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/POI/">POI</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SVN/">SVN</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shell/">Shell</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud-Spring-Boot-微服务/">Spring Cloud Spring Boot 微服务</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Springboot/">Springboot</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WeCaht/">WeCaht</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/console/">console</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/github/">github</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vscode/">vscode</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/加密算法/">加密算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随记/">随记</a><span class="category-list-count">6</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2020/09/03/webpack-spritesmith/">webpack中如何使用雪碧图</a>
          </li>
        
          <li>
            <a href="/2020/08/13/work-wechat-start/">企业微信小程序开发流程</a>
          </li>
        
          <li>
            <a href="/2020/08/11/node-process-argv/">node.js获取命令参数</a>
          </li>
        
          <li>
            <a href="/2020/08/05/github-hosts/">GitHub 访问加速方法</a>
          </li>
        
          <li>
            <a href="/2020/08/05/vscode-settings-sync/">vscode-settings-sync</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2021 花皮松
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
    <!-- busuanzi start -->
    
    <!-- busuanzi end -->
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>